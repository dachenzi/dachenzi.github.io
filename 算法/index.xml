<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法s on dahl&#39;s blog</title>
    <link>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法s on dahl&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>dahlhin.li@gmail.com (daxin.li)</managingEditor>
    <webMaster>dahlhin.li@gmail.com (daxin.li)</webMaster>
    <copyright>(c) 2015 Lee xin.</copyright><atom:link href="https://dachenzi.github.io/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-冒泡排序</title>
      <link>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>{% raw %}
1 冒泡算法  冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法,它属于交换排序，主要的方式是通过两辆比较，交换位置，如同水泡咕嘟咕嘟往上冒一样，需要称他为&amp;rsquo;冒泡排序&#39;。
2 具体的排序方法  它重复地走访过要排序的元素列，依次比较两个相邻的元素，按照一定的顺序(升序/降序)进行比较，如果是升序，那么当右边的数小于左边的数，那么就会进行交换，直到没有相邻的元素需要交换后停止。此时表示该列元素已经排序完成。
3 分析  根据定义，我们知道最少需要两个循环，第一个循环遍历所有元素，内层循环则进行两两比较及换位的操作。
升序分析：
初始列表：[9,1,3,2,6,8,7,4,5]
第一趟,第一次：比较9和1的大小情况，9大于1，需要调换位置[1,9,3,2,6,8,7,4,5]
第一趟,第二次：比较9和3的大小情况，9大于3，需要调换位置[1,3,9,2,6,8,7,4,5]
第一趟,第三次：比较9和2的大小情况，9大于2，需要调换位置[1,3,2,9,6,8,7,4,5]
第一趟,第四次：比较9和6的大小情况，9大于6，需要调换位置[1,3,2,6,9,8,7,4,5]
第一趟,第五次：比较9和8的大小情况，9大于8，需要调换位置[1,3,2,6,8,9,7,4,5]
第一趟,第六次：比较9和7的大小情况，9大于7，需要调换位置[1,3,2,6,8,7,9,4,5]
第一趟,第七次：比较9和4的大小情况，9大于4，需要调换位置[1,3,2,6,8,7,4,9,5]
第一趟,第八次：比较9和5的大小情况，9大于5，需要调换位置[1,3,2,6,8,7,4,5,9]
第一趟确定了一个最大数，放在最右边。接下来在除他以外的未排序空间进行第二趟循环，确认第二大的数放在最油边
第二趟初始列表：[1,3,2,6,8,7,4,5,9]
第二趟,第一次：比较1和3的大小情况，1小于3，不用调换位置[1,3,2,6,8,7,4,5,9]
第二趟,第二次：比较3和2的大小情况，3大于2，需要调换位置[1,2,3,6,8,7,4,5,9]
第二趟,第三次：比较3和6的大小情况，3小于6，不用调换位置[1,2,3,6,8,7,4,5,9]
第二趟,第四次：比较6和8的大小情况，6小于8，不用调换位置[1,2,3,6,8,7,4,5,9]
第二趟,第五次：比较8和7的大小情况，8大于7，需要调换位置[1,2,3,6,7,8,4,5,9]
第二趟,第六次：比较8和4的大小情况，8大于4，需要调换位置[1,2,3,6,7,4,8,5,9]
第二趟,第七次：比较8和5的大小情况，8大于5，需要调换位置[1,2,3,6,7,4,5,8,9] 第二趟找到了第二大的书，放在了第一趟找出的最大数的左边。
4 实现  通过观察可以得知，外层循环每次都可以确定一个最大数，放在最右边，而内层循环，判断的次数是依次减少的，因为上一堂确定的最大数，下一趟就不必再进行对比，根据这个情况编写代码进行排序。
lst = [1,9,3,2,6,8,7,4,5] length = len(lst) for i in range(length): flag = False # 退出开关 for j in range(length - i - 1): if lst[j] &amp;gt; lst[j+1]: flag = True # 如果本次交换了位置，开关位置为关 lst[j], lst[j+1] = lst[j+1], lst[j] if not flag:break # 当开关为开时，表示本次判断没有交换，没有交换，则认为已经排序完毕 print(lst) 5 总结  冒泡法需要数据一轮一轮的比较 可以设定一个标记判断是否有数据交换发生，如果没有发生交换，可以结束排序，因为此时已经排序完毕了，如果发生了交换，那么就需要继续下一轮排序了 最差的排序情况是，出事顺序与目标顺序完全相反，遍历次数1,&amp;hellip;n-1之和： n(n-1)/2 最好的排序情况是，初始顺序与目标顺序完全相同,遍历次数n-1 时间复杂度为O(n**2) {% endraw %}  </description>
    </item>
    
    <item>
      <title>2-选择排序</title>
      <link>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>{% raw %}
 1 选择排序介绍 2 基本选择排序 3 选择排序的优化  3.1 二元选择排序 3.2 同时排序最大和最小值 3.3 索引混乱 3.4 代码优化   4 总结  1 选择排序介绍  选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置(升序或者降序)，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对n个元素的表进行排序总共进行至多n-1次交换，所以它的时间复杂度是n(n-1),不包括这个函数的低阶项和首项系数后用大O表示法为：O(n^2)。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。
2 基本选择排序  现有序列[1, 9, 8, 5, 6, 7, 4, 3, 2]，请使用选择排序对该列表进行排序。
nums = [1, 9, 8, 5, 6, 7, 4, 3, 2] length = len(nums) for i in range(length-1): max_index=i for j in range(i+1,length): if nums[max_index] &amp;lt; nums[j]: max_index = j if i !</description>
    </item>
    
    <item>
      <title>3-直接插入排序</title>
      <link>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/3-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/%E7%AE%97%E6%B3%95/3-%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>{% raw %}
 1 直接插入排序 2 分析过程 3 关于存储中间变量 4 代码编写 5 总结  1 直接插入排序 直接插入排序属于比较简单的排序算法，基本原理：
 在未排序序列中，构建一个子排序序列，直至全部数据排列完成。 将待排序的数，插入到已经排序的序列中合适的位置。 增加一个哨兵(中间变量)，放入待比较的值，让它和后面已经排好序的序列比较，找到合适的插入点。  2 分析过程  看上面的定义可能不是特别清楚其原理，那么请看来自维基百科的动态演示图：
以图中列表为例，下面是分析过程：
[6，5，3，1，8，7，2，4]  假定已排序序列在列表的最左边初始为空。 第一趟循环将第一个元素6，赋值给中间变量，然后在已排序区一一比较，由于已排序区初始为空，所以元素6被直接放入已排序区 第二趟循环将第二个元素5，赋值给中间变量，然后在已排序中开始比较，循环开始，由于已排序区中只有1个元素，所以只需要比对1次，5比6小，先将元素6向右移动一位，然后将5赋值给6的原位上。此时排序后的元素排列如下：  [5，6，3，1，8，7，2，4]  第三趟循环将第三个元素3，赋值给中间变量，然后在已排序中开始比较，循环开始，由于已排序区中有2个元素，所以需要比对2次，3比6小，将6向右移动一位，继续循环，3比5小，将5向右移动一位，然后把3放在原来5的位置上。此时排序后的元素排列如下：  [3, 5, 6, 1, 8, 7，2，4]  第四趟循环将第四个元素1，赋值给中间变量，然后在已排序中开始比较，循环开始，最后把1放在原来3的位置上。此时排序后的元素排列如下：  [1，3，5，6，8, 7，2，4]  第五趟循环将第五个元素8，赋值给中间变量，然后在已排序中开始比较，循环开始，由于8大于6，会直接将8赋给当前已排序区最大值的右边。此时排序后的元素排列如下：  [1，3，5，6，8, 7，2，4] 以此类推。直到排序完成
3 关于存储中间变量  我们可以单独使用一个中间变量来存储待排序的元素，也可以在列表的首部插入一个变量用来存储待排序的元素。因为代码量以及索引计算方便等原因，这里使用在列表的首部插入一个元素一个变量用来存储待排序的元素的方式编写代码。
4 代码编写 lst = [6, 5, 3, 1, 8, 7, 2, 4] lst = [0] + lst # [0, 6, 5, 3, 1, 8, 7, 2, 4] length = len(lst) for i in range(2, length): # lst[0] = lst[i] j = i - 1 if lst[j] &amp;gt; lst[0]: while lst[j] &amp;gt; lst[0]: lst[j+1] = lst[j] lst[j] = lst[0] j -= 1 print(lst[1:])  因为在列表头部添加了一个元素用于记录待交换元素，所以应该从索引为2的元素，开始，拿来和已经排序好的序列进行比较(认为6已经在排序空间了) 由于无法判断已排序区到底排了几次，所以只能使用while循环，直到排序区的某个元素比待排序元素小时，表示在上一次插入过后，排序区已经排序完毕，这时就可以退出循环了。  附上使用单个变量的方法： lst = [6, 5, 3, 1, 8, 7, 2, 4] length = len(lst) temp = 0 for i in range(1, length): # 7 temp = lst[i] j = i - 1 # 6 if lst[j] &amp;gt; temp: while lst[j] &amp;gt; temp: lst[j+1], lst[j] = lst[j], temp j -= 1 if j &amp;lt; 0: # 不限制j的索引时，j会取到-1.</description>
    </item>
    
  </channel>
</rss>
