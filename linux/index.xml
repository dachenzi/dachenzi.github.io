<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linuxes on dahl&#39;s blog</title>
    <link>https://dachenzi.github.io/linux/</link>
    <description>Recent content in Linuxes on dahl&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>dahlhin.li@gmail.com (daxin.li)</managingEditor>
    <webMaster>dahlhin.li@gmail.com (daxin.li)</webMaster>
    <copyright>(c) 2015 Lee xin.</copyright><atom:link href="https://dachenzi.github.io/linux/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-ansible</title>
      <link>https://dachenzi.github.io/linux/tools/1-ansible/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/tools/1-ansible/</guid>
      <description>{% raw %}
文章目录 1 简介  1.1 基本组成 1.2 命令介绍 1.3 Inventory文件介绍   2 Ansible配置文件介绍  2.1 常用配置 2.2 ssh相关 2.3 权限提升相关   3 常用模块  3.1 setup 3.2 file 3.3 copy 3.4 command 3.5 shell 3.6 service 3.7 cron 3.8 filesystem 3.9 yum 3.10 user 3.11 synchronize 3.12 mount 3.12 template 3.13 get_url 3.14 unarchive 3.15 git 3.16 stat 3.17 sysctl   4 模块的返回值 5 YAML简介  5.</description>
    </item>
    
    <item>
      <title>1-docker入门介绍</title>
      <link>https://dachenzi.github.io/linux/container/1-docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/container/1-docker%E5%85%A5%E9%97%A8%E4%BB%8B%E7%BB%8D/</guid>
      <description>{% raw %}
1 虚拟化介绍 主流的虚拟机化方式：
 主机级虚拟化：虚拟化的是整个完整的物理硬件平台(VMware workstation) 容器级虚拟化：虚拟化的是一个个的用户空间  主机虚拟化两种类型的实现：
 Type-I:直接在硬件设备上安装虚拟机管理器一般叫hypervisor，然后再来创建虚拟机 Type-II:在宿主机上安装一个宿主机操作系统，再装一个VMM(viurtul Machine Manage) 虚拟机管理器，然后再来创建虚拟机（WMware、virtualbox等)  没有一个虚拟机是直接跑在硬件设备之上的。所以减少中间层，中间环境，就可以有效的提高效率。  由图可知，去掉虚拟机的内核以后，就需要直接在主机的用户空间内进行分割，形成多个用户态，在这些独立分割的用户空间内去运行应用程序。
2 容器技术  不同用户空间内，主机名肯定需要不相同、并且PID号、文件系统等，都应该相对隔离，所以每一个用户空间都应该存在以下七个部分：
 主机名/域名（UTS） 文件系统（Mount） - 树形结构 进程间通讯（IPC） 进程(PID) - 树形结构（归属与init或者本身就是init) 用户(User) 网络(Network)   Linux在内合层面通过使用名称空间(namespace)对以上六种资源进行的隔离进行直接支持，并通过系统调用直接输出。但是不同的内核版本对名称空间的支持不同，下面是六大资源实现的内核版本
   namespace 系统调用参数 隔离内容 内核版本     UTS CLONE_NEWUTS 主机和域名 2.6.19   IPC CLONE_NEWIPC 信号量、消息队列和共享内存 2.6.19   PID CLONE_NEWPID 进程编号 2.6.24   Network CLONE_NEWNET 网络设备、网络栈、端口等 2.</description>
    </item>
    
    <item>
      <title>1-平均负载</title>
      <link>https://dachenzi.github.io/linux/optimize/1-%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/optimize/1-%E5%B9%B3%E5%9D%87%E8%B4%9F%E8%BD%BD/</guid>
      <description>{% raw %}
1 平均负载 安装stress，sysstat包
yum install -y stress sysstat 其中：
 stress是一个Linux系统压力测试工具，可以用作异常进程，模拟平均负载升高的场景。 sysstat包含了常用的Linux性能工具，用来监控和分析系统的性能。（比如mpstat和pidstat）  mpstat：是一个常用的多喝    {% endraw %}</description>
    </item>
    
    <item>
      <title>1-源码安装缺少configure文件</title>
      <link>https://dachenzi.github.io/linux/questions/1-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E7%BC%BA%E5%B0%91configure%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/questions/1-%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85%E7%BC%BA%E5%B0%91configure%E6%96%87%E4%BB%B6/</guid>
      <description>{% raw %}
源代码中没有configure的软件安装方法 今天下载了一个旧版的GeoIP软件包，解压以后发现代码包中没有configure文件，现在这这里记录一下安装遇到的问题 网上大部分GeoIP下载地址已经失效，因为GeoIP新版本GeoIP2，所以这里附旧版Geoip的下载地址：GeoIP下载地址
生成configure文件的步骤 在软件包内执行如下命令：
 aclocal autoconf &amp;ndash;&amp;gt; 生成configure文件 autoheader(出现什么AC_CONFIG_HEADERS not found in configure.ac 可以忽略) automake --add-missing(出现ltmain.sh not found，需要执行autoreconf -ivf) &amp;ndash;&amp;gt; 会生成Makefile .in 文件  然后就会生成configure文件，继续按照软件的INSTALL/README文件开始安装即可
参考： 生成configure
{% endraw %}</description>
    </item>
    
    <item>
      <title>2-docker基本使用</title>
      <link>https://dachenzi.github.io/linux/container/2-docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/container/2-docker%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>{% raw %}
1 docker的基本结构 docker的架构图如下：  Client端 &amp;ndash;&amp;gt; docker client Hosts(Docker_Host,server端) &amp;ndash;&amp;gt; docker daemon Registries &amp;ndash;&amp;gt; docker registries   docker是一个采用C/S结构的应用程序。当我们运行docker daemon是，这台主机变成了Server端，它默认情况下通过监听socket来接受client端的请求，当然服务器端还支持其他两种类型套接字(IPv4，IPv6)，默认是unix socket套接字文件
PS：docker client 到 docker Host 使用的是也是HTTPS（docker HOST 遵循Restful风格）
docker中的资源和对象：（restful中的资源是可以支持增删改查的操作)
 images：镜像 containers：容器 networks：网络 volumes：存储卷 plugins：插件  1.1 server端  运行docker daemon的主机就变成了DOCKER_HOST主机,也就是server端，它内部主要包含两部分：
 Containers:容器 Images:镜像，来自于registry，镜像仓库，默认为docker hub，初始化是空的从远端下载(HTTP,HTTPS),默认为HTTPS，除非明确确认安全。  PS：镜像是静态的(文件)，容器是动态的，包含生命周期（类似进程）
1.2 仓库  docker提供的公共存储空间叫做docker hub,默认情况下我们的server都是从它那来下载镜像的，但是docker称它为 registry,那么为什么不不叫repository，而叫registry呢，其实它还包含了如下功能
 镜像存储 用户认证 可用镜像的索引(搜索索引)   所以registry不仅仅是一个仓库，而是一个应用程序，包含多个仓库(repository)，一个仓库用于存放一个应用程序的镜像(一般仓库名就是应用程序名)，单个仓库加标签，唯一标示一个镜像(图)，如果没有执行标签，那么就是最新版,当然还有稳定版的标签(stable)指向对应的版本。
2 安装及使用docker 基础平台需求：
 64bits CPU Linux Kernel 3.</description>
    </item>
    
    <item>
      <title>2-nginx安装echo模块</title>
      <link>https://dachenzi.github.io/linux/questions/2-nginx%E5%AE%89%E8%A3%85echo%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/questions/2-nginx%E5%AE%89%E8%A3%85echo%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
nginx 安装第三方echo模块 openresty是基于nginx的一个分支版本，echo模块用于打印出内置变量的值，这样可以方便我们知晓整个过程，便于排错，对于nginx来说，可以使用echo-nginx-module来添加echo模块。
添加echo-nginx-module模块   下载echo-nginx-module模块 echo-nginx-module下载地址
  解压后重新编译nginx 只需要在原有的nginx编译命令后添加如下命令
  $ ./configure ... ...--add-module=/opt/software/echo-nginx-module-0.61/ $ make &amp;amp;&amp;amp; make install 基本使用 在nginx.conf中使用 echo 即可输出打印的变量 nginx内置变量
比如nginx配置文件
location /hello { echo $http_user_agent echo $host } {% endraw %}</description>
    </item>
    
    <item>
      <title>3-docker镜像</title>
      <link>https://dachenzi.github.io/linux/container/3-docker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/container/3-docker%E9%95%9C%E5%83%8F/</guid>
      <description>{% raw %}
1 docker image 镜像  docker host 从docker registries 中获取镜像并存入到本地，所以要求docker host本地能够存储这种镜像，这种存储空间要求是一种特殊而且专用的文件系统(1.18 overlay2存储驱动) 镜像可以理解为应用程序的集装箱(docker(码头工人)负责转配这些集装箱) Docker镜像含有启动容器所需要的文件系统及其内容，因此，其用于创建并启动Docker容器
 采用分层构建机制，大体上分为两部分：最底层为bootfs，其之上为rootfs(图，rootfs层(/etc,/bin,/sbin等)，bootfs层)  bootfs：用于系统引导的文件系统，包括bootloader和kernel，容器启动完成后会被卸载以节约内存资源（从内存中移除) 底层为aufs/btrfs/overlay文件系统，来确保能够引导并启动一个用户空间 rootfs：位于bootfs之上，表现为docker容器的根 文件系统  传统模式中，系统启动之时，内核挂载rootfs时会首先将其挂载为“只读”模式，完整性自检完成后将其重新挂载为读写模式； docker中，rootfs由内核挂载为“只读”模式，而后通过“联合挂载”技术额外挂载一个“可写”层。   位于下层的镜像称为父镜像(parent image)，最底层的称为基础镜像(base image) 最上层为“可读写”层，其下的均为“只读”层。(图，可写层，http层，vim层，base image层，bootfs层)    专有文件系统  docker的这种分层构建，联合挂载，需要的是专有的文件系统的支持，比如Aufs、overlay2，brtfs等。
Aufs文件系统  Aufs：advanced multi-layered unification filesystem：高级多层统一文件系统
 用于为Linux文件系统实现”联合挂载“ aufs是之前的UnionFS的重新实现，2006年由Junjiro Okajima开发； Docker最初使用aufs作为容器文件系统层，它目前仍作为存储后端之一来支持； aufs的竞争产品是overlayfs，后者自从3.18版本开始被合并到Linux内核； docker的分层镜像，除了aufs、docker还支持btrfs，devicemapper和vfs等  在Ubuntu系统下，docker默认Ubuntu的aufs；而在Centos7上，用的是devicemapper(DM)；    devicemapper文件系统 overlay2文件系统 overlay2是一个抽象的二级文件系统，它需要构建在一个本地文件系统之上，这个文件系统就是xfs(extfs)
docker registry 启动容器时，docker daemon会视图从本地获取相关的镜像；本地镜像不存在时，其将从registry中下载该镜像并保存到本地；(图，docker Client ,http/https, Docker Daemon(stroage Driver, aufs,dm), Public Docker registry DockerHub, Private Docker Registry,Storage Driver)</description>
    </item>
    
    <item>
      <title>4-docker网络</title>
      <link>https://dachenzi.github.io/linux/container/4-docker%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/container/4-docker%E7%BD%91%E7%BB%9C/</guid>
      <description>{% raw %}
brctl show
docker 网络： docker 四种网络类型：
 bridge(Bridged Container): NAT桥模式(默认) host(Open Container): 与当前物理机共享网络资源(可以直接管理物理机网卡配置),容器使用宿主机的网络资源 none(Closed container): 以为这容器没有网络，只有lo接口(新买一台主机，没有网卡) 联盟网络(joined Container): 多个容器公用一组资源(NET、IPC、)  docker network inspect web
ip命令管理网络名称空间 ip netns: 用于管理网络名称空间(模拟容器间通信)
 ip netns list:显示网络名称空间 ip netns add NAME：添加一个网络名称空间 ip netns set NAME NETNSID：设置一个网络名称名称空间的SID ip [-all] netns exec [NAME] cm d &amp;hellip;：在一个网络名称空间中执行命令 ip link：挪动网络设备到容器中去  当我们使用ip去管理网络名称空间时，只有网络名称空间是被隔离的，其他名称空间都是共享的
例子： 创建网络名称空间：
 ip netns add r1 ip netns add r2  添加虚拟网卡：(一对)
 ip link add name veth1.</description>
    </item>
    
    <item>
      <title>DNS</title>
      <link>https://dachenzi.github.io/linux/dns/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/dns/</guid>
      <description>{% raw %}
 1 什么是DNS 2 DNS域名系统 3 DNS域名结构 4 域名服务器 5 域名解析过程 6 特殊记录说明  6.1 什么是A记录？ 6.2 什么是NS记录？ 6.3 什么是CNAME记录？ 6.4 什么是MX记录 6.5 什么是PTR记录   7 DNS相关命令  1 什么是DNS  Domain Name System，域名系统。因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。
2 DNS域名系统  域名系统DNS(Domain Name System)是因特网使用的命名系统，用来把便于人们使用的机器名字转换成为IP地址。域名系统其实就是名字系统。为什么不叫&amp;quot;名字&amp;quot;而叫&amp;quot;域名&amp;quot;呢？这是因为在这种因特网的命名系统中使用了许多的&amp;quot;域(domain)&amp;quot;，因此就出现了&amp;quot;域名&amp;quot;这个名词。&amp;ldquo;域名系统&amp;quot;明确地指明这种系统是应用在因特网中。 我们都知道，IP地址是由32位的二进制数字组成的。用户与因特网上某台主机通信时，显然不愿意使用很难记忆的长达32位的二进制主机地址。即使是点分十进制IP地址也并不太容易记忆。相反，大家愿意使用比较容易记忆的主机名字。但是，机器在处理IP数据报时，并不是使用域名而是使用IP地址。这是因为IP地址长度固定，而域名的长度不固定，机器处理起来比较困难。 因为因特网规模很大，所以整个因特网只使用一个域名服务器是不可行的。因此，早在1983年因特网开始采用层次树状结构的命名方法，并使用分布式的域名系统DNS。并采用客户服务器方式。DNS使大多数名字都在本地解析(resolve)，仅有少量解析需要在因特网上通信，因此DNS系统的效率很高。由于DNS是分布式系统，即使单个计算机除了故障，也不会妨碍整个DNS系统的正常运行。 域名到IP地址的解析是由分布在因特网上的许多域名服务器程序共同完成的。域名服务器程序在专设的结点上运行，而人们也常把运行域名服务器程序的机器称为域名服务器。 域名到IP地址的解析过程的要点如下：当某一个应用需要把主机名解析为IP地址时，该应用进程就调用解析程序，并称为DNS的一个客户，把待解析的域名放在DNS请求报文中，以UDP用户数据报方式发给本地域名服务器。本地域名服务器在查找域名后，把对应的IP地址放在回答报文中返回。应用程序获得目的主机的IP地址后即可进行通信。 若本地域名服务器不能回答该请求，则此域名服务器就暂时称为DNS的另一个客户，并向其他域名服务器发出查询请求。这种过程直至找到能够回答该请求的域名服务器为止。
3 DNS域名结构  由于因特网的用户数量较多，所以因特网在命名时采用的是层次树状结构的命名方法。任何一个连接在因特网上的主机或路由器，都有一个唯一的层次结构的名字，即域名(domain name)。这里，&amp;ldquo;域&amp;rdquo;(domain)是名字空间中一个可被管理的划分。 从语法上讲，每一个域名都是有标号(label)序列组成，而各标号之间用点(小数点)隔开。 如下例子所示：
这是中央电视台用于手法电子邮件的计算机的域名，它由三个标号组成，其中标号com是顶级域名，标号cctv是二级域名，标号mail是三级域名。
DNS规定，域名中的标号都有英文和数字组成，每一个标号不超过63个字符(为了记忆方便，一般不会超过12个字符)，也不区分大小写字母。标号中除连字符(-)外不能使用其他的标点符号。级别最低的域名写在最左边，而级别最高的字符写在最右边。由多个标号组成的完整域名总共不超过255个字符。DNS既不规定一个域名需要包含多少个下级域名，也不规定每一级域名代表什么意思。各级域名由其上一级的域名管理机构管理，而最高的顶级域名则由ICANN进行管理。用这种方法可使每一个域名在整个互联网范围内是唯一的，并且也容易设计出一种查找域名的机制。 域名只是逻辑概念，并不代表计算机所在的物理地点。据2006年12月统计，现在顶级域名TLD(Top Level Domain)已有265个，分为三大类：
 国家顶级域名nTLD：采用ISO3166的规定。如：cn代表中国，us代表美国，uk代表英国，等等。国家域名又常记为ccTLD(cc表示国家代码contry-code)。 通用顶级域名gTLD：最常见的通用顶级域名有7个，即：com(公司企业)，net(网络服务机构)，org(非营利组织)，int(国际组织)，gov(美国的政府部门)，mil(美国的军事部门)。 基础结构域名(infrastructure domain)：这种顶级域名只有一个，即arpa，用于反向域名解析，因此称为反向域名。
注：目前全球有13台根服务器。  4 域名服务器  如果采用上述的树状结构，每一个节点都采用一个域名服务器，这样会使得域名服务器的数量太多，使域名服务器系统的运行效率降低。所以在DNS中，采用划分区的方法来解决。 一个服务器所负责管辖(或有权限)的范围叫做区(zone)。各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。每一个区设置相应的权限域名服务器，用来保存该区中的所有主机到域名IP地址的映射。</description>
    </item>
    
    <item>
      <title>DNS-server</title>
      <link>https://dachenzi.github.io/linux/dns-server/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/dns-server/</guid>
      <description>{% raw %}
比较好用的dns记录 OpenDNS：
 208.67.222.222 208.67.220.220  台湾中华电讯的 DNS：
 168.95.192.1 168.95.192.2  香港宽频的 DNS：
 203.80.96.9 203.80.96.10  Level 3:
 4.2.2.2  {% endraw %}</description>
    </item>
    
    <item>
      <title>gogs安装</title>
      <link>https://dachenzi.github.io/linux/tools/gogs%E5%AE%89%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/tools/gogs%E5%AE%89%E8%A3%85/</guid>
      <description>{% raw %}
1 Gogs安装 Gogs 是一款极易搭建的自助 Git 服务。Gogs 的目标是打造一个最简单、最快速和最轻松的方式搭建自助 Git 服务。使用 Go 语言开发使得 Gogs 能够通过独立的二进制分发，并且支持 Go 语言支持的 所有平台，包括 Linux、Mac OS X、Windows 以及 ARM 平台。
1.1 安装准备  以下步骤均在CentOS 7.6下测试成功
  更新yum源  curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo 安装git  yum install -y git 安装数据库 支持MySQL、Mariadb、PostgreSQL、SQLite等  yum install -y mariadb-server 1.2 启动数据库  启动数据库  systemctl start mariadb-server 验证数据库启动  ps aux | grep mariadb # 检查进程 ss -lanp | grep 3306 # 检查端口 基础配置  # 初始化数据库 mysql_secure_installation 按照提示删除test库，以及创建数据库的root等</description>
    </item>
    
    <item>
      <title>Linuxcrontab</title>
      <link>https://dachenzi.github.io/linux/os/linuxcrontab/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxcrontab/</guid>
      <description>{% raw %}
1 什么是定时任务  我们的服务器存放的都是非常重要的数据，为了安全起见，我们每晚都会进行备份把数据备份到其他服务器上防止数据丢失，那么我们每天晚上都要手动的去备份吗？ 服务器上运行的服务都会有日志文件，它会记录程序运行运行时的输出信息，服务器运行久了这些文件就会非常大，那么我们要定期的进行手动删除吗？ 如果我们需要定时执行一些周期性重复性的任务，我们就会用到定时执行任务功能来帮我们自动执行每天、每周等周期性重复性的任务而不需要人为干预即可实现。
2 Windows的定时任务 作为使用者最多的操作系统，windows下也有定时任务。依次选择开始——&amp;gt;所有程序——&amp;gt;附件——&amp;gt;系统工具——&amp;gt;任务计划程序 3 Linux的定时任务  Linux中的定时任务主要分为两种:
 系统定时任务 用户自定义定时任务  3.1 系统定时任务  系统周期自行执行的任务工作，如轮询系统日志、备份系统数据、清理系统缓存等，这些任务无需我们认为干涉。系统定时任务是由/etc/logrotate.conf文件中的定义的，它的文件定义内容为：
[root@lixin ~]# grep &amp;#39;^[^#]&amp;#39; /etc/logrotate.conf weekly #按周分隔 rotate 4 #最多分成4份，然后覆盖 create #创建新的空文件，供记录 dateext #分隔文件，用日期加后缀名 include /etc/logrotate.d #包涵/etc/logrotato.d下的文件 /var/log/wtmp { monthly #按月分隔 create 0664 root utmp #分隔后,创建权限为0644属主为root，名字为utmp的新文件 minsize 1M #最小1M rotate 1 #分1份 } /var/log/btmp { missingok monthly create 0600 root utmp rotate 1 } # 该文件定义的是系统定时任务，我们一般不更改其内容。 3.</description>
    </item>
    
    <item>
      <title>LinuxDirs</title>
      <link>https://dachenzi.github.io/linux/os/linuxdirs/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxdirs/</guid>
      <description>{% raw %}
1 概述 1.1 疑问1  为什么某些程序位于/bin下，或者/sbin，或者/usr/bin，或/usr/sbin目录下吗？例如，less命令位于/usr/bin目录下。为什么没在/bin中，或/sbin，或/usr/sbin目录中？所有这些目录之间有什么不同？
1.2 疑问2  为什么很多发行版本，比如Centos、Red hat、SuSE。它们的/（根）目录下都有相同的目录结构？比如/etc、/home、/dev、/var、/tmp。为什么叫这些名字，这些目录下放的都是什么东西？
1.3 文件系统目录标准  由于Linux家喻户晓，开发人员众多，目录也越来越多，如果没有一个统一的标准，那么不同的发行版文件放置位置也不同，相同文件的名称也不同，这样看起来会非常的杂乱无章，在这种情况下FHS的出现就是必然的了。
Filesystem Hierarchy Standard（文件系统目录标准）的缩写，多数Linux版本采用这种文件组织形式，类似于Windows操作系统中c盘的文件目录，FHS采用树形结构组织文件。FHS定义了系统中每个区域的用途、所需要的最小构成的文件和目录，同时还给出了例外处理与矛盾处理。
FHS定义了两层规范，第一层是/目录下要放置哪些文件数据。第二层则是针对/usr和/var这两个目录的子目录定义。
2 目录说明 2.1 目录特点  /（根）是所有目录的顶点。 目录结构像一颗倒挂的树。 目录和磁盘分区，默认是没有关联的。 /（根）下不同的目录可能会对应不同的分区或磁盘。 所有的目录都是按照一定的类别和规律组成的。  2.2 目录结构 FHS规定的/(根)目录下各目录结构，如下图
2.3 目录说明 2.3.1 /(根)目录 每一个文件和目录从根开始，/下的目录有：
[root@lixin /]# ls bin data etc lib lost+found mnt opt root selinux sys usr boot dev home lib64 media daxin proc sbin srv tmp var 2.3.2 /bin目录 用来存放二进制可执行命令的目录，用户常用的命令都存在该目录下。例如：mkdir（创建目录）、cat（查看文件）、find（查找文件）等。
[root@lixin bin]# ls alsaunmute egrep mkdir sh arch env mknod sleep awk ex mktemp sort basename false more stty bash fgrep mount su cat find mountpoint sync chgrp findmnt mv tar …… [root@lixin bin]# 2.</description>
    </item>
    
    <item>
      <title>LinuxPermisson</title>
      <link>https://dachenzi.github.io/linux/os/linuxpermisson/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxpermisson/</guid>
      <description>{% raw %}
1 概述  我们使用ls –il命令查看的文件列表就是我们文件的简要属性信息。
[root@lixin ~]# ls –li  total 80 26171 -rw-r--r-- 1 root root 11 Mar 17 22:24 12345.txt 3545 lrwxrwxrwx 1 root root 6 Mar 16 23:24 1234.txt -&amp;gt; 10.txt 3581 -rw-r--r-- 1 root root 149 Mar 16 23:03 123.tar.gz 3563 -rw-r--r-- 1 root root 149 Mar 17 00:21 123.txt.bak 26197 -rw-r--r-- 1 root root 11 Mar 18 00:01 1.txt 26181 -rw-r--r-- 1 root root 0 Mar 16 19:46 2.</description>
    </item>
    
    <item>
      <title>LinuxRegExp</title>
      <link>https://dachenzi.github.io/linux/os/linuxregexp/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxregexp/</guid>
      <description>{% raw %}
1 什么是正则表达式  正则表达式RE（Regular Expression）是由一串字符和元字符构成的字符串。主要功能是文本查询和字符串操作，它可以匹配文本的一个字符或字符集合。实际上正则表达式完成了数据的过滤，将不满足正则表达式定义的数据拒绝掉，剩下与正则表达式匹配的数据。
简单的说，正则表达式就是为处理大量的字符串而定义的一套规则和方法。
1.1 正则表达式特点  正则表达式应用非常广泛，存在于各种语言中，例如：php、python、java等。Linux系统运维工作中的正则表达式，叫做Liunx正则表达式，它与其他语言中的正则表达式有一些不同，在Linux中最常应用正则表达式的是grep（egrep），sed，awk。
正则表达式和我们常用的通配符特殊字符是有本质区别的。注意设置字符集 LC_ALL=C其作用是为了去除所有本地化的设置，让命令能正确执行。
2 什么是通配符  通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符。当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。
2.1 通配符和正则表达式的区别  通配符一般用于命令行bash环境，用于匹配文件的名称而linux正则表达式一般用于awk、grep（egrep）、sed环境用于匹配字符串。
3 通配符的含义 3.1 *号 表示任意位任意字符，通常用来匹配任意文件名
[root@lixin ~]# ls 1 123.txt 1.txt 4 persion.txt 12 123.txt.bak 3 daxin.txt sshd_config [root@lixin ~]# ls *.txt 123.txt 1.txt daxin.txt persion.txt [root@lixin ~]# 3.2 ?号 ？号表示任意一个字符，多个？号可以叠加连用
[root@lixin ~]# ls ?.txt # ？代表一个字符 1.txt 2.txt 3.txt 4.txt 5.txt [root@lixin ~]# ls ??.txt # ？？代表两个字符 10.</description>
    </item>
    
    <item>
      <title>Linuxsed</title>
      <link>https://dachenzi.github.io/linux/os/linuxsed/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxsed/</guid>
      <description>{% raw %}
1 功能说明  sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有改变，除非你使用重定向存储输出或者加入i参数。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 小结：sed的功能是，对字符串进行增加、删除、改变、查找，即增删改查!
2 语法格式 sed [optian] [sed-command] [input-file] # 注意sed和后面的选项之间至少有一个空格。 # 为了避免混淆，称呼sed为sed软件。sed-commands(sed命令)是sed软件内置的一些命令选项，为了和前面的options(选项)区分，故称为sed命令。 # sed-commands既可以是单个sed命令，也可以是多个sed命令组合。 # input-file(输入文件)是可选项，sed还能够从标准输入如管道获取输入。 3 常用选项 测试文本内容为：
[root@lixin ~]# cat daxin.txt I am daxin teacher! I teach linux. I like badminton ball ,billiard ball and chinese chess! my blog is http://daxin.blog.51cto.com our site is http://www.cnblogs.org my qq num is 49000448. not 4900000448. my god ,i am not dachenzi,but daxin! gd good gooood [root@lixin ~]# 3.</description>
    </item>
    
    <item>
      <title>LinuxUser</title>
      <link>https://dachenzi.github.io/linux/os/linuxuser/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/linuxuser/</guid>
      <description>{% raw %}
1 小知识点回顾  Linux 是一个多用户多任务操作系统。 每个文件和进程，都需要对应一个用户和用户组。 Linux系统是通过UID和GID来识别用户和组的。 用户名相当于人名（给人看的）,UID，GID相当于身份证号（系统用的） Linux管理员：root 用户和组的关系：1对1、1对多、多对1、多对多 Linux系统用户的分类：  超级用户：UID为0，代表皇帝。 普通用户：UID为500-65535，由皇帝创建的普通用户，大臣。 虚拟用户：UID为1-499，，为了满足程序启动的需要。   和用户关联的四个文件:/etc/passwd,/etc/shadow,/etc/group,/etc/gshadow  2 环境变量配置文件 /etc/skel  当我们创建一个用户的时候，他的家目录下面默认会有一些隐藏文件，比如.bashrc、.bash_histoy、.bash_profile这些文件从哪来的?
[root@lixin ~]# ls -la dr-xr-x---. 3 root root 4096 Apr 1 22:39 . dr-xr-xr-x. 25 root root 4096 Apr 1 21:51 .. -rw-------. 1 root root 20481 Apr 1 20:08 .bash_history -rw-r--r--. 1 root root 18 May 20 2009 .bash_logout -rw-r--r--. 1 root root 176 May 20 2009 .</description>
    </item>
    
    <item>
      <title>nginxbasis</title>
      <link>https://dachenzi.github.io/linux/web/nginxbasis/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/web/nginxbasis/</guid>
      <description>{% raw %}
1 nginx介绍  HTTP协议包含很多功能。常用的www，world wide web是http功能之一。默认端口为80端口，也被称之为7层协议。
常用web软件：apache、nginx（静态web服务软件）。
流行的web组合：
 LAMP (Linux Apache Mysql Php) =====&amp;gt;经典 LNMP(Linux Nginx Mysql Php)=====&amp;gt;流行（或者LEMP，E（engine X 这样读法） nginx由俄罗斯人开发，是一款开源的，支持高性能，高并发的www服务和代理服务软件，一共780K，C语言开发。nginx本身是一款静态（html。css，js，jpg等）www的软件，不能解析动态的PHP,JSP,DO。因具有高并发（特别是静态资源）占用系统资源少等有点，且功丰富，而流行起来。淘宝，在nginx做了更改（优化）生成 tengine。  1.1 nginx重要特性  支持高并发：能支持几万并发连接（特别是静态小文件业务环境） 资源消耗少：在3万并发连接下，开启10个Nginx线程消耗不到200M内存。 可以做HTTP反向代理及加速缓存，即负载均衡功能，内置对RS节点服务器健康检查功能，这相当于专业的haproxy软件或lvs功能。 具备squid等专业缓存软件等的缓存功能。 支持异步网络IO事件模型epoll（Linux2.6+）  1.2 nginx主要功能  作为web服务软件：  运行HTML、JS、CSS、小图片等静态数据（此功能类似lighttpd软件） 结合FastCGI运行PHP等动态程序（例如使用fastcgi_pass方式）。 结合tomcat/resin等支持Java动态程序（常用）   作为反向代理或负载均衡服务：  为web服务、PHP服务等动态服务及Memcached缓存提供代理。 可以作为邮件代理服务软件。 在1.9.0版本以后支持tcp/IP代理，之前是不支持的。   作为前端的数据缓存服务器：  通过自身的proxy_cache模块实现类squid等专业缓存软件的功能。    1.3 nginx与其他web软件对比 apache
 2.2版本非常稳定强大，据官方说，其2.4版本性能超强。 Prefork模式取消了进程创建开销，性能很高。 处理动态业务数据时，因关联到后端的引擎和数据库，瓶颈不在apache本身。 高并发时消耗系统资源相对多一些。 基于传统的select模型。 支持扩展库，DSO方法，apxs方法编译安装额外的插件功能，不需要重新编译 功能多，更稳定，更安全，插件多 市场份额在逐年降低  Nginx</description>
    </item>
    
    <item>
      <title>rpmforyum_repo</title>
      <link>https://dachenzi.github.io/linux/os/rpmforyum_repo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/os/rpmforyum_repo/</guid>
      <description>{% raw %}
1 Linux上安装软件包的方式  Linux下常用的软件包安装方式有三种。
1.1 编译安装  编译:将源代码变为机器可执行的代码文件。 安装:将可执行文件安装到操作系统里,才可以使用。
编译安装的优缺点如下:
 优点  可以定制化安装目录 按需开启功能   缺点  需要查找并试验出适合的编译参数 编译时间过长 依赖包需要单独安装    1.2 yum安装  yum安装顾名思义，就是使用yum工具进行程序的安装。
 优点  自动处理依赖关系 自动化帮我们直接安装在操作系统中   缺点  不能定制化选择我们需要的功能模块 不能自定义安装目录 依赖于网络，网络不通，则无法安装    1.3 rpm安装  rpm，Redhat Packages Manager，红帽包管理工具，使用rpm工具（-i）进行软件程序的安装。
 优点  本地安装 强大的查询以及软件包验证的功能 yum安装方式，实质上安装的就是一个个rpm包   缺点  安装软件时，需要首先获取软件包依赖的所有包 无法直接处理依赖关系（需要制定—aid）参数    1.4 rpm定制+yum安装  综合了rpm的优点和yum的优点，定制化rpm包，自定义yum仓库，启用我们自己的yum源，这样可以使用yum帮我们一键安装软件，并执行某些操作，这在批量安装多台服务器的时候是非常有用的。</description>
    </item>
    
    <item>
      <title>ShellNotes</title>
      <link>https://dachenzi.github.io/linux/shell/shellnotes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/shell/shellnotes/</guid>
      <description>{% raw %}
1 什么是shell  shell是一个命令解释器，位于操作系统的最外层，它负责和用户直接对话，不用户输入的内容解释给操作系统，操作系统处理完毕后，输出结果，输出到屏幕上。分为交互式的和非交互式的。输入命令，得到结果。就是交互式的，执行脚本就是非交互的。 总结：shell就像是一座桥梁，连通用户和操作系统。
2 什么是shell脚本  把一个或多个linux命令组合起来放在一个程序文件中执行，这样的程序叫做shell脚本。严格来说把命令.变量和流程控制语句等结合在一起，就是shell脚本
2.1 如何写一个思路缜密的shell脚本  要多去模拟操作，多去想想为什么
2.2 shell的特点  linux中所有的配置文件.日志文件都是纯文本文件。而shell的特点就是善于处理纯文本的内容。
2.3 shell的分类  bourne shell(包括 sh,ksh,bash) C shell(csh,tcsh)
查看系统支持的sh类型：/etc/shells,常用的就是/bin/sh,/bin/bash,/sbin/nologin
Linux主流的shell就是bash，它是bourne again shell的缩写，是由bonrne shell发展而来，它还包含了csh和ksh的特色。
目前：通用的bourne shell 已经被bash shell取代
2.4 其他脚本语言  php：主要用于web页面开发，适合wab前端展示 perl：比shell强大，语法灵活，实现方式很多，不易读，其中mysql的HA就是由perl写的 python：近几年很火的软件，不但可以开发前端，也可以开发后端，属于全能型语言  2.5 常用系统的默认shell  Linux：bash
solaris：bonrne sh
AIX：ksh
HP-unix：posix shell（sh）
2.6 修改用户默认的shell  可以修改/etc/default/useradd文件的shell字段，更改新添加的用户。也可以直接修改/etc/passwd中的最后一个字段，直接修改某个用户的shell。
2.7 shell脚本的建立  通过vim编辑器编写shell脚本 ,注意脚本的第一行 #!/bin/bash 表示来指定解释器
 注意：python 程序开头 #!/usr/bin/env python因为Linux默认就是使用bash，所以使用bash的话，可以不用加，为了规范还是要添加。如果不指定解释器，就需要用bash test.sh来执行了。</description>
    </item>
    
    <item>
      <title>无法修改docker监听端口</title>
      <link>https://dachenzi.github.io/linux/container/%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9docker%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/linux/container/%E6%97%A0%E6%B3%95%E4%BF%AE%E6%94%B9docker%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3/</guid>
      <description>{% raw %}
docker daemon启用tcp端口异常  默认情况下docker daemon监听的是本地的sock的，它的位置一般为/var/run/docker.sock，其实docker也是支持监听tcp端口的，今天在修改监听方式时，遇到如下问题：
 OS:Centos 7.6 Docker:18.04
 我的修改方式为，在/etc/docker/daemon.json中添加如下配置
{ &amp;#34;hosts&amp;#34;:[&amp;#34;tcp://0.0.0.0:2375&amp;#34;,&amp;#34;unix:///var/run/docker.sock&amp;#34;] } 启动docker时，一直启动失败，提示如下错误
7月 19 22:52:34 localhost.localdomain dockerd[28536]: unable to configure the Docker daemon with file /etc/docker/daemon.json: the following dir ectives are specified both as a flag and in the configuration file: hosts: (from flag: [fd://], from file: [unix:///var/run/docker.sock tcp://12 7.0.0.1:2375]) 7月 19 22:52:34 localhost.localdomain systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE 7月 19 22:52:34 localhost.</description>
    </item>
    
  </channel>
</rss>
