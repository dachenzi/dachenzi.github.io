<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>27-面向对象高级-描述器 &middot; Lee Xin</title>

  
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dachenzi.github.io/touch-icon-144-precomposed.png">
  <link href="https://dachenzi.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="Your default page description">
  <meta name="keywords" content="your,default,page,keywords">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking code', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>Lee Xin</h1>
      <p class="lead">Your favourite quote or soundbite.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://dachenzi.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      
      
      
      
      
      
      
      
      
      </li>
    </ul>

    
    <p><script id='flattr'>
      (function(id){
        var s = document.getElementById(id);
        var f = document.createElement('iframe');
        f.src = '//api.flattr.com/button/view/?uid=&button=compact&url=https:\/\/dachenzi.github.io\/&title=daxin\u0027s blog';
        f.title = 'Flattr';
        f.height = 20;
        f.width = 110;
        f.style.borderWidth = 0;
        s.parentNode.insertBefore(f, s);
      })('flattr');
    </script></p>
    

    <p>Copyright &copy; 2020 <a href="https://dachenzi.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">27-面向对象高级-描述器</h1>
    <span class="post-date">Jan 1, 0001 &middot; 5 minute read &middot; <a href="https://dachenzi.github.io/blog/1/01/01/27-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E6%8F%8F%E8%BF%B0%E5%99%A8/#disqus_thread">Comments</a>
    </span>
    <p>{% raw %}</p>
<p><!-- raw HTML omitted --><strong>文章目录</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#1-%E6%8F%8F%E8%BF%B0%E5%99%A8">1 描述器</a></li>
<li><a href="#2-%E6%8F%8F%E8%BF%B0%E5%99%A8%E5%8D%8F%E8%AE%AE">2 描述器协议</a>
<ul>
<li><a href="#21-%E9%9D%9E%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%99%A8">2.1 非数据描述器</a>
<ul>
<li><a href="#211-%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90">2.1.1 实例分析</a></li>
</ul>
</li>
<li><a href="#22-%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E5%99%A8">2.2 数据描述器</a>
<ul>
<li><a href="#221-%E5%AE%9E%E4%BE%8B">2.2.1 实例</a></li>
</ul>
</li>
<li><a href="#23-%E6%8F%8F%E8%BF%B0%E5%99%A8%E7%9A%84%E8%B0%83%E7%94%A8%E5%8F%8A%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F">2.3 描述器的调用及属性访问顺序</a></li>
<li><a href="#24-%E6%8F%8F%E8%BF%B0%E5%99%A8%E6%80%BB%E7%BB%93">2.4 描述器总结</a></li>
</ul>
</li>
<li><a href="#3-python%E7%9A%84%E6%8F%8F%E8%BF%B0%E5%99%A8%E4%BD%93%E7%8E%B0">3 Python的描述器体现</a>
<ul>
<li><a href="#31-staticmethod%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0">3.1 staticmethod简单实现</a></li>
<li><a href="#32-classmethod%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0">3.2 ClassMethod简单实现</a></li>
<li><a href="#33-%E5%AF%B9%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%A0%A1%E9%AA%8C">3.3 对实例的数据进行校验</a>
<ul>
<li><a href="#331-%E7%9B%B4%E6%8E%A5%E5%9C%A8__init__%E5%87%BD%E6%95%B0%E4%B8%AD%E6%A3%80%E6%9F%A5">3.3.1 直接在__init__函数中检查</a></li>
<li><a href="#332-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%89%88%E6%9C%AC">3.3.2 装饰器版本</a></li>
<li><a href="#333-%E6%8F%8F%E8%BF%B0%E5%99%A8%E7%89%88%E6%9C%AC">3.3.3 描述器版本</a></li>
<li><a href="#334-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8F%8F%E8%BF%B0%E5%99%A8%E7%89%88%E6%9C%AC%E4%B9%8B%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8">3.3.4 装饰器+描述器版本之函数装饰器</a></li>
<li><a href="#335-%E8%A3%85%E9%A5%B0%E5%99%A8%E6%8F%8F%E8%BF%B0%E5%99%A8%E7%89%88%E6%9C%AC%E4%B9%8B%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8">3.3.5 装饰器+描述器版本之类装饰器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4-%E7%96%91%E9%97%AE">4 疑问</a></li>
</ul>
<!-- raw HTML omitted -->
<h1 id="1-描述器">1 描述器</h1>
<p>        一般来说，一个描述器是一个有'__<code>绑定行为</code>__&lsquo;的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 __get__(), __set__(), 和 __delete__() 。</p>
<blockquote>
<p>有这些方法的对象叫做描述器。</p>
</blockquote>
<p>        默认对属性的访问控制是从对象的字典里面(__dict__)中获取、设置和删除它。举例来说, 比如 a.x 的查找顺序是, a.__dict__[&lsquo;x&rsquo;] , 然后 type(a).__dict__[&lsquo;x&rsquo;] , 然后找 type(a) 的父类(不包括元类(metaclass)). 如果查找到的值是一个描述器, Python就会调用描述器的方法来重写默认的控制行为。这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。注意, 只有在新式类中时描述器才会起作用。(新式类是继承自 type 或者 object 的类)。</p>
<h1 id="2-描述器协议">2 描述器协议</h1>
<p>描述器主要涉及三个方法：</p>
<ol>
<li>descr.__get__(self, obj, type=None) &ndash;&gt; value</li>
<li>descr.__set__(self, obj, value) &ndash;&gt; None</li>
<li>descr.__delete__(self, obj) &ndash;&gt; None</li>
</ol>
<p>一个对象具有其中任一个方法就会成为描述器，从而在被当作对象属性时重写默认的查找、设置和删除行为。</p>
<h2 id="21-非数据描述器">2.1 非数据描述器</h2>
<p>在类中仅仅定义了__get__方法的描述器被称为非数据描述器(non-data descriptor)。</p>
<blockquote>
<p>非数据描述器的优先级低于实例的__dict__。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>a1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;a1&#39;</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;A.init&#39;</span>)

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">pass</span>
        <span style="color:#75715e"># return self</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>:
    x <span style="color:#f92672">=</span> A()

    <span style="color:#66d9ef">def</span> __init__(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;B.init&#39;</span>)

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;-&#39;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">20</span>)
b <span style="color:#f92672">=</span> B()
<span style="color:#66d9ef">print</span>(b<span style="color:#f92672">.</span>x<span style="color:#f92672">.</span>a1)

<span style="color:#75715e"># Traceback (most recent call last):</span>
<span style="color:#75715e"># A.init</span>
<span style="color:#75715e"># --------------------</span>
<span style="color:#75715e"># B.init</span>
<span style="color:#75715e">#   File &#34;E:/Python - base - code/ClassDesc.py&#34;, line 20, in &lt;module&gt;</span>
<span style="color:#75715e">#     print(b.x.a1)</span>
<span style="color:#75715e"># AttributeError: &#39;NoneType&#39; object has no attribute &#39;a1&#39;</span>
</code></pre></div><p>分析：</p>
<ol>
<li>Class A实现了__get__方法，所以它是一个非数据描述器</li>
<li>由于Class B里面设置的x属性是Class A的实例，所以在定义阶段就会实例化，把实例化的对象赋给x属性，所以会先执行A的__init__方法。</li>
<li>访问实例b的x属性时，发现值是一个描述器，然后就会被描述器A的__get__方法捕获</li>
<li>__get__方法默认然会None，所以None对象没有a1属性，所以报属性错误</li>
<li>在__get__方法中，return self就可以访问了</li>
</ol>
<p>那么self是什么，__get__方法的参数都是什么意思：</p>
<ul>
<li><code>self</code>：对应A的实例(这里是属性x)</li>
<li><code>owner</code>：对应的是x属性的拥有者，也就是B类</li>
<li><code>instance</code>：它的值有两个
<ul>
<li>当使用owner类直接调用时，<code>它是None</code></li>
<li>当使用owner类的实例调用是，是<code>实例本身</code></li>
</ul>
</li>
</ul>
<h3 id="211-实例分析">2.1.1 实例分析</h3>
<p>下面是小例子，分析代码结果</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>country <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;Earth&#39;</span>

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>country

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ChinaPeople</span>:
    country <span style="color:#f92672">=</span> Person()

    <span style="color:#66d9ef">def</span> __init__(self,name,country):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>country <span style="color:#f92672">=</span> country

daxin <span style="color:#f92672">=</span> ChinaPeople(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#e6db74">&#39;China&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>country)
</code></pre></div><p>分析：</p>
<ol>
<li>由于描述器Person是一个非数据描述器，优先级低于实例自己的__dict__</li>
<li>实例在初始化时对self.country属性赋值，会直接在自己的__dict__中，写入{&ldquo;country&rdquo;:&ldquo;China}</li>
<li>在访问时根据MRO，优先访问实例自己的__dict__，所以结果是China</li>
</ol>
<h2 id="22-数据描述器">2.2 数据描述器</h2>
<p>同时实现了__get__、__set__方法就称为数据描述器(data descriptor)</p>
<blockquote>
<p>数据描述器的优先级高于实例的字典__dict__。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __get__&#39;</span>)
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>name

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __set__&#39;</span>)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>:
    name <span style="color:#f92672">=</span> A()
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>

b <span style="color:#f92672">=</span> B()
<span style="color:#66d9ef">print</span>(b<span style="color:#f92672">.</span>name)

<span style="color:#75715e"># 结果：</span>
<span style="color:#75715e"># From A __set__</span>
<span style="color:#75715e"># From A __get__</span>
<span style="color:#75715e"># A</span>
</code></pre></div><p>分析：</p>
<ol>
<li>描述器A，实现一个数据描述器，优先级高于实例的自己的__dict__</li>
<li>在对b进行实例化的时候，设置了b的name属性，根据mro规则，找到父类B的name属性，然后发现其是一个数据描述器，然后被描述器A的__set__方法捕获。</li>
<li>当打印实例属性name时，由于数据描述器中，没有对传入的&rsquo;B&rsquo;进行赋值，所以这里&rsquo;B&rsquo;就丢了，最后访问属性name，会被描述器的__get__方法捕获，并返回描述器的name属性，所以打印是&quot;A&rdquo;</li>
</ol>
<p>那么self是什么，__set__方法的参数都是什么意思：</p>
<ul>
<li><code>self</code>：对应A的实例(这里是属性name)</li>
<li><code>instance</code>：对应的是实例本身，这里就是b</li>
<li><code>value</code>：表示设置的值(这里就是&rsquo;B&rsquo;)</li>
</ul>
<h3 id="221-实例">2.2.1 实例</h3>
<p>分析下面代码的运行原理</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __get__&#39;</span>)
        <span style="color:#75715e"># return self.name</span>
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;name&#39;</span>]

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __set__&#39;</span>)
        instance<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;name&#39;</span>] <span style="color:#f92672">=</span> value

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>:
    name <span style="color:#f92672">=</span> A()

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>

b <span style="color:#f92672">=</span> B()
<span style="color:#66d9ef">print</span>(b<span style="color:#f92672">.</span>name)
</code></pre></div><p>分析：</p>
<ol>
<li>当b在初始化时，对name属性进行了设置，所以第一步先按照mro查找name属性。</li>
<li>在父类B中，查找到类属性name，它的结果是一个数据描述器，所以设置的请求被数据描述器的__set__方法捕获，在__set__方法中，为实例自己的__dict__注入了属性name以及它的值。</li>
<li>在打印name属性时，由于数据描述器的优先级高于实例的__dict__，所以操作被描述器的__get__方法捕获，在内部返回了实例自己__dict__的属性name，所以最后打印&rsquo;B'</li>
</ol>
<h2 id="23-描述器的调用及属性访问顺序">2.3 描述器的调用及属性访问顺序</h2>
<p>        当类中存在描述器时，那么对象属性的调用就会发生变化。根据上面的例子，我们知道，实例属性访问的优先级为：数据描述器 &gt; 实例字典__dict__ &gt; 非数据描述器</p>
<blockquote>
<p>特别注意：这里的访问顺序指的是：<strong><code>实例属性对应一个描述器时的顺序。</code></strong>，如果直接对类属性进行赋值操作，会直接覆盖类的描述器。
结合前面学的魔术方法，分析整个过程。</p>
</blockquote>
<ol>
<li>实例daxix的属性name(daxin.name) 本质上执行的是daxin.__getattribute__()方法</li>
<li>daxin.__getattribute__() 其实是type(daxin).__dict__[&lsquo;name&rsquo;].__get__(daxin,type(daxin))</li>
</ol>
<p>使用Pyhon描述这个过程就是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> __getattribute__(self, key):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;from B __getattribute__&#39;</span>)
    v <span style="color:#f92672">=</span> super(B, self)<span style="color:#f92672">.</span>__getattribute__(key)   <span style="color:#75715e"># 这里用 self.__getattribute__就会递归了</span>
    <span style="color:#75715e"># v = object.__getattribute__(self, key)   # 使用super的方法，等同于直接调用object</span>
    <span style="color:#66d9ef">if</span> hasattr(v, <span style="color:#e6db74">&#39;__get__&#39;</span>):
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">.</span>__get__(self, type(self))  
    <span style="color:#66d9ef">return</span> v
</code></pre></div><p>完整的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;A&#39;</span>

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __get__&#39;</span>)
        <span style="color:#75715e"># return self.name</span>
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;name&#39;</span>]

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;From A __set__&#39;</span>)
        instance<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;name&#39;</span>] <span style="color:#f92672">=</span> value

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>:
    name <span style="color:#f92672">=</span> A()

    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;B&#39;</span>

    <span style="color:#66d9ef">def</span> __getattribute__(self, key):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;from B __getattribute__&#39;</span>)
        v <span style="color:#f92672">=</span> super(B, self)<span style="color:#f92672">.</span>__getattribute__(key)   
        <span style="color:#66d9ef">if</span> hasattr(v, <span style="color:#e6db74">&#39;__get__&#39;</span>):
            <span style="color:#66d9ef">return</span> v<span style="color:#f92672">.</span>__get__(self, type(self))
        <span style="color:#66d9ef">return</span> v

b <span style="color:#f92672">=</span> B()
<span style="color:#66d9ef">print</span>(b<span style="color:#f92672">.</span>name)
</code></pre></div><h2 id="24-描述器总结">2.4 描述器总结</h2>
<p>总结几点比较重要的：</p>
<ul>
<li>描述器的调用是因为__getattribute__()方法</li>
<li>重写__getattribute__()方法会组织正常的描述器调用</li>
<li>__getattribute__()只对新式类的实例可用</li>
<li>object.__getattribute__()和type.__getattribute__()对__get__()的调用不一样</li>
<li>数据描述器总是比实例字典优先</li>
<li>非数据描述器可能被实例字典重写/覆盖(非数据描述器不如实例字典优先)</li>
</ul>
<h1 id="3-python的描述器体现">3 Python的描述器体现</h1>
<p>        描述器在Python中应用非常广泛。我们定义的实例方法，包括类方法(classmethod)和静态方法(staticmethod)都属于非数据描述器。所以实例可以重新定义和覆盖方法。这样就可以使一个实例拥有与其他实例不同的行为(方法重写)。<br>
        但property装饰器不然，它是一个数据描述器，所以实例不能覆盖属性。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name ):
        self<span style="color:#f92672">.</span>_name <span style="color:#f92672">=</span> name

    <span style="color:#a6e22e">@staticmethod</span> 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>():         <span style="color:#75715e"># 非数据描述器</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;world&#39;</span>)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">world</span>(cls):      <span style="color:#75715e"># 非数据描述器</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;world&#39;</span>)

    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">name</span>(self):      <span style="color:#75715e"># 数据描述器</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>_name

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">welcome</span>(self):   <span style="color:#75715e"># 非数据描述器</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Welcome&#39;</span>)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>(A):            
    <span style="color:#66d9ef">def</span> __init__(self,name):
        super()<span style="color:#f92672">.</span>__init__(name)


daxin <span style="color:#f92672">=</span> B(<span style="color:#e6db74">&#39;daxin&#39;</span>)
daxin<span style="color:#f92672">.</span>hello <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> : <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;modify hello&#39;</span>)  <span style="color:#75715e"># 可以被覆盖</span>
daxin<span style="color:#f92672">.</span>world <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> : <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;modify world&#39;</span>)  <span style="color:#75715e"># 可以被覆盖</span>
daxin<span style="color:#f92672">.</span>welcome <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> : <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;modify welcome&#39;</span>)  <span style="color:#75715e"># 可以被覆盖</span>
daxin<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> self: self<span style="color:#f92672">.</span>_name  <span style="color:#75715e"># 无法被覆盖</span>

daxin<span style="color:#f92672">.</span>hello()
daxin<span style="color:#f92672">.</span>world()
daxin<span style="color:#f92672">.</span>welcome()
</code></pre></div><h2 id="31-staticmethod简单实现">3.1 staticmethod简单实现</h2>
<p>下面是一个简单的StaticMethod的实现</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticMethod</span>:
    <span style="color:#66d9ef">def</span> __init__(self, fn):
        self<span style="color:#f92672">.</span>fn <span style="color:#f92672">=</span> fn

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>fn

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:

    <span style="color:#a6e22e">@StaticMethod</span>  <span style="color:#75715e"># hello = StaticMethod(hello)</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>():  
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>)

daxin <span style="color:#f92672">=</span> A()
daxin<span style="color:#f92672">.</span>hello()  <span style="color:#75715e"># hello() = StaticMethod().fn()</span>
</code></pre></div><p>静态方法不需要传参，那么只需要在__get__方法拦截后，仅仅返回方法本身即可。</p>
<h2 id="32-classmethod简单实现">3.2 ClassMethod简单实现</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span>  functools
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClassMethod</span>:

    <span style="color:#66d9ef">def</span> __init__(self, fn):
        self<span style="color:#f92672">.</span>fn <span style="color:#f92672">=</span> fn

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#75715e">#return lambda : self.fn(owner)</span>
        <span style="color:#66d9ef">return</span>  functools<span style="color:#f92672">.</span>partial(self<span style="color:#f92672">.</span>fn,owner)

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>:

    <span style="color:#a6e22e">@ClassMethod</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>(cls):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world {}&#39;</span><span style="color:#f92672">.</span>format(cls<span style="color:#f92672">.</span>__name__))

daxin <span style="color:#f92672">=</span> A()
daxin<span style="color:#f92672">.</span>hello()  <span style="color:#75715e"># hello() = functools.partial(self.fn,owner)</span>
</code></pre></div><p>类方法由于默认会把类当作参数传递，所以需要把方法的第一个参数固定为类，所以使用偏函数来固定，是一个比较好的办法，又或者使用lambda，由于lambda函数只能接受一个参数，所以当类方法是多个参数时，无法接受。</p>
<h2 id="33-对实例的数据进行校验">3.3 对实例的数据进行校验</h2>
<p>现有如下代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name:str, age:int):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name 
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age 
</code></pre></div><p>对上面类的属性name，age进行数据类型的校验。<br>
思路：</p>
<ol>
<li>写函数，直接在__init__中检查，如果不符合直接抛出异常(<code>一般人都会</code>)</li>
<li>装饰器(<code>多数人会</code>)</li>
<li>描述器(<code>少数人会</code>)</li>
<li>描述器版装饰器(<code>基本没人会</code>)</li>
</ol>
<h3 id="331-直接在__init__函数中检查">3.3.1 直接在__init__函数中检查</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name:str, age:int):
        <span style="color:#75715e"># 每次都判断，然后赋值</span>
        <span style="color:#75715e"># if self._typecheck(name,str):</span>
        <span style="color:#75715e">#     self.name = name</span>
        <span style="color:#75715e"># if self._typecheck(age, int):</span>
        <span style="color:#75715e">#     self.age = age</span>

        <span style="color:#75715e"># 或者直接构建需要的数据类型，一次性判断，最后赋值</span>
        params <span style="color:#f92672">=</span> [(name,str),(age,int)]
        <span style="color:#66d9ef">for</span> param <span style="color:#f92672">in</span> params:
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> self<span style="color:#f92672">.</span>_typecheck(<span style="color:#f92672">*</span>param):
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(param[<span style="color:#ae81ff">0</span>])
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_typecheck</span>(self,value,typ):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(value, typ):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(value)
        <span style="color:#66d9ef">return</span> True

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#ae81ff">20</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>name)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age)
</code></pre></div><p>看起来也太丑了，不能复用不说，在初始化阶段还做了大量的逻辑判断，也不容易让别人明白你真正的意图是啥。</p>
<h3 id="332-装饰器版本">3.3.2 装饰器版本</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> inspect

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">TypeCheck</span>(cls:object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs):
        sig <span style="color:#f92672">=</span> inspect<span style="color:#f92672">.</span>signature(cls)  <span style="color:#75715e"># 获取签名对象</span>
        param <span style="color:#f92672">=</span> sig<span style="color:#f92672">.</span>parameters<span style="color:#f92672">.</span>values()  <span style="color:#75715e"># 抽取签名信息(有序)</span>
        data <span style="color:#f92672">=</span> zip(args,param)  <span style="color:#75715e"># 构建值与类型的元组</span>
        <span style="color:#66d9ef">for</span> value,typ <span style="color:#f92672">in</span> data:
            <span style="color:#66d9ef">if</span> typ<span style="color:#f92672">.</span>annotation <span style="color:#f92672">!=</span> inspect<span style="color:#f92672">.</span>_empty:   <span style="color:#75715e"># 当定义了参数注解时，开始参数判断</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(value,typ<span style="color:#f92672">.</span>annotation):
                    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(value)   <span style="color:#75715e"># 判断不通过，爆出异常</span>
        <span style="color:#66d9ef">return</span> cls(<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs)
    <span style="color:#66d9ef">return</span> wrapper

<span style="color:#a6e22e">@TypeCheck</span>  <span style="color:#75715e"># Person = TypeCheck(Person)(&#39;daxin&#39;,20)  ==&gt; wrapper(&#39;daxin&#39;,20)</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name:str, age:int):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name 
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#e6db74">&#39;20&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>name)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age)
</code></pre></div><p>看起来很好的解决了参数类型的检查，并且也可以针对不同类继续进行参数检查，所以说:<code>装饰器</code>，<code>真香</code>。</p>
<h3 id="333-描述器版本">3.3.3 描述器版本</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TypeCheck</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name, typ):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>typ <span style="color:#f92672">=</span> typ

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name]

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(value,self<span style="color:#f92672">.</span>typ):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(value)
        instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name] <span style="color:#f92672">=</span> value

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    name <span style="color:#f92672">=</span> TypeCheck(<span style="color:#e6db74">&#39;name&#39;</span>,str)      <span style="color:#75715e"># 硬编码</span>
    age <span style="color:#f92672">=</span> TypeCheck(<span style="color:#e6db74">&#39;age&#39;</span>,int)        <span style="color:#75715e"># 硬编码</span>

    <span style="color:#66d9ef">def</span> __init__(self, name:str, age:int):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#e6db74">&#39;20&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>name)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age)
</code></pre></div><h3 id="334-装饰器描述器版本之函数装饰器">3.3.4 装饰器+描述器版本之函数装饰器</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> inspect


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TypeCheck</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name, typ):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>typ <span style="color:#f92672">=</span> typ

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name]

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(value,self<span style="color:#f92672">.</span>typ):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(value)
        instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name] <span style="color:#f92672">=</span> value

<span style="color:#75715e"># 动态注入name，age描述器属性</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">AttriCheck</span>(cls:object):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">wrapper</span>(<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs):
        sig <span style="color:#f92672">=</span> inspect<span style="color:#f92672">.</span>signature(cls)
        params <span style="color:#f92672">=</span> sig<span style="color:#f92672">.</span>parameters
        <span style="color:#66d9ef">for</span> k,v <span style="color:#f92672">in</span> params<span style="color:#f92672">.</span>items():
            <span style="color:#66d9ef">print</span>(v<span style="color:#f92672">.</span>annotation)
            <span style="color:#66d9ef">if</span> v<span style="color:#f92672">.</span>annotation <span style="color:#f92672">!=</span> inspect<span style="color:#f92672">.</span>_empty:
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hasattr(cls,k):
                    setattr(cls,k,TypeCheck(k,v<span style="color:#f92672">.</span>annotation))
        <span style="color:#66d9ef">return</span> cls(<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs)
    <span style="color:#66d9ef">return</span> wrapper

<span style="color:#a6e22e">@AttriCheck</span>   <span style="color:#75715e"># Person = AttriCheck(Person)</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name: str, age: int):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

a <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>, <span style="color:#ae81ff">20</span>)
<span style="color:#66d9ef">print</span>(a<span style="color:#f92672">.</span>name)
<span style="color:#66d9ef">print</span>(a<span style="color:#f92672">.</span>age)
</code></pre></div><p>使用装饰器结合描述器时，类必须包含对应同名描述器，才可以利用描述器进行参数检查，所以，利用反射，将参数注入类中，然后通过描述器进行检查</p>
<h3 id="335-装饰器描述器版本之类装饰器">3.3.5 装饰器+描述器版本之类装饰器</h3>
<p>能否把上面的装饰器函数，改为类？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> inspect

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TypeCheck</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name, typ):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>typ <span style="color:#f92672">=</span> typ

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name]

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(value,self<span style="color:#f92672">.</span>typ):
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(value)
        instance<span style="color:#f92672">.</span>__dict__[self<span style="color:#f92672">.</span>name] <span style="color:#f92672">=</span> value

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AttriCheck</span>:
    <span style="color:#66d9ef">def</span> __init__(self,cls):
        self<span style="color:#f92672">.</span>cls <span style="color:#f92672">=</span> cls

    <span style="color:#66d9ef">def</span> __call__(self, <span style="color:#f92672">*</span>args, <span style="color:#f92672">**</span>kwargs):
        sig <span style="color:#f92672">=</span> inspect<span style="color:#f92672">.</span>signature(self<span style="color:#f92672">.</span>cls)
        params <span style="color:#f92672">=</span> sig<span style="color:#f92672">.</span>parameters
        <span style="color:#66d9ef">for</span> name,typ <span style="color:#f92672">in</span> params<span style="color:#f92672">.</span>items():
            <span style="color:#66d9ef">if</span> typ<span style="color:#f92672">.</span>annotation <span style="color:#f92672">!=</span> inspect<span style="color:#f92672">.</span>_empty:
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hasattr(self<span style="color:#f92672">.</span>cls, name):
                    setattr(self<span style="color:#f92672">.</span>cls,name,TypeCheck(name,typ<span style="color:#f92672">.</span>annotation))
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>cls(<span style="color:#f92672">*</span>args,<span style="color:#f92672">**</span>kwargs)


<span style="color:#a6e22e">@AttriCheck</span>   <span style="color:#75715e"># Person = AttriCheck(Person)</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name: str, age: int):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

a <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>, <span style="color:#e6db74">&#39;20&#39;</span>)
<span style="color:#66d9ef">print</span>(a<span style="color:#f92672">.</span>name)
<span style="color:#66d9ef">print</span>(a<span style="color:#f92672">.</span>age)

</code></pre></div><h1 id="4-疑问">4 疑问</h1>
<p>看下面例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>:
    <span style="color:#66d9ef">def</span> __init__(self, data):
        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> data

    <span style="color:#66d9ef">def</span> __get__(self, instance, owner):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>data

    <span style="color:#66d9ef">def</span> __set__(self, instance, value):
        self<span style="color:#f92672">.</span>data <span style="color:#f92672">=</span> value


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span>:
    name <span style="color:#f92672">=</span> B(<span style="color:#e6db74">&#39;daxin&#39;</span>)
    age <span style="color:#f92672">=</span> B(<span style="color:#ae81ff">20</span>)

    <span style="color:#66d9ef">def</span> __init__(self, name, age):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age

daxin <span style="color:#f92672">=</span> C(<span style="color:#e6db74">&#39;tom&#39;</span>,<span style="color:#ae81ff">18</span>)
dachenzi <span style="color:#f92672">=</span> C(<span style="color:#e6db74">&#39;Jack&#39;</span>,<span style="color:#ae81ff">29</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>name) 
</code></pre></div><p>结果是&rsquo;Jack'，为什么呢？</p>
<ol>
<li>name和age属于类属性，只会在定义的时候实例化一次！不同实例的name和age属性是公用的！</li>
<li>在描述器中，把实例设置的值，绑定到了描述器本身的属性上去了。</li>
<li>不同实例的name和age属性都指向了相同的描述器，并且每次修改的都是同一个属性。</li>
<li>这种坑是要避免的，尽量把属性绑定在实例自己身上
{% endraw %}</li>
</ol>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "your_disqus_shortname";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "your_disqus_shortname";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="https://dachenzi.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

