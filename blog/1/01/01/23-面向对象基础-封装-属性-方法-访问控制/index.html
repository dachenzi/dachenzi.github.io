<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>23-面向对象基础-封装-属性-方法-访问控制 &middot; Lee Xin</title>

  
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dachenzi.github.io/touch-icon-144-precomposed.png">
  <link href="https://dachenzi.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="Your default page description">
  <meta name="keywords" content="your,default,page,keywords">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking code', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>Lee Xin</h1>
      <p class="lead">Your favourite quote or soundbite.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://dachenzi.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      
      
      
      
      
      
      
      
      
      </li>
    </ul>

    
    <p><script id='flattr'>
      (function(id){
        var s = document.getElementById(id);
        var f = document.createElement('iframe');
        f.src = '//api.flattr.com/button/view/?uid=&button=compact&url=https:\/\/dachenzi.github.io\/&title=daxin\u0027s blog';
        f.title = 'Flattr';
        f.height = 20;
        f.width = 110;
        f.style.borderWidth = 0;
        s.parentNode.insertBefore(f, s);
      })('flattr');
    </script></p>
    

    <p>Copyright &copy; 2020 <a href="https://dachenzi.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">23-面向对象基础-封装-属性-方法-访问控制</h1>
    <span class="post-date">Jan 1, 0001 &middot; 6 minute read &middot; <a href="https://dachenzi.github.io/blog/1/01/01/23-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-%E5%B0%81%E8%A3%85-%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#disqus_thread">Comments</a>
    </span>
    <p>{% raw %}</p>
<p><!-- raw HTML omitted --><strong>文章目录</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#1-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%8B%E7%BB%8D">1 面向对象介绍</a></li>
<li><a href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">2 面向对象</a>
<ul>
<li><a href="#21-%E7%B1%BBclass">2.1 类class</a></li>
<li><a href="#22-%E5%AF%B9%E8%B1%A1instanceobject">2.2 对象instance/object</a></li>
<li><a href="#23-python%E7%9A%84%E5%93%B2%E5%AD%A6%E6%80%9D%E6%83%B3">2.3 Python的哲学思想</a></li>
</ul>
</li>
<li><a href="#3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A6%81%E7%B4%A0">3 面向对象的要素</a></li>
<li><a href="#4-python%E7%9A%84%E7%B1%BB">4 Python的类</a>
<ul>
<li><a href="#41-%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%8F%8A%E5%B1%9E%E6%80%A7">4.1 类对象及属性</a></li>
<li><a href="#42-%E5%AE%9E%E4%BE%8B%E5%8C%96">4.2 实例化</a>
<ul>
<li><a href="#421-__init__%E5%87%BD%E6%95%B0">4.2.1 __init__函数</a></li>
<li><a href="#422-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1instance">4.2.2 实例对象(instance)</a></li>
<li><a href="#423-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E5%92%8C%E7%B1%BB%E5%8F%98%E9%87%8F">4.2.3 实例变量和类变量</a></li>
<li><a href="#424-__dict__%E5%92%8C%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E9%A1%BA%E5%BA%8F">4.2.4 __dict__和变量查找顺序</a></li>
<li><a href="#425-%E6%80%BB%E7%BB%93">4.2.5 总结</a></li>
</ul>
</li>
<li><a href="#43-%E8%A3%85%E9%A5%B0%E4%B8%80%E4%B8%AA%E7%B1%BB">4.3 装饰一个类</a></li>
<li><a href="#44-%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">4.4 类方法和静态方法</a>
<ul>
<li><a href="#441-%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E4%B8%8D%E7%94%A8">4.4.1 普通函数(不用)</a></li>
<li><a href="#442-%E7%B1%BB%E6%96%B9%E6%B3%95">4.4.2 类方法</a></li>
<li><a href="#443-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%94%A8%E7%9A%84%E5%BE%88%E5%B0%91">4.4.3 静态方法(用的很少)</a></li>
<li><a href="#444-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8">4.4.4 方法的调用</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">5 访问控制</a>
<ul>
<li><a href="#51-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">5.1 私有属性</a></li>
<li><a href="#52-%E4%BF%9D%E6%8A%A4%E5%8F%98%E9%87%8F">5.2 保护变量</a></li>
<li><a href="#53-%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">5.3 私有方法</a></li>
<li><a href="#54-%E8%A1%A5%E4%B8%81%E9%BB%91%E7%A7%91%E6%8A%80">5.4 补丁：(黑科技)</a></li>
<li><a href="#55-%E5%B1%9E%E6%80%A7%E8%A3%85%E9%A5%B0%E5%99%A8">5.5 属性装饰器</a></li>
<li><a href="#56-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81">5.6 对象的销毁</a></li>
<li><a href="#57-%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BDoverload">5.7 方法重载(overload)</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="1-面向对象介绍">1 面向对象介绍</h1>
<p>        面向对象是一种程序设计思想，它把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。但并不是所有语言都支持面向对象编程的。简单的从语言本身来分的话，主要分为以下三种：(并不是说其他类型的语言不好，只是场景不适合而已，就好比操作系统，基本都是使用C语言编写的，语言没有优劣，只有适不适合)</p>
<ol>
<li><code>面向机器</code>(汇编语言等):抽象成机器指令，机器容易理解。</li>
<li><code>面向过程</code>(C语言等):做一件事，排除个步骤，第一步干什么，第二部干什么，如果出现情况A，做什么处理，如果出现过程B，做什么处理。问题规模小，可以步骤话，按部就班的处理。</li>
<li><code>面向对象OOP</code>(Java语言，C++语言，Python等):针对情况复杂的情况，比如表示一个大楼的作用，使用函数就比较麻烦了。</li>
</ol>
<blockquote>
<p>现在大部分语言都是面向对象的，它适合软件规模比较大的场景使用</p>
</blockquote>
<h1 id="2-面向对象">2 面向对象</h1>
<p>        那什么是面向对象？我们可以简单来说它就是一套方法论，是 <strong><code>一种认识世界、分析世界的方法论</code></strong> 。将万事万物都抽象为各种对象，在Python中一切皆对象。下面来说一下，主要的名词含义：</p>
<h2 id="21-类class">2.1 类class</h2>
<p>抽象的概念，是一类事物的共同特征的集合。</p>
<ul>
<li>数据：有没有耳朵，有没有鼻子</li>
<li>操作事物的能力：能不能吃，能不能说等</li>
</ul>
<p>用计算机语言来描述，就是属性(数据)和方法(操作事物的能力)的集合。但凡说分类：都是抽象的概念</p>
<h2 id="22-对象instanceobject">2.2 对象instance/object</h2>
<p>        对象是类的具象、是一个实体。对于我们每个个体，都是抽象概念人类的不同实体（对象，实例），比如你吃鱼，你是对象，鱼也是对象，吃是动作.<br>
PS：在python中我们说类的实例通常会用instance或者object来指代。</p>
<ul>
<li>属性：对象状态的抽象，用数据结构来描述</li>
<li>操作：对象行为的抽象，用操作名和实现该操作的方法来描述（函数）</li>
</ul>
<blockquote>
<p>每个人都是人类的一个单独实例，都有自己的名字、身高、体重等信息，这些信息是个人的属性，但是这些信息不能保存在人类中，因为它是抽象的概念，不能保存具体的信息，而我们每个人，每个个体，都是具体的人，就可以存储这些具体的属性，而且不同的人具有不同的属性。</p>
</blockquote>
<h2 id="23-python的哲学思想">2.3 Python的哲学思想</h2>
<p>在Python中一切皆对象,对象是数据和操作的封装,对象是独立的，但是对象之间可以相互作用(你推我，我打你，相互作用)。</p>
<blockquote>
<p>目前OOP是最接近人类认知的编程范式</p>
</blockquote>
<h1 id="3-面向对象的要素">3 面向对象的要素</h1>
<p>面向对象有三大特点：</p>
<ol>
<li><code>封装(Encapsulation)</code>，将数据和操作组装到一起，对外只暴露一些借口，通过接口访问对象。（比如驾驶员驾驶汽车，不需要了解汽车的构造，只需要知道使用什么部件怎么驾驶皆可以了，踩了油门就能跑，可以不了解其中的机动原理。）</li>
<li><code>继承(Inheritance)</code>，多复用（继承来的就不用写了），遵循多继承少修改原则，OCP（Open-closed Principle)，使用继承来改变，来体现个性（修改实例自己，不要去修改父类）</li>
<li><code>多态(Polymorphism)</code>，面向对象编程最灵活的地方，动态绑定，比如人吃和猫吃，都是吃，但是不同吃又不太一样。简单来说就是：同一种方法，在不同的子类上，表现方式不同。(父类、子类通过继承联系在一起，通过一套方法，就可以实现不同的表现，就是多态)</li>
</ol>
<h1 id="4-python的类">4 Python的类</h1>
<p>对象是特征(变量)与技能(函数)的结合，类是一些列对象共有的特征与技能的结合体.</p>
<ul>
<li>在现实生活中：先有对象，再总结归纳出的类</li>
<li>在程序中：一定先定义类，再实例化出对象</li>
</ul>
<p>定义一个类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ClassName</span>:
    <span style="color:#960050;background-color:#1e0010">语句块</span>
</code></pre></div><p>规范：</p>
<ol>
<li>必须使用<code>class</code>关键字</li>
<li>类名必须是用<code>大驼峰</code>命名</li>
<li>类定义完成后(被解释器一行一行解释完毕后），就产生一个类对象，绑定到了标识符ClassName上(一切皆对象思想，类对象也是某个对象(type)的实例)</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyClass</span>:              <span style="color:#75715e"># class 类名称</span>
    <span style="color:#e6db74">&#39;&#39;&#39;MyClass Doc&#39;&#39;&#39;</span>       <span style="color:#75715e"># 类介绍，通过类对象的__doc__属性获取</span>
    x <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>                 <span style="color:#75715e"># 类属性</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">showme</span>(self):       <span style="color:#75715e"># 类方法名(函数)</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;My Class&#39;</span>)   <span style="color:#75715e"># 函数体</span>
    
    showme <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> self: <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;My Class&#39;</span>)     <span style="color:#75715e"># 等同于上面定义的函数</span>
p <span style="color:#f92672">=</span> MyClass()
<span style="color:#66d9ef">print</span>(p<span style="color:#f92672">.</span>__doc__)
</code></pre></div><h2 id="41-类对象及属性">4.1 类对象及属性</h2>
<ul>
<li><code>类对象</code>：类的定义执行后会产生一个类对象</li>
<li><code>类的属性</code>：类定义中的变量和类中定义的方法都是类的属性</li>
<li><code>类变量</code>：x是类MyClass的变量</li>
</ul>
<p>所以根据上面例子来说：</p>
<ol>
<li>MyClass中，x，showme都是类的属性，__doc__也是类的特殊属性。</li>
<li>showme被叫做method(方法)，本质上就是普通的函数对象function，它一般要求至少有一个参数。第一个形式参数可以是self(self只是一个惯用标识符，可以换名字，但是不建议，指代当前实例本身)。当使用某个实例调用方法时，这个实例对象会被注入给第一个参数self。所以，self指代的就是实例本身。</li>
</ol>
<h2 id="42-实例化">4.2 实例化</h2>
<p>通过使用类名加括号来构建实例化一个对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">a <span style="color:#f92672">=</span> Person() <span style="color:#75715e"># 实例化</span>
</code></pre></div><ol>
<li>类名后面加括号，就调用类的实例化方法，完成实例化。</li>
<li>实例化就真正创建一个该类的对象（实例），每一次实例化都会返回不同的实例对象</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">daxin <span style="color:#f92672">=</span> Person()
xiaoming <span style="color:#f92672">=</span> Person()
</code></pre></div><p>注意：上面的两次实例化产生的都是不同的实例，即便是参数相同。Python类实例化后，会自动调用<code>__init__</code>方法。这个方法第一个形式参数必须留给self，其他参数随意。</p>
<h3 id="421-__init__函数">4.2.1 __init__函数</h3>
<p>        在Python中对象的实例化，其实分为两个部分，即实例化和初始化。主要对应__new__和__init__方法。</p>
<ol>
<li>实例化(<strong>new</strong>)：得到一个真正的具体的实例</li>
<li>初始化(<strong>init</strong>)：对这个真正的实例进行定制化(不能返回，或return None)</li>
</ol>
<blockquote>
<p><code>__变量名__</code> 的方法叫做魔术方法
        __new__方法比较复杂，一般用在元类的定义和修改上，这里先记住：__new__方法实例化一个对象的过程中会调用__init__方法进行初始化，初始化完毕后再由__new__方法将产生的实例对象进行返回，当__new__方法和__init__方法没有被定义时，会<code>隐式</code>的向上(父类)查找并调用。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>():
    <span style="color:#66d9ef">def</span> __init__(self, name, age):  <span style="color:#75715e"># 形参</span>
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name   <span style="color:#75715e"># 这里daxin 赋给 self.name</span>
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age   <span style="color:#75715e"># 这里20 赋给 self.age</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sing</span>(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} is sing&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>name))
daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#ae81ff">20</span>)    <span style="color:#75715e"># 实参</span>
</code></pre></div><p>注意：</p>
<ol>
<li><code>__init__</code>: 的self是由__new__方法注入进来的，不用手动传递，这个self就是实例化后的对象。</li>
<li>self.name和self.age:表示对实例化添加了两个属性name和age，并进行初始化赋值。</li>
<li><code>__init__</code>: 只是添加了一些定制化的属性，并不会返回对象。</li>
<li>daxin 是由__new__方法返回的具体的实例化对象。</li>
</ol>
<blockquote>
<p>注意：<code>__init__</code>方法只有在实例化的时候才会被调用。</p>
</blockquote>
<h3 id="422-实例对象instance">4.2.2 实例对象(instance)</h3>
<p>        类实例化后一定会获得一个类的实例，就是实例对象。__init__方法的第一个变量self就是实例本身。通过实例化我们可以获得一个实例对象，比如上面的daxin，我们可以通过daxin.sing()来调用sing方法，但是我们并没有传递self参数啊，这是因为类实例化后，得到一个实例对象，实例对象会<code>绑定</code>到<code>方法</code>上，在使用daxin.sing()进行调用时，会把方法的调用者daxin实例，作为第一个参数self传入。而self.name就是daxin实例的name属性，name保存在daxin实例中，而不是Person类中，所以这里的name被叫做实例变量。</p>
<blockquote>
<p>类中定义的方法会存放在类中(仅存一份)，而不是实例中，实例直接绑定到方法上。</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sing</span>(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} is sing&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>name))

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>sing)   <span style="color:#75715e"># &lt;bound method Person.sing of &lt;__main__.Person object at 0x00000198EADD83C8&gt;&gt;  绑定方法</span>
<span style="color:#66d9ef">print</span>(Person<span style="color:#f92672">.</span>sing)  <span style="color:#75715e"># &lt;function Person.sing at 0x00000198EADD99D8&gt;  方法函数</span>
</code></pre></div><p>        上例中，在调用daxin.sing时，daxin实例是被绑定到了sing方法上，当 a = Person(&lsquo;a&rsquo;) 时，a.sing其实也是把a绑定到了sing方法上，仔细看的话，不同实例的sing方法的内存地址是相同的.</p>
<h3 id="423-实例变量和类变量">4.2.3 实例变量和类变量</h3>
<p>        实例变量是每一个实例自己的变量，是自己独有的。类变量是类的变量，是类的所有实例共享的属性和方法。下面我们从一个例子来看实例变量和类变量</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">2</span>]: <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>: 
   <span style="color:#f92672">...</span>:     country <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;China&#39;</span>         <span style="color:#75715e"># 类变量</span>
   <span style="color:#f92672">...</span>:     <span style="color:#66d9ef">def</span> __init__(self, name, gender): 
   <span style="color:#f92672">...</span>:         self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name      <span style="color:#75715e"># 实例变量</span>
   <span style="color:#f92672">...</span>:         self<span style="color:#f92672">.</span>gender <span style="color:#f92672">=</span> gender 
   <span style="color:#f92672">...</span>:                                                                                                 

In [<span style="color:#ae81ff">3</span>]: daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#e6db74">&#39;male&#39;</span>)                                                                  

In [<span style="color:#ae81ff">4</span>]: daxin<span style="color:#f92672">.</span>country                                                                          
Out[<span style="color:#ae81ff">4</span>]: <span style="color:#e6db74">&#39;China&#39;</span>

In [<span style="color:#ae81ff">5</span>]: daxin<span style="color:#f92672">.</span>name                                                                                      
Out[<span style="color:#ae81ff">5</span>]: <span style="color:#e6db74">&#39;daxin&#39;</span>

In [<span style="color:#ae81ff">6</span>]: Person<span style="color:#f92672">.</span>country                                                                                  
Out[<span style="color:#ae81ff">6</span>]: <span style="color:#e6db74">&#39;China&#39;</span>

In [<span style="color:#ae81ff">7</span>]: Person<span style="color:#f92672">.</span>name                                                                                     
<span style="color:#f92672">---------------------------------------------------------------------------</span>
<span style="color:#a6e22e">AttributeError</span>       
</code></pre></div><p>观察例子，我们可以发现：</p>
<ol>
<li>类变量我们可以通过类访问，也可以通过实例访问</li>
<li>实例变量只能通过实例访问(因为类本身是不会知道谁是他的实力)</li>
</ol>
<blockquote>
<p>类变量可以通过实例调用，但实例变量是实例私有的，无法通过类调用。</p>
</blockquote>
<p>PS: 获取类属性的不同的方式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">daxin<span style="color:#f92672">.</span>age
daxin<span style="color:#f92672">.</span>__class__<span style="color:#f92672">.</span>age
Person<span style="color:#f92672">.</span>age
type(daxin)<span style="color:#f92672">.</span>age 
</code></pre></div><p>有几个特殊的属性先来看一下，便于后续理解</p>
<table>
<thead>
<tr>
<th>特殊属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__name__</code></td>
<td>获取类对象的对象名(返回字符串)</td>
</tr>
<tr>
<td><code>__class__</code></td>
<td>获取实例对象的类型(相当于type),type和__class__返回的是同样的东西</td>
</tr>
<tr>
<td><code>__dict__</code></td>
<td>对象的属性的字典</td>
</tr>
<tr>
<td><code>__qualname__</code></td>
<td>类的限定名</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">8</span>]: daxin<span style="color:#f92672">.</span>__class__                                                                                 
Out[<span style="color:#ae81ff">8</span>]: __main__<span style="color:#f92672">.</span>Person

In [<span style="color:#ae81ff">9</span>]: Person<span style="color:#f92672">.</span>__class__                                                                                
Out[<span style="color:#ae81ff">9</span>]: type

In [<span style="color:#ae81ff">10</span>]: type(daxin)                                                                                    
Out[<span style="color:#ae81ff">10</span>]: __main__<span style="color:#f92672">.</span>Person

In [<span style="color:#ae81ff">11</span>]: type(daxin) <span style="color:#f92672">is</span> Person                                                                          
Out[<span style="color:#ae81ff">11</span>]: True

In [<span style="color:#ae81ff">13</span>]: Person<span style="color:#f92672">.</span>__name__                                                                                 
Out[<span style="color:#ae81ff">13</span>]: <span style="color:#e6db74">&#39;Person&#39;</span>   <span style="color:#75715e"># 返回字符串</span>
</code></pre></div><p>疑问：当类变量和实例变量重名时，到底访问的是哪个？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    age <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
    height <span style="color:#f92672">=</span> <span style="color:#ae81ff">170</span>

    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age


tom <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;Tom&#39;</span>)
jerry <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;jetty&#39;</span>, <span style="color:#ae81ff">20</span>)

Person<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">1</span>, Person<span style="color:#f92672">.</span>age, tom<span style="color:#f92672">.</span>age, jerry<span style="color:#f92672">.</span>age) 
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">2</span>, Person<span style="color:#f92672">.</span>height, tom<span style="color:#f92672">.</span>height, jerry<span style="color:#f92672">.</span>height)
jerry<span style="color:#f92672">.</span>height <span style="color:#f92672">=</span> <span style="color:#ae81ff">175</span>
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">3</span>, Person<span style="color:#f92672">.</span>height, tom<span style="color:#f92672">.</span>height, jerry<span style="color:#f92672">.</span>height)
tom<span style="color:#f92672">.</span>height <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">4</span>, Person<span style="color:#f92672">.</span>height, tom<span style="color:#f92672">.</span>height, jerry<span style="color:#f92672">.</span>height)
Person<span style="color:#f92672">.</span>height <span style="color:#f92672">+=</span> <span style="color:#ae81ff">15</span>
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">5</span>, Person<span style="color:#f92672">.</span>height, tom<span style="color:#f92672">.</span>height, jerry<span style="color:#f92672">.</span>height)
Person<span style="color:#f92672">.</span>weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">70</span>
<span style="color:#66d9ef">print</span>(<span style="color:#ae81ff">6</span>, Person<span style="color:#f92672">.</span>weight, tom<span style="color:#f92672">.</span>weight, jerry<span style="color:#f92672">.</span>weight)
</code></pre></div><p>分析：</p>
<ol>
<li>Person返回的是自己的类属性，所以Person.age是30，tom优先访问自己的实例变量，由于指定了默认值，所以tom.age是18，jerry指定了age,所以jerry.age是20.</li>
<li>Person返回的是自己的类属性，所以Person.height是170，tom和jerry没有height实例变量，所以访问的都是类变量，值得都是170</li>
<li>Person.height是170，jerry.height=175 赋值即定义了一个实例变量height，所以tom.height = 170, jerry.height = 175</li>
<li>Person.height是170, tom.height += 10 赋值即定义了一个实例变量height, 所以tom.height = tom.height + 10 = 180, jerry.height = 175</li>
<li>Person.height += 15，Person.height = 185,tom和jerry有自己的实例变量不会收Person影响，所以tom.height = 170, jerry.height=175</li>
<li>Person.weight = 70，为Person赋值即定义了一个新的weight属性，所以Person.weight = 70,tom和jerry没有weight属性，访问Person的所以值都是70</li>
</ol>
<p>通过观察发现，当类变量和实例变量重名时，似乎有一定的查找规则，那么就要说说__dict__了。</p>
<h3 id="424-__dict__和变量查找顺序">4.2.4 __dict__和变量查找顺序</h3>
<p>        __dict__是一个非常重要的特殊属性，它是一个存放着对象的属性信息的字典(对实例来说是字典，对类来说是映射)。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">14</span>]: Person<span style="color:#f92672">.</span>__dict__                                                                                
Out[<span style="color:#ae81ff">14</span>]: 
mappingproxy({<span style="color:#e6db74">&#39;__module__&#39;</span>: <span style="color:#e6db74">&#39;__main__&#39;</span>,
              <span style="color:#e6db74">&#39;country&#39;</span>: <span style="color:#e6db74">&#39;China&#39;</span>,
              <span style="color:#e6db74">&#39;__init__&#39;</span>: <span style="color:#f92672">&lt;</span>function __main__<span style="color:#f92672">.</span>Person<span style="color:#f92672">.</span>__init__(self, name, gender)<span style="color:#f92672">&gt;</span>,
              <span style="color:#e6db74">&#39;__dict__&#39;</span>: <span style="color:#f92672">&lt;</span>attribute <span style="color:#e6db74">&#39;__dict__&#39;</span> of <span style="color:#e6db74">&#39;Person&#39;</span> objects<span style="color:#f92672">&gt;</span>,
              <span style="color:#e6db74">&#39;__weakref__&#39;</span>: <span style="color:#f92672">&lt;</span>attribute <span style="color:#e6db74">&#39;__weakref__&#39;</span> of <span style="color:#e6db74">&#39;Person&#39;</span> objects<span style="color:#f92672">&gt;</span>,
              <span style="color:#e6db74">&#39;__doc__&#39;</span>: None})

In [<span style="color:#ae81ff">15</span>]: daxin<span style="color:#f92672">.</span>__dict__                                                                                 
Out[<span style="color:#ae81ff">15</span>]: {<span style="color:#e6db74">&#39;name&#39;</span>: <span style="color:#e6db74">&#39;daxin&#39;</span>, <span style="color:#e6db74">&#39;gender&#39;</span>: <span style="color:#e6db74">&#39;male&#39;</span>}

In [<span style="color:#ae81ff">19</span>]: daxin<span style="color:#f92672">.</span>__dict__[<span style="color:#e6db74">&#39;name&#39;</span>]         <span style="color:#75715e"># 因为__dict__是一个字典，我们可以直接通过key来访问                                                              </span>
Out[<span style="color:#ae81ff">19</span>]: <span style="color:#e6db74">&#39;daxin&#39;</span>

</code></pre></div><p>通过观察发现：</p>
<ol>
<li>Person.<strong>dict</strong>：包含所有类内定义的属性及方法。</li>
<li>daxin.<strong>dict</strong> : 只记录实例自己的属性信息。</li>
</ol>
<blockquote>
<p>方法是记录在类的<code>__dict__</code>中的</p>
</blockquote>
<p>实例属性查找顺序: <strong><code>指的是实例使用.点号来访问属性，会先找自己的__dict__，如果没有，然后通过属性__class__找到自己的类，然后再在类的__dict__中查找.直接使用实例.__dict__[变量名]，不会在类中查找。</code></strong></p>
<h3 id="425-总结">4.2.5 总结</h3>
<ol>
<li>类变量是属于类的变量，这个类的所以实例可以共享这个变量</li>
<li>对象(实例或者类)，可以动态的给自己增加一个属性(赋值即定义)</li>
<li>实例.<strong>dict</strong>[变量名] 和 实例.变量名 都可以访问到实例自己的属性</li>
<li>实例的同名变量会隐藏掉类变量，或者说是覆盖了这个类变量。但是注意类变量还在那里，并没有真正被覆盖。</li>
<li>实例属性查找顺序：指的是实例使用.点号来访问属性，会先找自己的__dict__，如果没有，然后通过属性__class__找到自己的类，然后再在类的__dict__中查找。直接使用实例.__dict__[变量名]，不会在类中查找。</li>
<li>一般来说类变量可以全部用大写来表示(当常量用)</li>
</ol>
<h2 id="43-装饰一个类">4.3 装饰一个类</h2>
<p>为一个类通过装饰，增加一些类属性。例如能否给一个类增加一个NAME类属性并提供属性值</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dec</span>(name):
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">warpper</span>(cls):
        cls<span style="color:#f92672">.</span>NAME <span style="color:#f92672">=</span> name
        <span style="color:#66d9ef">return</span> cls
    <span style="color:#66d9ef">return</span> warpper


<span style="color:#a6e22e">@dec</span>(<span style="color:#e6db74">&#39;tom&#39;</span>)  <span style="color:#75715e"># Person = dec(&#39;tom&#39;)(Person)</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">pass</span>

a <span style="color:#f92672">=</span> Person()
<span style="color:#66d9ef">print</span>(a<span style="color:#f92672">.</span>NAME)
</code></pre></div><blockquote>
<p>类也可以作为一个装饰器，后面会说</p>
</blockquote>
<p>可以给类加装饰器，那么可以给类中的方法加装饰器吗？答案当然是可以的。</p>
<h2 id="44-类方法和静态方法">4.4 类方法和静态方法</h2>
<p>        在类中中定义的方法大多都需要传入一个self参数，用于指定一个实例化对象，用于通过对象来调用这个方法，但是也有例外的情况</p>
<h3 id="441-普通函数不用">4.4.1 普通函数(不用)</h3>
<p>        定义在类内部的普通函数,只能通过类来进行调用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">23</span>]: <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>: 
    <span style="color:#f92672">...</span>:     <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">normal_function</span>(): 
    <span style="color:#f92672">...</span>:         <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;normal_function&#39;</span>) 
    <span style="color:#f92672">...</span>:                                                                                                

In [<span style="color:#ae81ff">24</span>]: Person<span style="color:#f92672">.</span>normal_function()                                                                       
normal_function

In [<span style="color:#ae81ff">25</span>]: test <span style="color:#f92672">=</span> Person()                                                                                

In [<span style="color:#ae81ff">27</span>]: test<span style="color:#f92672">.</span>normal_function()                                                                         
<span style="color:#f92672">---------------------------------------------------------------------------</span>
<span style="color:#a6e22e">TypeError</span>                                 Traceback (most recent call last)
<span style="color:#f92672">&lt;</span>ipython<span style="color:#f92672">-</span>input<span style="color:#f92672">-</span><span style="color:#ae81ff">27</span><span style="color:#f92672">-</span><span style="color:#ae81ff">9011</span>f04ffcaa<span style="color:#f92672">&gt;</span> <span style="color:#f92672">in</span> <span style="color:#f92672">&lt;</span>module<span style="color:#f92672">&gt;</span>
<span style="color:#f92672">----&gt;</span> <span style="color:#ae81ff">1</span> test<span style="color:#f92672">.</span>normal_function()

<span style="color:#a6e22e">TypeError</span>: normal_function() takes <span style="color:#ae81ff">0</span> positional arguments but <span style="color:#ae81ff">1</span> was given

In [<span style="color:#ae81ff">28</span>]:   
</code></pre></div><p>注意：</p>
<ol>
<li>normal_function 定义在类里，只是受Person类管辖的一个普通函数而已，在Person中，认为normal_function仅仅是Person的一个属性而已.</li>
<li>当通过实例访问时，由于实例会默认把当前实例当作self传入函数，而函数并没有形参接受所以会报错。</li>
</ol>
<blockquote>
<p>虽然可以通过类调用，但是没人这样用，也就是说是<code>禁止</code>这么写的</p>
</blockquote>
<h3 id="442-类方法">4.4.2 类方法</h3>
<p>        类方法是给类用的，在使用时会将类本身当做参数传给类方法的第一个参数，使用<code>@classmethod</code>装饰器来把类中的某个函数定义成类方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">In [<span style="color:#ae81ff">31</span>]: <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>: 
    <span style="color:#f92672">...</span>:     <span style="color:#a6e22e">@classmethod</span> 
    <span style="color:#f92672">...</span>:     <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">class_method</span>(cls): 
    <span style="color:#f92672">...</span>:         <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;class={0.__name__}({0})&#39;</span><span style="color:#f92672">.</span>format(cls)) 
    <span style="color:#f92672">...</span>:         cls<span style="color:#f92672">.</span>HEIGHT<span style="color:#f92672">=</span><span style="color:#ae81ff">170</span> 
    <span style="color:#f92672">...</span>:                                                                                                

In [<span style="color:#ae81ff">32</span>]: Person<span style="color:#f92672">.</span>class_method()                                                                          
class<span style="color:#f92672">=</span>Person(<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">__main__</span><span style="color:#f92672">.</span>Person<span style="color:#e6db74">&#39;&gt;)</span>

In [<span style="color:#ae81ff">35</span>]: daxin <span style="color:#f92672">=</span> Person()                                                                               

In [<span style="color:#ae81ff">36</span>]: daxin<span style="color:#f92672">.</span>class_method()                                                                           
class<span style="color:#f92672">=</span>Person(<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#a6e22e">__main__</span><span style="color:#f92672">.</span>Person<span style="color:#e6db74">&#39;&gt;)</span>

In [<span style="color:#ae81ff">37</span>]:
</code></pre></div><p>注意：</p>
<ol>
<li>在类定义中，使用@classmethod装饰器的方法</li>
<li>必须至少有一个参数，且第一个参数留给了cls，cls指代调用者即类对象自身</li>
<li>cls这个标识符可以是任意合法名称，但是为了易读，不建议修改</li>
<li>通过cls可以直接操作类的属性</li>
<li>通过类的实例依旧可以调用类方法，那是因为当通过实例调用时，@classmethod发现调用者是实例时，会把当前实例的__class__对象，传入给类方法的cls。</li>
</ol>
<blockquote>
<p>类方法类似于C++、Java中的静态方法。</p>
</blockquote>
<h3 id="443-静态方法用的很少">4.4.3 静态方法(用的很少)</h3>
<p>        静态方法是一种普通函数，位于类定义的命名空间中，不会对任何实例类型进行操作,它有如下特点</p>
<ol>
<li>在类定义中，使用<code>@classmethod</code>装饰器修饰的方法，在调用时不会隐式的传入参数</li>
<li>静态方法，只表明这个方法属于这个名称空间，函数归在一起，方便组织管理。</li>
<li>可以理解为一个函数封装，可以通过类调用、也可以通过实例调用，只是强制的放在类中而已。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#a6e22e">@staticmethod</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">static_method</span>():
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;static_method&#39;</span>)


daxin <span style="color:#f92672">=</span> Person()
Person<span style="color:#f92672">.</span>static_method()
daxin<span style="color:#f92672">.</span>static_method()
</code></pre></div><blockquote>
<p>和普通函数的区别是，静态方法可以使用实例调用，普通方法不可以。</p>
</blockquote>
<h3 id="444-方法的调用">4.4.4 方法的调用</h3>
<p>        类几乎可以调用所有方法，普通函数的调用一般不可能出现，因为不允许这么定义。实例也几乎可以调用所有内部定义的方法，但是调用普通方法时会报错，原因是第一参数必须是类的实例self。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>:
    age <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">normal_funtion</span>():
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;normal_function&#39;</span>)

    <span style="color:#a6e22e">@classmethod</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">class_method</span>(cls):
        <span style="color:#66d9ef">print</span>(cls<span style="color:#f92672">.</span>__name__)

    <span style="color:#a6e22e">@staticmethod</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">static_method</span>():
        <span style="color:#75715e"># Test.age</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;static_method&#39;</span>)

daxin <span style="color:#f92672">=</span> Test()
daxin<span style="color:#f92672">.</span>normal_funtion()   <span style="color:#75715e"># 无法调用，因为通过实例调用时，实例会被当作第一个参数传给normal_funcion。</span>
daxin<span style="color:#f92672">.</span>class_method()     <span style="color:#75715e"># 可以调用，当@classmethod检测到是通过实例调用时，会把当前实例的__class__，当作cls传递，可以访问类属性，但无法访问实例属性</span>
daxin<span style="color:#f92672">.</span>static_method()    <span style="color:#75715e"># 可以调用，当@staticmethod检测到是通过实例调用时，会在当前实例的类中调用静态方法，无法访问类或实例的属性，但是可以访问全局变量(比如全局变量Test类)</span>

Test<span style="color:#f92672">.</span>normal_funtion()    <span style="color:#75715e"># 可以调用，类调用时不传递参数，刚好normal_function也不需要参数，无法访问类或实例的属性</span>
Test<span style="color:#f92672">.</span>class_method()      <span style="color:#75715e"># 可以调用，类方法，通过类调用时，类会被当作cls传递给函数，可以访问类属性,无法访问实例属性</span>
Test<span style="color:#f92672">.</span>static_method()     <span style="color:#75715e"># 可以调用，静态方法，等于定义在类内的函数，无法访问类或实例的属性，但是可以访问全局变量(比如全局变量Test类)</span>
</code></pre></div><p>注意：</p>
<ol>
<li>实例除了普通方法都可以调用，普通方法需要对象的实例作为第一参数。</li>
<li>类可以调用所有类中定义的方法(包括类方法、静态方法)， 普通方法不用传递参数，静态方法，和类方法需要查找到实例的类。</li>
</ol>
<p>体会：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span>:
    age <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">normal_funtion</span>(abc):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{}&#39;</span><span style="color:#f92672">.</span>format(abc))

Test<span style="color:#f92672">.</span>normal_funtion(Test)
Test<span style="color:#f92672">.</span>normal_funtion(<span style="color:#ae81ff">123</span>)
a <span style="color:#f92672">=</span> Test()
a<span style="color:#f92672">.</span>normal_funtion()
</code></pre></div><p>        normal_function依旧是一个普通方法而已，加了参数发现类和实例都可以调用了，那是因为之前实例无法调用是因为实例调用时默认传递给函数作为第一个参数，那么我给普通函数加一个形参接受就可以了。没有场景这样使用，这里只做学习了解。</p>
<h1 id="5-访问控制">5 访问控制</h1>
<p>        封装成类还可以控制什么属性可以让别人访问，什么方法不能让别人访问,这就叫做访问控制。</p>
<h2 id="51-私有属性">5.1 私有属性</h2>
<p>使用 <strong>双下划线开头</strong> 的属性名，就是私有属性，现有如下例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name, age):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> age 

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>, <span style="color:#ae81ff">18</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age)
</code></pre></div><p>        我们可以在外面直接使用daxin.age来访问daxin的age属性，但是如果这个age是银行卡密码，不能让别人知道该怎么办呢，Python提供了一种私有属性来解决</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name, age):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age 
        
daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>, <span style="color:#ae81ff">20</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>__age)
</code></pre></div><p>        使用__开头的属性被称为私有属性，这种属性在类的外部是无法直接进行访问的，前面所说__dict__中会存放类的属性信息，那么我们来看一下daxin实例的<code>__dict__</code>是怎么样的。</p>
<pre><code>print(daxin.__dict__)

{'name': 'daxin', '_Person__age': 20}
</code></pre><p>根据上面结果可以得知：私有属性的本质上其实是属性改名，设置self.__age属性时，__age 变为了 _Person__age（_类名__属性名)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name, age):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#ae81ff">18</span>)
daxin<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>__dict__) <span style="color:#75715e"># {&#39;name&#39;: &#39;daxin&#39;, &#39;_Person__age&#39;: 18, &#39;__age&#39;: 100}</span>
</code></pre></div><p>        只有在类中定义的私有变量才会被改名，上面我们虽然指定了实例的变量__age,但由于是在类外定义的，所以它并不会变形，就真的产生了一个__age属性，而在类内定义的，由于变型了，所以不会覆盖。观察<code>__dict__</code>就可以看出结果。</p>
<p>        我们知道私有属性在定义时会被改名，并且知道改名后的属性名称，那么我们是否就可以修改了呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name, age):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_age</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age
daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>,<span style="color:#ae81ff">18</span>)
daxin<span style="color:#f92672">.</span>_Person__age <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>get_age())   <span style="color:#75715e"># 100</span>
</code></pre></div><p>通过结果我们可以知道，只要知道了私有变量的名称，就可以直接从外部访问，并且修改它。但并不建议这么做!</p>
<blockquote>
<p>Java等其他语言，比较严格，私有在外面是绝对访问不到的。</p>
</blockquote>
<h2 id="52-保护变量">5.2 保护变量</h2>
<p>        保护变量(protected),其实Python并不支持保护变量，是开发者自己的不成文的约定。那什么是保护变量呢？在变量前使用 <strong><code>一个下划线</code></strong> 的变量称为保护变量。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name):
        self<span style="color:#f92672">.</span>_name <span style="color:#f92672">=</span> name

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>__dict__)  <span style="color:#75715e"># {&#39;_name&#39;: &#39;daxin&#39;}</span>
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>_name)   <span style="color:#75715e"># daxin</span>
</code></pre></div><p>注释：</p>
<ol>
<li>保护变量不会被改变名称</li>
<li>外部依旧可以看到并且调用</li>
</ol>
<blockquote>
<p>如果看见这种变量，就如同私有变量，尽量不要直接使用</p>
</blockquote>
<h2 id="53-私有方法">5.3 私有方法</h2>
<p>        前面说了私有属性，那么私有方法和私有属性是相似的，使用单/双下划线开头的方法称为私有方法(不能已双下划线结尾)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self,name):
        self<span style="color:#f92672">.</span>_name <span style="color:#f92672">=</span> name

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">__age</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>_name

<span style="color:#66d9ef">print</span>(Person<span style="color:#f92672">.</span>__dict__)  <span style="color:#75715e"># {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__init__&#39;: &lt;function Person.__init__ at 0x00000228BCB22158&gt;, &#39;_Person__age&#39;: &lt;function Person.__age at 0x00000228BCB221E0&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Person&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Person&#39; objects&gt;, &#39;__doc__&#39;: None}</span>
</code></pre></div><p>通过上面__dict__的内容，我们发现私有方法和私有属性是相同的，都会被改名，所以知道了私有方法真正的名字，我们依旧可以在外部进行调用，但是不建议。</p>
<blockquote>
<p>单下划线的方法，也和变量相同，解释器不会做任何变型，只是告诉你，它是一个私有方法，不建议直接使用。</p>
</blockquote>
<h2 id="54-补丁黑科技">5.4 补丁：(黑科技)</h2>
<p>        可以通过修改或替换类的成员。使用者调用的方式没有改变，但是，类提供的功能可能已经改变了。(比如前面的类装饰器)，通常称作猴子补丁(Monkey Patch)</p>
<p>        在运行时,对属性、方法、函数等进行动态替换。其目的往往是为了通过替换、修改来增强、扩展原有代码的能力。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sing</span>(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} is sing&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>name))


<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">monkeypatch</span>():    <span style="color:#75715e"># 猴子补丁，用于动态修改Person中某个方法</span>
    Person<span style="color:#f92672">.</span>sing <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> self: <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>)    <span style="color:#75715e"># 可以来自于不同包中的某个函数，这里只是使用lambda举例</span>

monkeypatch()    <span style="color:#75715e"># 执行后，Person.sing函数就被替换掉了</span>

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
daxin<span style="color:#f92672">.</span>sing()   <span style="color:#75715e"># &#39;hello world&#39;</span>
</code></pre></div><p>        一般情况下是不建议使用的，但是在某些场景下，比如我替换的方法原来是连接数据库获取数据的，反复连接数据库测试不是很方便，所以在这种情况下，我们使用补丁的方式，返回部分目标数据就好了，不用每次都去数据库取数据。</p>
<h2 id="55-属性装饰器">5.5 属性装饰器</h2>
<p>        被属性装饰器装饰的方法，就变成了属性了。是不是很拗口？简单来说就是：属性装饰器把一个方法变成属性，进行调用。这么做的目的可以把某些属性保护起来，不让外部访问(通过前面私有属性的了解，我们知道这是不可能的，嘿嘿嘿)。它主要由下面三种组成，可以组合使用也可以单独使用。</p>
<ol>
<li><code>@property</code>：标识下面的方法为属性方法，同时激活setter，deleter</li>
<li><code>@方法.setter</code>：设置属性时调用方法</li>
<li><code>@方法.deleter</code>：删除属性时调用方法</li>
</ol>
<p>不使用属性装饰器时，我们为了隐藏某个属性可以使用如下方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self):    <span style="color:#75715e"># 一般称为getter方法</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setage</span>(self, value):  <span style="color:#75715e"># 一般称为setter方法</span>
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> value

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
daxin<span style="color:#f92672">.</span>setage(<span style="color:#ae81ff">30</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age())
</code></pre></div><p>        使用起来很别扭，为什么获取age属性要加括号执行方法呢？如何能让用户在使用age或者setage时不要认为他们是在调用函数，而是一个属性呢，下面使用属性装饰器property来完成这个需求</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age

    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self):    <span style="color:#75715e"># 一般称为getter方法</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age
        
daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age)
</code></pre></div><p>        添加了@property装饰器以后，被他装饰的函数，就可以像普通的属性来访问了(daxin.age，就是daxin.age()的返回值),那是否可以使用daxin.age=100来设置age属性的值呢？</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">daxin<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span> 
<span style="color:#f92672">&gt;&gt;</span> <span style="color:#a6e22e">AttributeError</span>: can<span style="color:#e6db74">&#39;t set attribute</span>
</code></pre></div><p>        无法设置的，是因为property装饰的函数是只读的，如果要使用daxin.age = 100 来赋值时，还需要一个setter装饰器来装饰一个设置属性的函数，并且这个函数必须和property装饰的函数的名称相同。那如果要删除呢，自然就触发了deleter装饰器了，我们在方法中，删除属性即可。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:

    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age
        
    <span style="color:#a6e22e">@property</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self):    <span style="color:#75715e"># 一般称为getter方法</span>
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age
    
    <span style="color:#a6e22e">@age.setter</span>    <span style="color:#75715e"># 被装饰的函数.setter(设置一个属性的值时触发)</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self,value):
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> value 
    
    <span style="color:#a6e22e">@age.deleter</span>   <span style="color:#75715e"># 删除一个属性时触发(很不常用)</span>
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">age</span>(self):
        <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>__age

daxin <span style="color:#f92672">=</span> Person()
<span style="color:#66d9ef">print</span>(daxin<span style="color:#f92672">.</span>age) <span style="color:#75715e"># 触发@property装饰过的age</span>
daxin<span style="color:#f92672">.</span>age <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>  <span style="color:#75715e"># 触发age.setter </span>
<span style="color:#66d9ef">del</span> daxin<span style="color:#f92672">.</span>age    <span style="color:#75715e"># 触发age.deleter      </span>
</code></pre></div><p>这样使用起来就比较方便了，当然property还提供了另一种写法<code>property(getter,settr,deleter,'description')</code>,因为property实际上是一个class类而已。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name 
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age 
    
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getage</span>(self):
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>__age 
        
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">setage</span>(self, value):
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> value 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">delage</span>(self):
        <span style="color:#66d9ef">del</span> self<span style="color:#f92672">.</span>__age 
        
    age <span style="color:#f92672">=</span> property(getage,setage,delage,<span style="color:#e6db74">&#39;age property&#39;</span>)
</code></pre></div><p>例：快速实现一个只读属性</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name, age<span style="color:#f92672">=</span><span style="color:#ae81ff">18</span>):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
        self<span style="color:#f92672">.</span>__age <span style="color:#f92672">=</span> age 
        
    age <span style="color:#f92672">=</span> property(<span style="color:#66d9ef">lambda</span> self:self<span style="color:#f92672">.</span>__age)  <span style="color:#75715e"># 快捷包装一个只读属性。</span>
</code></pre></div><blockquote>
<p>因为lambda不支持等号，而setter中有赋值等号，所以lambda就无法实现这个需求了。</p>
</blockquote>
<h2 id="56-对象的销毁">5.6 对象的销毁</h2>
<p>        <code>__init__</code> 用于在对象被实例化时为对象初始化一些属性信息，按照其他语言的逻辑，也可以称之为构造器，既然有构造器，那么就会有析构器，即在对象被销毁时执行。在Python的类中使用__del__方法定义的函数称为析构函数，在对象被销毁时触发执行。需要注意的是，这个方法不能引起对象本身的销毁，只是对象销毁的时候会自动调用它。换言之，就是当对象引用计数为0时，触发销毁操作(标记为可回收，等待GC)，而销毁操作又会触发对象的__del__方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span>:
    <span style="color:#66d9ef">def</span> __init__(self, name):
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name

    <span style="color:#66d9ef">def</span> __del__(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} is die&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>name))

daxin <span style="color:#f92672">=</span> Person(<span style="color:#e6db74">&#39;daxin&#39;</span>)
daxin<span style="color:#f92672">.</span>__del__()    <span style="color:#75715e"># 仅仅是执行__del__方法，不会真正销毁</span>
daxin<span style="color:#f92672">.</span>__del__()    <span style="color:#75715e"># 仅仅是执行__del__方法，不会真正销毁</span>
<span style="color:#66d9ef">del</span> daxin   <span style="color:#75715e"># 在本例中引用计数为0，即真正的销毁</span>

<span style="color:#75715e"># 代码执行完毕后也会触发销毁操作。</span>
</code></pre></div><blockquote>
<p>一般在析构函数中清理当前实例中申请的内存空间或者某些对象，做一些资源释放的工作。</p>
</blockquote>
<h2 id="57-方法重载overload">5.7 方法重载(overload)</h2>
<p>        在其他面向对象的高级语言中，会有重载的改变。所谓重载，就是同一个方法名，但是参数数量、类型不一样，就是同一个方法的重载。</p>
<p>下面是一段模拟其他语言方法重载的<code>伪代码</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">x</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">y</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">pass</span>
}
    
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">x</span> <span style="color:#a6e22e">array</span>,<span style="color:#a6e22e">y</span> <span style="color:#a6e22e">array</span>) {
    <span style="color:#a6e22e">pass</span> 
}
    
<span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>)
<span style="color:#a6e22e">test</span>([<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">2</span>])
</code></pre></div><p>        在其他语言中，当test(4,5)时会调用上面的函数，当test([1],[2])会调用下面的函数，这就叫做类型重载，传递不同的参数类型，就会执行对应的方法，而在Python中，后面的会直接覆盖前面的同名函数，所以Python没有重载，当然Python也不需要重载,为什么呢？因为Python的动态语言的特性，其实悄悄的就实现了其他语言的类型重载</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test</span>(x,y):
    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">+</span> y 
    
test(<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>)
test([<span style="color:#ae81ff">1</span>],[<span style="color:#ae81ff">2</span>])
test(<span style="color:#e6db74">&#39;a&#39;</span>,<span style="color:#e6db74">&#39;b&#39;</span>)
</code></pre></div><p>        在Python中上面是可以执行的，但是在其他语言中，可能就需要对应三个函数处理不同类型的数据，然后通过类型重载来调用。由于Python语言的特性，天生就能实现类型重载的功能。
{% endraw %}</p>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "your_disqus_shortname";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "your_disqus_shortname";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="https://dachenzi.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

