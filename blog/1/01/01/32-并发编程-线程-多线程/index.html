<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>32-并发编程-线程-多线程 &middot; Lee Xin</title>

  
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/poole-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-overrides.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/hyde-x.css">
  <link rel="stylesheet" href="https://dachenzi.github.io/css/highlight/sunburst.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dachenzi.github.io/touch-icon-144-precomposed.png">
  <link href="https://dachenzi.github.io/favicon.png" rel="icon">

  
  
  
  

  <meta name="description" content="Your default page description">
  <meta name="keywords" content="your,default,page,keywords">
  
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'Your Google Analytics tracking code', 'auto');
    ga('send', 'pageview');
  </script>
  
</head>
<body class="theme-base-08">
<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      
      <h1>Lee Xin</h1>
      <p class="lead">Your favourite quote or soundbite.</p>
    </div>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item"><a href="https://dachenzi.github.io/">Blog</a></li>
      
    </ul>

    <ul class="sidebar-nav">
      <li class="sidebar-nav-item">
      
      
      
      
      
      
      
      
      
      </li>
    </ul>

    
    <p><script id='flattr'>
      (function(id){
        var s = document.getElementById(id);
        var f = document.createElement('iframe');
        f.src = '//api.flattr.com/button/view/?uid=&button=compact&url=https:\/\/dachenzi.github.io\/&title=daxin\u0027s blog';
        f.title = 'Flattr';
        f.height = 20;
        f.width = 110;
        f.style.borderWidth = 0;
        s.parentNode.insertBefore(f, s);
      })('flattr');
    </script></p>
    

    <p>Copyright &copy; 2020 <a href="https://dachenzi.github.io/license/">License</a><br/>
       Powered by <a href="http://gohugo.io">Hugo</a> and <a href="https://github.com/zyro/hyde-x">Hyde-X</a></p>

  </div>
</div>


<div class="content container">
  <div class="post">
    <h1 class="post-title">32-并发编程-线程-多线程</h1>
    <span class="post-date">Jan 1, 0001 &middot; 4 minute read &middot; <a href="https://dachenzi.github.io/blog/1/01/01/32-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/#disqus_thread">Comments</a>
    </span>
    <p>{% raw %}</p>
<h1 id="1-概述">1 概述</h1>
<p>        我们都知道windows是支持多任务的操作系统。<br>
        什么叫&rsquo;多任务&rsquo;呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>
        现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>
        答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</p>
<blockquote>
<p>这里的执行时间，一般被称为时间片，即操作系统把CPU的时间划分为一个一个的时间片，在一个时间片内，线程可以可劲儿的运行，时间一到，当前线程就被挂起了。</p>
</blockquote>
<p>        真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。<br>
        对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。<br>
        有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个&rsquo;子任务'，我们把进程内的这些&rsquo;子任务&rsquo;称为线程（Thread）。<br>
        由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。<br>
        我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？有两种解决方案：</p>
<ul>
<li>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</li>
<li>一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</li>
</ul>
<p>        当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。总结一下就是，多任务的实现有3种方式：</p>
<ol>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式</li>
</ol>
<p>        同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。</p>
<blockquote>
<p>Python既支持多进程，又支持多线程。</p>
</blockquote>
<h1 id="2-进程和线程">2 进程和线程</h1>
<p>        进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程(Thread)是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位。</p>
<blockquote>
<p>一个程序的执行实例就是一个进程</p>
</blockquote>
<h2 id="21-进程和线程的关系">2.1 进程和线程的关系</h2>
<p>        程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据(资源)，它也是线程的容器。</p>
<blockquote>
<p>Linux进程有父进程、子进程，而Windows中的进程都是平等关系。
        线程，有时被称为轻量级进程(Lightweight Process,LWP)，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。在许多系统中，创建一个线程比创建一个进程快10-100倍。</p>
</blockquote>
<h2 id="22-进程和线程的特点">2.2 进程和线程的特点</h2>
<p>现在操作系统提出进程的概念，每一个进程都认为自己独占所以计算机硬件资源：</p>
<ol>
<li>进程就是独立的王国，进程间不可以随便的共享数据(IPC)</li>
<li>线程就是省份，同一个进程内的线程可以共享进程资源，每一个线程拥有自己独立的堆栈。</li>
</ol>
<h2 id="23-线程与进程的区别">2.3 线程与进程的区别</h2>
<ol>
<li>线程共享创建它的进程的地址空间，进程拥有自己的地址空间</li>
<li>线程可以直接访问进程的数据，进程拥有它父进程内存空间的拷贝</li>
<li>线程可以和同一进程内其他的线程直接通信，进程必须interprocess communicateion(IPC机制)进行通信</li>
<li>线程可以被很容易的创建，而进程依赖于父进程内存空间的拷贝</li>
<li>线程可以直接控制同一进程内的其他线程，进程只能控制自己的子进程</li>
<li>改变主线程(控制)可能会影响其他线程，改变主进程不会影响它的子进程</li>
</ol>
<h2 id="23-线程的状态">2.3 线程的状态</h2>
<p>线程的状态如下表:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>就绪(Ready)</td>
<td>线程能够运行，但在等待被调度。可能线程刚刚创建启动，或者刚刚从阻塞中恢复，或者被其他线程抢占</td>
</tr>
<tr>
<td>运行(Running)</td>
<td>线程正在运行</td>
</tr>
<tr>
<td>阻塞(Blocked)</td>
<td>线程等待外部事件发生而无法运行，如磁盘I/O，网络I/O等。</td>
</tr>
<tr>
<td>终止(Terminated)</td>
<td>线程完成，或退出，或被取消</td>
</tr>
</tbody>
</table>
<p><img src="photo/xiancheng.png" alt="xiancheng"></p>
<h1 id="3-python线程">3 Python线程</h1>
<p>Python 标准库提供了 <code>thread</code> 和 <code>threading</code> 两个模块来对多线程进行支持。其中， thread 模块以低级、原始的方式来处理和控制线程，而 threading 模块通过对 thread 进行二次封装，提供了更方便的 api 来处理线程。编写多线程代码之前还需要知道:</p>
<ol>
<li>进程靠线程执行代码，至少有一个主线程，其他线程是工作线程。</li>
<li>主线程是第一个启动的线程</li>
<li>父线程：如果线程A启动了一个线程B，A就是B的父线程。</li>
<li>子线程：B就是A的子线程。</li>
</ol>
<h2 id="31-thread类">3.1 Thread类</h2>
<p>Thread 是threading模块中最重要的类之一，可以使用它来创建线程。Thread类的格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Thread</span>:
    <span style="color:#66d9ef">def</span> __init__(self, group<span style="color:#f92672">=</span>None, target<span style="color:#f92672">=</span>None,name<span style="color:#f92672">=</span>None,args<span style="color:#f92672">=</span>(), kwargs<span style="color:#f92672">=</span>None, <span style="color:#f92672">*</span>, daemon<span style="color:#f92672">=</span>None):
</code></pre></div><p>各参数含义如下：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>group</td>
<td>预留参数</td>
</tr>
<tr>
<td>traget</td>
<td>线程要干的事情，通常是一个函数</td>
</tr>
<tr>
<td>name</td>
<td>线程的名字</td>
</tr>
<tr>
<td>args</td>
<td>为函数传递的位置参数(元组)</td>
</tr>
<tr>
<td>kwargs</td>
<td>为函数传递的关键字参数(字典)</td>
</tr>
<tr>
<td>daemon</td>
<td>当它的值为True时使子线程变为守护线程，主线程退出后，子线程一同退出</td>
</tr>
</tbody>
</table>
<h3 id="311-运行线程">3.1.1 运行线程</h3>
<p>创建完子线程，那么就可以启动了，通常我们使用<code>start</code>方法来启动一个线程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(name):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello, {}&#39;</span><span style="color:#f92672">.</span>format(name))

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;daxin&#39;</span>,),name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin_thread&#39;</span>)
t<span style="color:#f92672">.</span>start()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;End&#39;</span>)

<span style="color:#75715e"># hello, daxin</span>
<span style="color:#75715e"># End</span>
</code></pre></div><h3 id="312-线程退出">3.1.2 线程退出</h3>
<p>Python没有提供线程退出的方法，线程在以下两种情况时退出：</p>
<ol>
<li>线程函数内语句执行完毕</li>
<li>线程函数中抛出未处理的异常</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(name):
    count <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">while</span> True:
        time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> <span style="color:#ae81ff">5</span>:
            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">Exception</span>(<span style="color:#e6db74">&#39;Bye Bye&#39;</span>)   <span style="color:#75715e"># 异常退出(线程关闭)</span>
        <span style="color:#66d9ef">if</span> count <span style="color:#f92672">==</span> <span style="color:#ae81ff">10</span>:
            <span style="color:#66d9ef">break</span>                        <span style="color:#75715e"># 执行完毕后退出(线程关闭)</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello, {}&#39;</span><span style="color:#f92672">.</span>format(name))
        count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;daxin&#39;</span>,),name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin_thread&#39;</span>)
t<span style="color:#f92672">.</span>start()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;End&#39;</span>)

<span style="color:#75715e"># hello, daxin</span>
<span style="color:#75715e"># End</span>
</code></pre></div><h3 id="313-属性方法">3.1.3 属性方法</h3>
<p>threading模块还提供了许多用于查看线程相关属性的方法：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>current_thread()</td>
<td>返回当前线程对象</td>
</tr>
<tr>
<td>main_thread()</td>
<td>返回主线程对象</td>
</tr>
<tr>
<td>active_count()</td>
<td>当前处于alive状态的线程个数</td>
</tr>
<tr>
<td>enumerate()</td>
<td>返回所以或者的线程的列表，不包括已经终止的线程和未开始的线程</td>
</tr>
<tr>
<td>get_ident()</td>
<td>返回当前线程的ID，非0整数</td>
</tr>
<tr>
<td>name</td>
<td>返回线程的名字(属性)</td>
</tr>
<tr>
<td>ident</td>
<td>线程的ID(属性)</td>
</tr>
<tr>
<td>is_alive()</td>
<td>返回线程是否还或者</td>
</tr>
<tr>
<td>start()</td>
<td>启动线程，每个线程只能启动一次</td>
</tr>
<tr>
<td>run()</td>
<td>运行线程函数</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(name):
    current_thread <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>current_thread()
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;我的名字：{}  我的ID：{}  我的状态：{}&#39;</span><span style="color:#f92672">.</span>format(current_thread<span style="color:#f92672">.</span>name,current_thread<span style="color:#f92672">.</span>ident,current_thread<span style="color:#f92672">.</span>is_alive()))
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)   <span style="color:#75715e"># 执行完会立即退出，这里为了掩饰，让它停顿一秒</span>

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;daxin&#39;</span>,),name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin_thread&#39;</span>)
t<span style="color:#f92672">.</span>start()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;主线程：{}&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>main_thread()))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;存活的线程数量：{}&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>active_count()))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;存活的线程: {}&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>enumerate()))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;End&#39;</span>)

<span style="color:#75715e"># 我的名字：daxin_thread  我的ID：6820  我的状态：True</span>
<span style="color:#75715e"># 主线程：&lt;_MainThread(MainThread, started 22980)&gt;</span>
<span style="color:#75715e"># 存活的线程数量：2</span>
<span style="color:#75715e"># 存活的线程: [&lt;_MainThread(MainThread, started 22980)&gt;, &lt;Thread(daxin_thread, started 6820)&gt;]</span>
<span style="color:#75715e"># End</span>
</code></pre></div><blockquote>
<p>线程的ID是会重复利用的，所以说一个线程消亡，那么下一个新建的线程可能还会服用之前线程的ID。所以不要以为这个线程执行完毕还在存活。</p>
</blockquote>
<h3 id="314-start方法和run方法">3.1.4 start方法和run方法</h3>
<p>        start和run方法看起来都是启动一个线程用的，他们的主要区别时，start方法执行后会开启一个新的线程，然后在新的线程中调用run方法运行我们指定的函数，而run方法只会在当前线程中调用我们指定的函数，实际上就是在主线程调用了一个普通的函数而已。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span>(threading<span style="color:#f92672">.</span>Thread):

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">start</span>(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} , start ～～～&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>__class__))
        super()<span style="color:#f92672">.</span>start()

    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} , run ~~~~&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>__class__))
        super()<span style="color:#f92672">.</span>run()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>():
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am worker&#39;</span>)

t <span style="color:#f92672">=</span> MyThread(target<span style="color:#f92672">=</span>worker, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin&#39;</span>)
t<span style="color:#f92672">.</span>start()

<span style="color:#75715e"># &lt;class &#39;__main__.MyThread&#39;&gt; , start ～～～</span>
<span style="color:#75715e"># &lt;class &#39;__main__.MyThread&#39;&gt; , run ~~~~</span>
<span style="color:#75715e"># I am worker</span>
</code></pre></div><p>先执行了start方法，然后调用了run方法。观察start方法的原码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 查看start干了啥</span>
_start_new_thread(self<span style="color:#f92672">.</span>_bootstrap, ())

<span style="color:#75715e"># 查看self._bootstrap干了啥</span>
self<span style="color:#f92672">.</span>_bootstrap_inner()

<span style="color:#75715e"># 操作了一个属性</span>
self<span style="color:#f92672">.</span>_started<span style="color:#f92672">.</span>set()

<span style="color:#75715e"># 设置为True了</span>
self<span style="color:#f92672">.</span>_flag <span style="color:#f92672">=</span> True
</code></pre></div><p>这么做是为什么呢？，来看一下start方法的运行条件</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>_started<span style="color:#f92672">.</span>is_set():
    <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">RuntimeError</span>(<span style="color:#e6db74">&#34;threads can only be started once&#34;</span>)
</code></pre></div><p>总结一下就是说：当我们使用start方法运行一个子进程的时候，它会检测_started属性，它的初始值是False，当运行以后，它被置为True，下次再运行时，就会异常提示，所以线程只能被运行一次。</p>
<h2 id="32-多线程">3.2 多线程</h2>
<p>多线程故名思议，多个线程运行</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>():
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am worker&#39;</span>)


t1 <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin1&#39;</span>)
t2 <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker, name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;daxin2&#39;</span>)
t1<span style="color:#f92672">.</span>start()
t2<span style="color:#f92672">.</span>start()
<span style="color:#66d9ef">print</span>(threading<span style="color:#f92672">.</span>enumerate())  <span style="color:#75715e"># [&lt;_MainThread(MainThread, started 15012)&gt;, &lt;Thread(daxin1, started 20808)&gt;, &lt;Thread(daxin2, started 21328)&gt;]</span>
<span style="color:#66d9ef">print</span>(threading<span style="color:#f92672">.</span>active_count())  <span style="color:#75715e"># 3</span>
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
</code></pre></div><p>同时运行了t1，t2和当前主线程。所以打印当前活动线程的数量为3.</p>
<blockquote>
<p>一个进程中至少有一个线程，并作为程序的入口，这个线程就是主线程，一个进程至少有一个主线程。其他线程称为工作线程。</p>
</blockquote>
<h2 id="33-线程安全">3.3 线程安全</h2>
<p>        多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。<br>
        换句话说就是线程执行的结果(显示)不会因为其他因素(时间片用完被交换、网络I/O被等待等待其他因素)而改变。那么这个线程就是安全的，典型的print函数，就是一个线程不安全的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Thread: {} start~~~&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>ident))

count <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">while</span> count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>:
    t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work)
    t<span style="color:#f92672">.</span>start()
    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>

<span style="color:#75715e"># 输出结果</span>
<span style="color:#75715e"># Thread: 11276 start~~~</span>
<span style="color:#75715e"># Thread: 11276 start~~~Thread: 5056 start~~~</span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># Thread: 11276 start~~~</span>
<span style="color:#75715e"># Thread: 5056 start~~~Thread: 23320 start~~~</span>
<span style="color:#75715e"># Thread: 20652 start~~~</span>
<span style="color:#75715e"># Thread: 11276 start~~~Thread: 23320 start~~~Thread: 12016 start~~~Thread: 12356 start~~~Thread: 21532 start~~~Thread: 16908 start~~~</span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># Thread: 12672 start~~~</span>
<span style="color:#75715e"># Thread: 19372 start~~~</span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># Thread: 11276 start~~~Thread: 12016 start~~~</span>
<span style="color:#75715e"># Thread: 5056 start~~~</span>
<span style="color:#75715e"># Thread: 19372 start~~~</span>
<span style="color:#75715e"># </span>
<span style="color:#75715e"># Thread: 20652 start~~~</span>

<span style="color:#75715e"># 上面代码需要在ipython环境下执行才会有类似的效果</span>
</code></pre></div><p>        我们看到上面的输出信息，有很多都打在了一起，这是因为print函数在执行打印完毕，然后换行的时候，时间片用完被暂停运行，其他线程的print函数开始运行，向输出终端开始打印信息，而此时光标在还在上一行的末尾，所以就连续输出了，等到再次切换回来，只剩换行符了，所以会看到有一些空行是输出。</p>
<blockquote>
<p>print函数的输出信息是原子的，即组成一句话整体被打印，而打印换行符的时候是可以被中断的，所以也可以在print函数打印的字符串中手动添加\n,然后指定sep=&lsquo;&lsquo;即可。这里只讨论线程安全问题。</p>
</blockquote>
<p>        相对于print函数来说，logging模块都是线程安全的。将上面的例子换成logging就可以完美打印了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> logging

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
        logging<span style="color:#f92672">.</span>warning(<span style="color:#e6db74">&#39;Thread: {} start~~~&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>ident))

count <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>
<span style="color:#66d9ef">while</span> count <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">20</span>:
    t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work)
    t<span style="color:#f92672">.</span>start()
    count <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
</code></pre></div><h2 id="34-daemon和non-daemon线程">3.4 daemon和non-daemon线程</h2>
<p>        daemon,守护进程。用于告诉子线程要追随主线程的状态，即主线程退出，子线程不管有没有执行完毕，都要跟着退出。Python中，构建线程的时候，可以设置线程是否是守护线程，需要注意的是这个属性必须在start方法前设置。(线程都已经运行起来了，你还设置，有毛用啊。)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Worked&#39;</span>)
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">10</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Finished&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work,daemon<span style="color:#f92672">=</span>True)
t<span style="color:#f92672">.</span>start()

time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;运行完毕，主线程关闭&#39;</span>)

<span style="color:#75715e"># I am Worked</span>
<span style="color:#75715e"># 运行完毕，主线程关闭</span>
</code></pre></div><p>设置线程t的属性为守护进程，当主线程执行完print后，虽然子线程还在睡眠中，但是也会被强制关闭，所以&rsquo;I am Finished&rsquo;不会被打印。<strong><code>默认情况下，主线程是non-daemon的。如果没有指定子线程的daemon属性，那么它会取当前线程的daemon的值</code></strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work2</span>():
    <span style="color:#75715e"># time.sleep(10)</span>
    current <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>current_thread()
    <span style="color:#66d9ef">print</span>(current<span style="color:#f92672">.</span>daemon)   <span style="color:#75715e"># 继承work线程的daemon属性，这里是True</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Work2&#39;</span>)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Worked&#39;</span>)
    t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work2)
    t<span style="color:#f92672">.</span>start()
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Finished&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work,daemon<span style="color:#f92672">=</span>True)
t<span style="color:#f92672">.</span>start()

time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
</code></pre></div><p>关于daemin的其他属性：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>isDaemon()</td>
<td>是否是daemon线程</td>
</tr>
<tr>
<td>setDaemon</td>
<td>设置daemon线程(<code>必须在start方法之前</code>)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>主线程执行完毕后，会检查是否有子线程的daemon属性是False，如果有，则等待子线程执行完毕后退出，如果没有，则直接退出。</p>
</blockquote>
<h2 id="35-join方法">3.5 join方法</h2>
<p>用于告知当前线程等待某个线程终止后再执行，这种等待是阻塞的。它的格式为:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">threadobj<span style="color:#f92672">.</span>join(timeout<span style="color:#f92672">=</span>None)
</code></pre></div><p>timeout用于指定具体等待多久，默认为None，表示永远等下去，否则只等待指定的时间。看下面的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Worked&#39;</span>)
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;I am Finished&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>work, daemon<span style="color:#f92672">=</span>True)
t<span style="color:#f92672">.</span>start()

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;主线程执行完毕，准备退出了&#39;</span>)
t<span style="color:#f92672">.</span>join() 
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;主线程退出&#39;</span>)

<span style="color:#75715e"># 结果</span>
<span style="color:#75715e"># I am Worked</span>
<span style="color:#75715e"># 主线程执行完毕，准备退出了</span>
<span style="color:#75715e"># I am Finished</span>
<span style="color:#75715e"># 主线程退出</span>
</code></pre></div><p>        t.join()表示阻塞等待，等待线程t执行完毕，再向后执行，所以会打印&rsquo;I am Finished&rsquo;。如果不等待，线程t的daemon属性为True，那么主线程执行完毕，就会直接退出了。</p>
<blockquote>
<p>在哪个线程join()，那么哪个线程就会等待，并阻塞。</p>
</blockquote>
<h2 id="36-daemon的使用场景">3.6 daemon的使用场景</h2>
<p>当你把一个线程设置为daemon，它可以随主线程的退出而退出：</p>
<ol>
<li>后台任务。如发送心跳包、监控、这种场景最多。</li>
<li>主线程工作才有用的线程。如主线程中维护公共资源，主线程已经能够被清理了。工作线程也就没有了意义，一起退出最合适。</li>
<li>随时可以被终止的线程。</li>
</ol>
<h2 id="37-threadinglocal类">3.7 threading.Local类</h2>
<p>        在多线程环境下，每个线程都有自己的数据。一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁(锁住资源，否则一旦在多个线程中修改，会产生无法预期的结果)。但是局部变量也有问题，就是在函数调用的时候，每次都要传递，感觉很麻烦。<br>
        在主进程中创建ThreadLocal对象，每个Thread对它都可以读写属性，但互不影响。你可以把ThreadLocal看成全局变量，但每个属性都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，ThreadLocal内部会处理。即：一个ThreadLocal变量虽然是全局变量，但每个线程都只能读写自己线程的独立副本，互不干扰。ThreadLocal解决了参数在一个线程中各个函数之间互相传递的问题。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

local <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>local()
local<span style="color:#f92672">.</span>x <span style="color:#f92672">=</span> <span style="color:#ae81ff">200</span>

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>():
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">100</span>):
        local<span style="color:#f92672">.</span>x <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;{} {}&#39;</span><span style="color:#f92672">.</span>format(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>name,local<span style="color:#f92672">.</span>x))

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
    t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>worker)
    t<span style="color:#f92672">.</span>start()

<span style="color:#66d9ef">print</span>(local<span style="color:#f92672">.</span>x)
</code></pre></div><p>上面的执行结果是互补不干扰的。为什么local对象可以安全使用？<br>
        通过分析原码，我们看到：在主线程中创建后local后，threading.local会为实例初始化一个字典管理器，创建一个大字典，用于嵌套每一个线程创建的它自己线程相关的字典。当开启了新的线程时，查找local对象的某个属性时，首先会被__getattribute__方法捕获，在内部又调用了包装为上下文管理器的_path(打补丁)，首先它通过local初始化时构建的key(prefix+id(当前线程))来查找它嵌套的字典。如果不存在说明线程第一次运行，为它初始化一个__dict__属性字典，替换local的属性，如果存在，则把字典管理器拿出来，直接替换local的属性。所以在不同线程内，每个local对象在调用时都会切换到它对应的__dict__上。线程执行完毕后，回到主线程，在_path中重新切换到主线程的小字典，然后继续把local对象的__dict__进行切换。<br>
        一句话总结：<strong><code>运行时，threading.local实例处在不同的线程中，就从大字典中找到当前线程相关键值对中的字典，覆盖threading.local实例的 __dict__ 。这样就可以在不同的线程中，安全地使用线程独有的数据，做到了线程间数据隔离，如同本地变量一样安全。</code></strong></p>
<p>简单的模拟thread_local的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Mylocal</span>(object):
    <span style="color:#66d9ef">def</span> __init__(self):
        self<span style="color:#f92672">.</span>storage <span style="color:#f92672">=</span> {}

    <span style="color:#66d9ef">def</span> __getitem__(self, item):
        process_ident <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>get_ident()
        <span style="color:#66d9ef">return</span> self<span style="color:#f92672">.</span>storage[process_ident][item]

    <span style="color:#66d9ef">def</span> __setitem__(self, key, value):
        process_ident <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>get_ident()
        <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>storage<span style="color:#f92672">.</span>get(process_ident, None):
            self<span style="color:#f92672">.</span>storage[process_ident][key] <span style="color:#f92672">=</span> value
        <span style="color:#66d9ef">else</span>:
            self<span style="color:#f92672">.</span>storage[process_ident] <span style="color:#f92672">=</span> {key: value}

data <span style="color:#f92672">=</span> Mylocal()

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sum</span>():
    data[<span style="color:#e6db74">&#39;value&#39;</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">while</span> True:
        <span style="color:#66d9ef">if</span> data[<span style="color:#e6db74">&#39;value&#39;</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>:
            data[<span style="color:#e6db74">&#39;value&#39;</span>] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
            time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
            <span style="color:#66d9ef">print</span>(data[<span style="color:#e6db74">&#39;value&#39;</span>])
        <span style="color:#66d9ef">else</span>:
            <span style="color:#66d9ef">print</span>(data[<span style="color:#e6db74">&#39;value&#39;</span>])
            <span style="color:#66d9ef">break</span>

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    threads <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
        t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Thread(target<span style="color:#f92672">=</span>sum, name<span style="color:#f92672">=</span>i)
        threads<span style="color:#f92672">.</span>append(t)
        t<span style="color:#f92672">.</span>start()

    <span style="color:#66d9ef">for</span> thread <span style="color:#f92672">in</span> threads:
        thread<span style="color:#f92672">.</span>join()

    <span style="color:#66d9ef">print</span>(data<span style="color:#f92672">.</span>storage)  <span style="color:#75715e"># {18900: {&#39;value&#39;: 10}, 22140: {&#39;value&#39;: 10}, 25816: {&#39;value&#39;: 10}, 17784: {&#39;value&#39;: 10}, 20588: {&#39;value&#39;: 10}, 3744: {&#39;value&#39;: 10}, 10448: {&#39;value&#39;: 10}, 15896: {&#39;value&#39;: 10}, 18016: {&#39;value&#39;: 10}, 16824: {&#39;value&#39;: 10}}</span>
</code></pre></div><h2 id="38-timer定时器">3.8 Timer定时器</h2>
<p>threading模块提供了一个Timer定时器对象，用于告诉某一线程延迟多久执行一个函数。它的基本格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">threading<span style="color:#f92672">.</span>Timer(interval, function, args<span style="color:#f92672">=</span>None, kwargs<span style="color:#f92672">=</span>None)
</code></pre></div><ul>
<li>interval:表示延迟时间(秒)</li>
<li>function: 同target，要执行的函数</li>
<li>args/kwargs：传递的位置/关键字参数</li>
</ul>
<p>timer对象执行start方法后，会等待interval的时间，然后开始执行function函数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Timer(<span style="color:#ae81ff">3</span>, work,)
t<span style="color:#f92672">.</span>start()
</code></pre></div><p>我们看到Timer类没有提供daemon参数，但因为它也是继承自Thread对象，所以如果要设置只能使用setDeamon方法了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    <span style="color:#66d9ef">print</span>(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>isDaemon())
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Timer(<span style="color:#ae81ff">3</span>, work,)
t<span style="color:#f92672">.</span>setDaemon(True)   <span style="color:#75715e"># 设置deamon属性</span>
t<span style="color:#f92672">.</span>start()
</code></pre></div><p>添加daemon以后，一启动，主进程执行完毕，直接退出了，定时器就没机会执行了。当然也可以通过Timer对象的cancel方法来取消定时器</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> threading
<span style="color:#f92672">import</span> time
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">work</span>():
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">2</span>)
    <span style="color:#66d9ef">print</span>(threading<span style="color:#f92672">.</span>current_thread()<span style="color:#f92672">.</span>isDaemon())
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;hello world&#39;</span>)

t <span style="color:#f92672">=</span> threading<span style="color:#f92672">.</span>Timer(<span style="color:#ae81ff">3</span>, work,)
t<span style="color:#f92672">.</span>start()
time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">4</span>)
t<span style="color:#f92672">.</span>cancel()
</code></pre></div><p>但如果定时器已经在运行，那么就无法取消了。cancel本质上使用的死Event对象实现的。
{% endraw %}</p>

  </div>
  <div id="disqus_thread"></div>
</div>


<script type="text/javascript">
var disqus_shortname = "your_disqus_shortname";
(function () {
    var s = document.createElement('script'); s.async = true;
    s.type = 'text/javascript';
    s.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
}());
</script>



<script type="text/javascript">
    var disqus_shortname = "your_disqus_shortname";
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<script src="https://dachenzi.github.io/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>

