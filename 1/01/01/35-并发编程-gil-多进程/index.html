<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>35-并发编程-GIL-多进程  &middot; dahl&#39;s blog</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="" />

<meta name="keywords" content="">


<meta property="og:title" content="35-并发编程-GIL-多进程  &middot; dahl&#39;s blog ">
<meta property="og:site_name" content="dahl&#39;s blog"/>
<meta property="og:url" content="https://dachenzi.github.io/1/01/01/35-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-gil-%E5%A4%9A%E8%BF%9B%E7%A8%8B/" />
<meta property="og:locale" content="en-EN">


<meta property="og:type" content="article" />
<meta property="og:description" content=""/>
<meta property="og:article:published_time" content="0001-01-01T00:00:00Z" />
<meta property="og:article:modified_time" content="0001-01-01T00:00:00Z" />

  
    
  

  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "35-并发编程-GIL-多进程",
    "author": {
      "@type": "Person",
      "name": "daxin.li"
    },
    "datePublished": "0001-01-01",
    "description": "",
    "wordCount":  762 
  }
</script>



<link rel="canonical" href="https://dachenzi.github.io/1/01/01/35-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-gil-%E5%A4%9A%E8%BF%9B%E7%A8%8B/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dachenzi.github.io/touch-icon-144-precomposed.png">
<link href="https://dachenzi.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.75.1" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight/default.css">

  
  
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'Your Google Analytics tracking code', 'auto');
	  ga('send', 'pageview');

	</script>

</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://dachenzi.github.io">
  foobar

</a>

</div>

  
<div class="container topline">
  
  few words about your site


</div>


</div>

  <nav class="container nav primary no-print">
  

<a class="homelink" href="https://dachenzi.github.io">home</a>


  
<a href="https://dachenzi.github.io/about">About</a>

<a href="https://dachenzi.github.io/post" title="Show list of posts">Posts</a>

<a href="https://dachenzi.github.io/tags" title="Show list of tags">Tags</a>


</nav>

<div class="container nav secondary no-print">
  
<a id="contact-link-email" class="contact_link" rel="me" aria-label="Email" href="mailto:dahlhin.li@gmail.com">
  <span class="fa fa-envelope-square"></span></a>



<a id="contact-link-github" class="contact_link" rel="me" aria-label="Github" href="https://github.com/enten/hugo-boilerplate">
  <span class="fa fa-github-square"></span></a>




 


















</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1>35-并发编程-GIL-多进程
</h1>

  <div class="metas">
<time datetime="0001-01-01">1 Jan, 0001</time>


  
  &middot; Read in about 4 min
  &middot; (762 Words)
  <br>
  


</div>

</header>

  <div class="container content">
  <p>{% raw %}</p>
<p><!-- raw HTML omitted --><strong>文章目录</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#1-gil">1 GIL</a>
<ul>
<li><a href="#11-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89gil">1.1 为什么会有GIL</a></li>
<li><a href="#12-gil%E4%B8%8Ethread-lock">1.2 GIL与thread lock</a>
<ul>
<li><a href="#13-%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93">1.3 个人总结</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-multiprocessing%E6%A8%A1%E5%9D%97">2 multiprocessing模块</a>
<ul>
<li><a href="#21-process%E7%B1%BB">2.1 Process类</a></li>
<li><a href="#22-process%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95">2.2 Process类的方法</a></li>
<li><a href="#23-process%E7%9A%84%E5%85%B6%E4%BB%96%E5%B1%9E%E6%80%A7">2.3 Process的其他属性</a></li>
<li><a href="#23-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8">2.3 基本使用</a></li>
<li><a href="#24-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%94%81">2.4 进程同步锁</a></li>
<li><a href="#25-%E8%BF%9B%E7%A8%8B%E6%B1%A0">2.5 进程池</a>
<ul>
<li><a href="#251-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.5.1 常用方法</a></li>
<li><a href="#252-asyncresul%E5%AF%B9%E8%B1%A1%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">2.5.2 AsyncResul对象常用方法</a></li>
<li><a href="#253-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">2.5.3 回调函数</a></li>
</ul>
</li>
<li><a href="#26-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF">2.6 进程间通讯</a>
<ul>
<li><a href="#261-%E9%98%9F%E5%88%97">2.6.1 队列</a></li>
<li><a href="#262-%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE">2.6.2 共享数据</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="1-gil">1 GIL</h1>
<p>        GIL：<code>Global Interpreter Lock</code> 全局解释器锁，它的含义是：<strong><code>在同一时间在某一个进程内，只有一个线程可以运行。即便是在多CPU下</code></strong> 。GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。</p>
<p>官方是这样解释GIL的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once.
This lock is necessary mainly because CPython’s memory management is not thread-safe.
<span style="color:#f92672">(</span>However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.<span style="color:#f92672">)</span>
 
<span style="color:#75715e"># 在CPython中，全局解释器锁或者简称GIL，</span>
<span style="color:#75715e"># 是一个用来阻止多线程程序在一次运行时多次执行Python字节码程序的锁，</span>
<span style="color:#75715e"># 在CPython中这个锁是必须的，因为CPython的内存管理不是线程安全的</span>
<span style="color:#75715e"># (然而，自从GIL存在，其他特性已经发展到依赖于GIL的强制执行)</span>
</code></pre></div><p>PS：为了防止多线程并发执行机器码。</p>
<h2 id="11-为什么会有gil">1.1 为什么会有GIL</h2>
<p>        由于物理上得限制，各CPU厂商在核心频率上的比赛已经被多核所取代。为了更有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。即使在CPU内部的Cache也不例外，为了有效解决多份缓存之间的数据同步时各厂商花费了不少心思，也不可避免的带来了一定的性能损失。<br>
        GIL本质就是一把互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全。</p>
<blockquote>
<p>可以肯定的一点是：保护不同的数据的安全，就应该加不同的锁。</p>
</blockquote>
<h2 id="12-gil与thread-lock">1.2 GIL与thread lock</h2>
<p>        GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理，如下图举例：
<img src="photo/gil.png" alt="gil"><br>
首先：在一个进程内的所有线程数据是共享的，由于GIL的存在，统一时刻只能一个线程在运行。</p>
<ol>
<li>线程1拿到GIL锁，加载count数据，准备修改的时候，被CPU进行调度</li>
<li>线程2拿到GIL锁，加载count数据(此时没有被修改),然后修改，保存，这时count的数据已经被修改了</li>
<li>线程1重新获取GIL锁，继续修改count的值，这时由于count的值已经变了，所以，就造成两个线程同时修改共享数据，并没有产生正确得结果。<br>
所以GIL是解释器级别的锁，用户数据，那么需要用户自行加锁处理。</li>
</ol>
<h3 id="13-个人总结">1.3 个人总结</h3>
<p>        多个线程先访问到解释器的代码，即拿到执行权限，然后将target的代码交给解释器的代码去执行<br>
        在一个python的进程内，不仅有应用的主线程或者由该主线程开启的其他线程，还有解释器开启的垃圾回收等解释器级别的线程，总之，所有线程都运行在这一个进程内，毫无疑问解释器的代码是所有线程共享的，所以垃圾回收线程也可能访问到解释器的代码而去执行，这就导致了一个问题:Python的垃圾回收线程在执行时，会扫描当前进程所在的内存空间中，引用计数为0的变量等信息，然后进行回收。如果没有GIL,那么在执行清理的动作，其他线程又对该变量进行赋值，那么当垃圾回收线程获取CPU执行权限后，会继续进行清理，那么就可能造成数据的混乱，所以当GIL锁存在时，当垃圾回收线程检测到引用计数为0的数据后，对数据进行加锁处理，这样即便是其他线程再次访问也不会造成数据的混乱。<br>
        由于GIL的存在，同一个进程下的线程，无法进行并发，并行也不行。 但是由于GIL是基于进程的，所以可以有多核多个进程并发，而每个进程下同时只能有一个线程运行。</p>
<h1 id="2-multiprocessing模块">2 multiprocessing模块</h1>
<p>        python中的多线程无法利用多核优势，如果想要充分地使用多核CPU的资源（CPU的数量可以用os.cpu_count()查看），在python中大部分情况需要使用多进程。Python提供了multiprocessing模块来开启多进程，并在某些子进程中执行定制的任务（比如函数）。</p>
<blockquote>
<p>该模块与多线程模块threading的编程接口类似.用起来也很相似</p>
</blockquote>
<p>        multiprocessing模块的功能众多：支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件。<br>
需要再次强调的一点是：<strong><code>与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内。</code></strong></p>
<h2 id="21-process类">2.1 Process类</h2>
<p><strong><code>注意：在windows中Process()必须放到# if __name__ == '__main__':下</code></strong></p>
<p>利用Process创建进程的类：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">Process<span style="color:#f92672">([</span>group <span style="color:#f92672">[</span>, target <span style="color:#f92672">[</span>, name <span style="color:#f92672">[</span>, args <span style="color:#f92672">[</span>, kwargs<span style="color:#f92672">]]]]])</span>  <span style="color:#75715e"># 由该类实例化得到的对象，表示一个子进程中的任务（尚未启动）</span>
</code></pre></div><p>强调：</p>
<ol>
<li>需要使用关键字的方式来指定参数</li>
<li>args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</li>
</ol>
<p>参数：</p>
<ul>
<li><code>group</code>：参数未使用，值始终为None</li>
<li><code>target</code>：表示调用对象，即子进程要执行的任务</li>
<li><code>args</code>：表示调用对象的位置参数元组，args=(1,2,&lsquo;egon&rsquo;,)</li>
<li><code>kwargs</code>：表示调用对象的字典,kwargs={&lsquo;name&rsquo;:&lsquo;egon&rsquo;,&lsquo;age&rsquo;:18}</li>
<li><code>name</code>：为子进程的名称</li>
</ul>
<h2 id="22-process类的方法">2.2 Process类的方法　　</h2>
<p>Process类与Thread类相同，提供了很多操作进程的方法，这里列举一些常用的。</p>
<ul>
<li><code>p.start()</code>：启动进程，并调用该子进程中的p.run() &ndash;&gt; 和直接调用run方法是不同的，因为它会初始化部分其他参数。</li>
<li><code>p.run()</code>：进程启动时运行的方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法</li>
<li><code>p.terminate()</code>：强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</li>
<li><code>p.is_alive()</code>：如果p仍然运行，返回True，否则返回False</li>
<li><code>p.join([timeout])</code>：主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是可选的超时时间，需要强调的是：p.join只能join住start开启的进程，而不能join住run开启的进程</li>
</ul>
<h2 id="23-process的其他属性">2.3 Process的其他属性　</h2>
<ul>
<li><code>p.daemon</code>：默认值为False，如果设为True，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且设定为True后，p不能创建自己的新进程；必须在p.start()之前设置</li>
<li><code>p.name</code>：进程的名称</li>
<li><code>p.pid</code>：进程的pid</li>
<li><code>p.exitcode</code>：进程在运行时为None、如果为–N，表示被信号N结束(了解即可)，就像Linux下的命令执行返回值一样，0表示正常执行完毕</li>
<li><code>p.authkey</code>：进程的身份验证键，默认是由os.urandom()随机生成的32字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功</li>
</ul>
<blockquote>
<p>特别强调：设置 p.daemon=True 是会随着主进程执行完毕而被回收，不管子进程是否完成任务。</p>
</blockquote>
<h2 id="23-基本使用">2.3 基本使用</h2>
<p>使用Process创建进程的类有两种方法：</p>
<ul>
<li>通过实例化Process类完成进程的创建</li>
<li>继承Process类，定制自己需要的功能后实例化创建进程类</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">---------------------------</span> <span style="color:#960050;background-color:#1e0010">方法</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">---------------------------</span>
<span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> time
<span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
  
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">hello</span>(name):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Welcome to my Home&#39;</span>)
    time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>))
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Bye Bye&#39;</span>)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>hello,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;daxin&#39;</span>,))    <span style="color:#75715e"># 创建子进程p</span>
    p<span style="color:#f92672">.</span>start()      <span style="color:#75715e"># 启动子进程</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;主进程结束&#39;</span>)
 
 
<span style="color:#f92672">---------------------------</span> <span style="color:#960050;background-color:#1e0010">方法</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">---------------------------</span>
<span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> time
<span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process
 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyProcess</span>(Process):
 
    <span style="color:#66d9ef">def</span> __init__(self,name):
        super(MyProcess, self)<span style="color:#f92672">.</span>__init__()    <span style="color:#75715e"># 必须继承父类的构造函数</span>
        self<span style="color:#f92672">.</span>name <span style="color:#f92672">=</span> name
 
    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">run</span>(self):     <span style="color:#75715e"># 必须叫run方法，和thread一样，start方法开辟进程空间后执行run方法。</span>
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Welcome to {0} Home&#39;</span><span style="color:#f92672">.</span>format(self<span style="color:#f92672">.</span>name))
        time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>randint(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>))
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;Bye Bye&#39;</span>)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    p <span style="color:#f92672">=</span> MyProcess(<span style="color:#e6db74">&#39;daxin&#39;</span>)
    p<span style="color:#f92672">.</span>start()
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;主进程结束&#39;</span>)
</code></pre></div><h2 id="24-进程同步锁">2.4 进程同步锁</h2>
<p>        进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的,竞争带来的结果就是错乱，如何控制，就是加锁处理。</p>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> multiprocessing

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">fileinput</span>(filename,str):

    <span style="color:#66d9ef">with</span> open(filename,<span style="color:#e6db74">&#39;a&#39;</span>,encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;UTF-8&#39;</span>) <span style="color:#66d9ef">as</span> f:
        f<span style="color:#f92672">.</span>write(str)

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
        p <span style="color:#f92672">=</span> multiprocessing<span style="color:#f92672">.</span>Process(target<span style="color:#f92672">=</span>fileinput,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;a.txt&#39;</span>,<span style="color:#e6db74">&#39;进程 </span><span style="color:#e6db74">%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i))
        p<span style="color:#f92672">.</span>start()
</code></pre></div><p>打印的顺序：是谁抢到谁写，那么顺序可能不是1,2,3&hellip;9。<strong>锁的目的就是：当程序1在使用的时候，申请锁，并且锁住共享资源，待使用完毕后，释放锁资源，其他程序获取锁后，重复这个过程。</strong></p>
<p>Multiprocessing模块提供了Lock对象用来完成进程同步锁的功能</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Lock
lock <span style="color:#f92672">=</span> Lock()<span style="color:#960050;background-color:#1e0010">：对象没有参数，通过使用</span>lock对象的acquire<span style="color:#f92672">/</span>release方法来进行 <span style="color:#960050;background-color:#1e0010">锁</span><span style="color:#f92672">/</span><span style="color:#960050;background-color:#1e0010">释放</span> <span style="color:#960050;background-color:#1e0010">的需求。</span>
</code></pre></div><p>利用进程同步锁模拟抢票软件的需求：</p>
<ol>
<li>创建票文件，内容为json，设置余票数量</li>
<li>并发100个进程抢票</li>
<li>利用random + time 模块模拟网络延迟</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> random
<span style="color:#f92672">import</span> time
<span style="color:#f92672">import</span> json
<span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Process,Lock
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gettickles</span>(filename,str,lock):

    lock<span style="color:#f92672">.</span>acquire()      <span style="color:#75715e"># 对要修改的部分加锁</span>
    <span style="color:#66d9ef">try</span>:
        <span style="color:#66d9ef">with</span> open(filename, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#66d9ef">as</span> f:
            dic <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>loads(f<span style="color:#f92672">.</span>read())
    <span style="color:#66d9ef">except</span>:
        dic <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#39;count&#39;</span>:<span style="color:#ae81ff">100</span>}

    <span style="color:#66d9ef">if</span> dic[<span style="color:#e6db74">&#39;count&#39;</span>] <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> :
        dic[<span style="color:#e6db74">&#39;count&#39;</span>] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>
        time<span style="color:#f92672">.</span>sleep(random<span style="color:#f92672">.</span>random())
        <span style="color:#66d9ef">with</span> open(filename,<span style="color:#e6db74">&#39;w&#39;</span>,encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;utf-8&#39;</span>) <span style="color:#66d9ef">as</span> f:
            f<span style="color:#f92672">.</span>write(json<span style="color:#f92672">.</span>dumps(dic))
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[33m{0}抢票成功</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m&#39;</span><span style="color:#f92672">.</span>format(str))
    <span style="color:#66d9ef">else</span>:
        <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[35m{0}抢票失败</span><span style="color:#ae81ff">\033</span><span style="color:#e6db74">[0m&#39;</span><span style="color:#f92672">.</span>format(str))
 
    lock<span style="color:#f92672">.</span>release()     <span style="color:#75715e"># 修改完毕后解锁</span>
 
<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    lock <span style="color:#f92672">=</span> Lock()   <span style="color:#75715e"># 创建一个锁文件</span>
 
    p_l <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000</span>):
        p <span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>gettickles,args<span style="color:#f92672">=</span>(<span style="color:#e6db74">&#39;a.txt&#39;</span>,<span style="color:#e6db74">&#39;用户</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> i,lock))
        p_l<span style="color:#f92672">.</span>append(p)
        p<span style="color:#f92672">.</span>start()  
</code></pre></div><p>        加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</p>
<h2 id="25-进程池">2.5 进程池</h2>
<p>        在利用Python进行系统管理的时候，特别是同时操作多个文件目录，或者远程控制多台主机，并行操作可以节约大量的时间。多进程是实现并发的手段之一，需要注意的问题是：</p>
<ol>
<li>很明显需要并发执行的任务通常要远大于核数</li>
<li>一个操作系统不可能无限开启进程，通常有几个核就开几个进程</li>
<li>进程开启过多，效率反而会下降（开启进程是需要占用系统资源的，而且开启多余核数目的进程也无法做到并行）</li>
</ol>
<p>        例如当被操作对象数目不大时，可以直接利用multiprocessing中的Process动态成生多个进程，十几个还好，但如果是上百个，上千个。。。手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。我们就可以通过维护一个进程池来控制进程数目，比如httpd的进程模式，规定最小进程数和最大进程数&hellip;</p>
<blockquote>
<p>对于远程过程调用的高级应用程序而言，应该使用进程池，Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，就重用进程池中的进程。</p>
</blockquote>
<p>        创建进程池的类：如果指定numprocess为3，则进程池会从无到有创建三个进程，然后自始至终使用这三个进程去执行所有任务，不会开启其他进程</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Pool
pool <span style="color:#f92672">=</span> Pool(processes<span style="color:#f92672">=</span>None, initializer<span style="color:#f92672">=</span>None, initargs<span style="color:#f92672">=</span>())   <span style="color:#75715e"># 进程在这一句执行完毕后就创建好了。</span>
</code></pre></div><p>参数：</p>
<ul>
<li><code>processes</code>：进程池的最大进程数量</li>
<li><code>initiallizer</code>：初始化完毕后要执行的函数</li>
<li><code>initargs</code>：要传递给函数的参数</li>
</ul>
<h3 id="251-常用方法">2.5.1 常用方法</h3>
<ul>
<li><code>p.apply(func [, args [, kwargs]])</code>：调用进程池中的一个进程执行函数func，args/kwargs为传递的参数，注意apply是阻塞式的，既串行执行。</li>
<li><code>p.apply_async(func [, args [, kwargs]])</code>：功能同apply，区别是非阻塞的，既异步执行。(<code>常用</code>)</li>
<li><code>p.close()</code>：关闭进程池，防止进一步操作。如果所有操作持续挂起，它们将在工作进程终止前完成</li>
<li><code>p.join()</code>：等待所有工作进程退出。此方法只能在close()或teminate()之后调用</li>
</ul>
<p>注意：apply_async 会返回AsyncResul对象</p>
<h3 id="252-asyncresul对象常用方法">2.5.2 AsyncResul对象常用方法</h3>
<ul>
<li><code>obj.get()</code>：获取返回结果，默认等待结果到达。timeout为等待时间，默认为None(永久阻塞等待)。如果在指定时间内还没有到达，将引发multiprocessing.context.TimeoutError异常。如果远程操作中引发了异常，它将在调用此方法时再次被引发。</li>
<li><code>obj.ready()</code>：如果进程执行完成，返回True</li>
<li><code>obj.successful()</code>：如果进程执行完成且没有引发异常，返回True，如果在结果就绪之前调用此方法，引发AssertionError异常</li>
<li><code>obj.wait([timeout])</code>：等待进程执行完毕(内部也是基于event.wait()来做的)。</li>
<li><code>obj.terminate()</code>：立即终止所有工作进程，同时不执行任何清理或结束任何挂起工作。如果p被垃圾回收，将自动调用此函数</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> multiprocessing

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">calc</span>(count<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>):
    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(count):
        sum <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    <span style="color:#66d9ef">return</span> sum

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    pool <span style="color:#f92672">=</span> multiprocessing<span style="color:#f92672">.</span>Pool(<span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
        res <span style="color:#f92672">=</span> pool<span style="color:#f92672">.</span>apply_async(func<span style="color:#f92672">=</span>calc,args<span style="color:#f92672">=</span>(<span style="color:#ae81ff">100000000</span>,))
        <span style="color:#66d9ef">print</span>(res<span style="color:#f92672">.</span>ready())     <span style="color:#75715e"># False</span>
        <span style="color:#75715e"># res.wait(2)          # 阻塞2秒等待进程执行完毕，否则跳过等待</span>
        <span style="color:#75715e"># print(res.get(2))    # 获取执行结果，阻塞等待2秒</span>
        <span style="color:#66d9ef">print</span>(res<span style="color:#f92672">.</span>successful())
    pool<span style="color:#f92672">.</span>close()
    pool<span style="color:#f92672">.</span>join()
</code></pre></div><h3 id="253-回调函数">2.5.3 回调函数</h3>
<p>        需要回调函数的场景：进程池中任何一个任务一旦处理完了，就立即告知主进程：我好了额，你可以处理我的结果了。主进程则调用一个函数去处理该结果，该函数即回调函数。我们可以把耗时间（阻塞）的任务放到进程池中，然后指定回调函数（主进程负责执行），这样主进程在执行回调函数时就省去了I/O的过程，直接拿到的是任务的结果。</p>
<pre><code>apply_async(self, func, args=(), kwds={}, callback=None）
</code></pre><blockquote>
<p>func的结果会交给指定的callback函数处理,callback为单参函数，参数即为func的返回值。</p>
</blockquote>
<p>callback函数由主进程执行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">
<span style="color:#f92672">import</span> multiprocessing
<span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(process)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(threadName)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO,format<span style="color:#f92672">=</span>FORMAT)

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(count<span style="color:#f92672">=</span><span style="color:#ae81ff">10000</span>):
    sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(count):
        sum <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
    logging<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#39;I am worker&#39;</span>)
    <span style="color:#66d9ef">return</span> sum

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">result</span>(res):
    logging<span style="color:#f92672">.</span>info(res)


<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    pool <span style="color:#f92672">=</span> multiprocessing<span style="color:#f92672">.</span>Pool(<span style="color:#ae81ff">3</span>)
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
        pool<span style="color:#f92672">.</span>apply_async(worker,args<span style="color:#f92672">=</span>(<span style="color:#ae81ff">1000000</span>,),callback<span style="color:#f92672">=</span>result)

    pool<span style="color:#f92672">.</span>close()
    pool<span style="color:#f92672">.</span>join()
    logging<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#39;I am Main&#39;</span>)

<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">097</span> <span style="color:#ae81ff">24400</span> MainThread I am worker
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">097</span> <span style="color:#ae81ff">2916</span> Thread<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1000000</span>
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">115</span> <span style="color:#ae81ff">19364</span> MainThread I am worker
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">115</span> <span style="color:#ae81ff">2916</span> Thread<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1000000</span>
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">117</span> <span style="color:#ae81ff">37836</span> MainThread I am worker
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">117</span> <span style="color:#ae81ff">2916</span> Thread<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span> <span style="color:#ae81ff">1000000</span>        <span style="color:#75715e"># process ID 为主进程，所以回调函数，由主进程完成</span>
<span style="color:#ae81ff">2019</span><span style="color:#f92672">-</span><span style="color:#ae81ff">03</span><span style="color:#f92672">-</span><span style="color:#ae81ff">04</span> <span style="color:#ae81ff">20</span>:<span style="color:#ae81ff">10</span>:<span style="color:#ae81ff">49</span>,<span style="color:#ae81ff">175</span> <span style="color:#ae81ff">2916</span> MainThread I am Main    <span style="color:#75715e"># 主进程 ID 2916</span>
</code></pre></div><p>一个爬虫的小例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Pool
<span style="color:#f92672">import</span> requests
<span style="color:#f92672">import</span> os
 
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">geturl</span>(url):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;我的进程号为： </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> os<span style="color:#f92672">.</span>getpid())
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;我处理的url为： </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> &#39;</span> <span style="color:#f92672">%</span> url )
    response <span style="color:#f92672">=</span> requests<span style="color:#f92672">.</span>get(url)    <span style="color:#75715e"># 请求网页</span>
    <span style="color:#66d9ef">return</span> response<span style="color:#f92672">.</span>text     <span style="color:#75715e"># 返回网页源码</span>
 
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">urlparser</span>(htmlcode):
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;我的进程号是: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> &#39;</span> <span style="color:#f92672">%</span> os<span style="color:#f92672">.</span>getpid())
    datalength <span style="color:#f92672">=</span> len(htmlcode)      <span style="color:#75715e"># 计算源码的长度</span>
    <span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;解析到的html大小为： </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> datalength)
 
 
 
<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    pool <span style="color:#f92672">=</span> Pool()
    url <span style="color:#f92672">=</span> [
        <span style="color:#e6db74">&#39;http://www.baidu.com&#39;</span>,
        <span style="color:#e6db74">&#39;http://www.sina.com&#39;</span>,
        <span style="color:#e6db74">&#39;http://www.qq.com&#39;</span>,
        <span style="color:#e6db74">&#39;http://www.163.com&#39;</span>
    ]
 
    res_l <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> url:
        res <span style="color:#f92672">=</span> pool<span style="color:#f92672">.</span>apply_async(geturl,args<span style="color:#f92672">=</span>(i,),callback<span style="color:#f92672">=</span>urlparser)    <span style="color:#75715e"># res 是 geturl执行的结果，因为已经交给urlparser处理了，所以这里不用拿</span>
        res_l<span style="color:#f92672">.</span>append(res)
 
    pool<span style="color:#f92672">.</span>close()
    pool<span style="color:#f92672">.</span>join()
    <span style="color:#66d9ef">for</span> res <span style="color:#f92672">in</span> res_l:
        <span style="color:#66d9ef">print</span>(res<span style="color:#f92672">.</span>get())    <span style="color:#75715e"># 这里拿到的就是网页的源码</span>
</code></pre></div><h2 id="26-进程间通讯">2.6 进程间通讯</h2>
<p>        进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块提供的两种形式：队列和管道，这两种方式都是使用消息传递的。但是还有一种基于共享数据的方式，现在已经不推荐使用，建议使用队列的方式进行进程间通讯。</p>
<blockquote>
<p>展望未来，基于消息传递的并发编程是大势所趋，即便是使用线程，推荐做法也是将程序设计为大量独立的线程集合，通过消息队列交换数据。这样极大地减少了对使用锁定和其他同步手段的需求，还可以扩展到分布式系统中。</p>
</blockquote>
<h3 id="261-队列">2.6.1 队列</h3>
<p>        底层就是以管道和锁定的方式实现。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">multiprocessing<span style="color:#f92672">.</span>Queue([maxsize])
</code></pre></div><p>创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。<br>
参数:</p>
<ul>
<li><code>maxsize</code>: 队列能承载的最大数量，省略的话则不限制队列大小</li>
</ul>
<!-- raw HTML omitted -->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Queue
 
q <span style="color:#f92672">=</span> Queue(<span style="color:#ae81ff">3</span>)
q<span style="color:#f92672">.</span>put(<span style="color:#e6db74">&#39;a&#39;</span>)          <span style="color:#75715e"># 数据存入Queue</span>
<span style="color:#66d9ef">print</span>(q<span style="color:#f92672">.</span>get())      <span style="color:#75715e"># 从Queue中取出数据</span>
</code></pre></div><p>注意：队列（Queue）是FIFO模式，既先进先出。</p>
<!-- raw HTML omitted -->
<ul>
<li><code>q.put(obj, block=True, timeout=None)</code>：用于插入数据到队列中。<br>
参数：
<ul>
<li>timeout：等待时间。</li>
<li>blocked：如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常。</li>
</ul>
</li>
</ul>
<blockquote>
<p>q.put_nowait() 等同于 q.put(block=False)</p>
</blockquote>
<ul>
<li><code>q.get(block=True,timeout=None)</code>：用于从队列中获取数据。
参数：
<ul>
<li>timeout：等待时间。</li>
<li>blocked：如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常.</li>
</ul>
</li>
</ul>
<blockquote>
<p>q.get_nowait() 等同于 q.get(block=False)</p>
</blockquote>
<ul>
<li><code>q.empty()</code>：调用此方法时q为空则返回True，该结果不可靠，比如在返回True的过程中，如果队列中又加入了项目。</li>
<li><code>q.full()</code>：调用此方法时q已满则返回True，该结果不可靠，比如在返回True的过程中，如果队列中的项目被取走。</li>
<li><code>q.qsize()</code>：返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</li>
</ul>
<h3 id="262-共享数据">2.6.2 共享数据</h3>
<p>        进程间数据是独立的，可以借助于队列或管道实现通信，二者都是基于消息传递的，虽然进程间数据独立，但也可以通过Manager实现数据共享，事实上Manager的功能远不止于此。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">multiprocessing<span style="color:#f92672">.</span>Manager() <span style="color:#960050;background-color:#1e0010">：没有参数</span>
</code></pre></div><blockquote>
<p>利用Manager创建数据，完成进程共享</p>
</blockquote>
<p>使用Manager对象创建共享数据类型</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> os
<span style="color:#f92672">from</span> multiprocessing <span style="color:#f92672">import</span> Manager,Process
 
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">worker</span>(d,l):
 
    d[os<span style="color:#f92672">.</span>getpid()]<span style="color:#f92672">=</span>os<span style="color:#f92672">.</span>getpid()   <span style="color:#75715e"># 对共享数据进行修改</span>
    l<span style="color:#f92672">.</span>append(os<span style="color:#f92672">.</span>getpid())

<span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;__main__&#39;</span>:
    m <span style="color:#f92672">=</span> Manager()
    d <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>dict()    <span style="color:#75715e"># 创建共享字典</span>
    l <span style="color:#f92672">=</span> m<span style="color:#f92672">.</span>list()    <span style="color:#75715e"># 创建共享列表</span>
 
    p_l <span style="color:#f92672">=</span> []
    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10</span>):
        p<span style="color:#f92672">=</span> Process(target<span style="color:#f92672">=</span>worker,args<span style="color:#f92672">=</span>(d,l))
        p_l<span style="color:#f92672">.</span>append(p)
        p<span style="color:#f92672">.</span>start()
 
    <span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> p_l:
        p<span style="color:#f92672">.</span>join()
 
    <span style="color:#66d9ef">print</span>(d)
    <span style="color:#66d9ef">print</span>(l)
</code></pre></div><p>{% endraw %}</p>

</div>


  <footer class="container">
  <div class="container navigation no-print">
  <h2>Navigation</h2>
  
  

    
    <a class="prev" href="https://dachenzi.github.io/1/01/01/36-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp%E7%BC%96%E7%A8%8B/" title="36-网络编程-TCP编程">
      Previous
    </a>
    

    
    <a class="next" href="https://dachenzi.github.io/1/01/01/33-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-event-lock/" title="33-并发编程-线程同步-Event-lock">
      Next
    </a>
    

  


</div>

  
<div class="container comments">
  <h2>Comments</h2>
  
<div id="disqus_thread"></div>
<script type="text/javascript">
  (function() {
    
    
    if (window.location.hostname == "localhost")
      return;

    var dsq = document.createElement('script'); dsq.async = true; dsq.type = 'text/javascript';
    dsq.src = '//your_disqus_shortname.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


</div>


</footer>

</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  
<a href="https://dachenzi.github.io/license">license</a>


  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  
  code with <!-- raw HTML omitted --><!-- raw HTML omitted -->


</div>


  
<div class="container copyright">
  
  (c) 2015 Lee xin.


</div>


</div>

</footer>

    </main>
    
<script type="text/javascript">
  (function() {
    
    
    if (window.location.hostname == "localhost")
      return;
    var dsq = document.createElement('script'); dsq.async = true; dsq.type = 'text/javascript';
    dsq.src = '//your_disqus_shortname.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>

