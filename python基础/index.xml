<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python基础s on dahl&#39;s blog</title>
    <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in Python基础s on dahl&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>dahlhin.li@gmail.com (daxin.li)</managingEditor>
    <webMaster>dahlhin.li@gmail.com (daxin.li)</webMaster>
    <copyright>(c) 2015 Lee xin.</copyright><atom:link href="https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-基础概念及环境部署</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</guid>
      <description>{% raw %}
文章目录 1. 编程基础  1.1. 基本概念 1.2. 语言分类 1.3. 高级语言的发展   2. 程序 3. python的语言介绍 4. Python的解释器 5. Python版本区别 6. Python安装  6.1. windows安装 6.2. Linux安装   7. pyenv多版本管理  7.1. pyenv介绍及安装 7.2. virtualenv 7.3. 导出项目依赖包 7.4. pyenv安装位置   8. pip命令  8.1. 命令说明 8.2. 配置说明   9. pycharm安装及基本使用 10. 第一个Python程序  1. 编程基础  首先，我们普及一下编程语言的基础知识。用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个MP3，编写一个文档等等，而计算机干活的CPU只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得&amp;rsquo;翻译&amp;rsquo;成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。
比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行。
所以Python是一种相当高级的语言。
你也许会问，代码少还不好？代码少的代价是运行速度慢，C程序运行1秒钟，Java程序可能需要2秒，而Python程序可能就需要10秒。
那是不是越低级的程序越难学，越高级的程序越简单？表面上来说，是的，但是，在非常高的抽象计算中，高级的Python程序设计也是非常难学的，所以，高级程序语言不等于简单。但是，对于初学者和完成普通任务，Python语言是非常简单易用的。连Google都在大规模使用Python，你就不用担心学了会没用。
用Python可以做什么？可以做日常任务，比如自动备份你的MP3；可以做网站，很多著名的网站包括YouTube就是Python写的；可以做网络游戏的后台，很多在线游戏的后台都是Python开发的。总之就是能干很多很多事啦。下面我们了解一下计算机的基础概念
1.1. 基本概念  程序：是一组能让计算机识别和执行的指令。 计算机五大部件：输入设备、输出设备、运算器、控制器、存储器，各部分主要作用：</description>
    </item>
    
    <item>
      <title>10-函数嵌套-作用域-闭包-LEGB-函数销毁</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/10-%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-legb-%E5%87%BD%E6%95%B0%E9%94%80%E6%AF%81/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/10-%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E9%97%AD%E5%8C%85-legb-%E5%87%BD%E6%95%B0%E9%94%80%E6%AF%81/</guid>
      <description>{% raw %}
文章目录 1 函数嵌套 2 作用域  2.1 global关键字   3 闭包  3.1 nonlocal关键字   4 默认值的作用域 5 变量名解析原则LEGB 6 函数的销毁  1 函数嵌套  一个函数中存在另外一个函数(定义/调用)，这种方式我们称之为函数嵌套。所以：函数的嵌套主要分为嵌套调用，以及嵌套定义。
函数的嵌套调用 def max2(a,b): # 判断两个变量的最大值 return a if a &amp;gt; b else b def max4(a,b,c,d): # 判断四个变量的最大值 res1 = max2(a,b) # 函数的嵌套调用 res2 = max2(res1,c) res3 = max(res2,d) print(res3) max4(10,100,21,99) 函数的嵌套定义 def func1(): print(&amp;#39;from func1&amp;#39;) def func2(): print(&amp;#39;from func2&amp;#39;) def func3(): print(&amp;#39;from func3&amp;#39;) func3() # 只有在func2中才能调用内部定义的函数func3 func2() func1()  注意：在函数的内部定义函数，只能在函数内部进行调用，在其他地方是无法进行调用，强行调用就会提示NameError异常，所以说函数是有可见范围的，这就涉及到了作用域了</description>
    </item>
    
    <item>
      <title>11-函数的执行流程-函数递归-匿名函数-生成器</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/11-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/11-%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>{% raw %}
文章目录 1 函数的执行流程  1.1 字节码了解压栈过程 1.2 嵌套函数的压栈   2 递归  2.1 递归函数 2.2 递归的性能 2.3 递归的优化 2.4 间接递归 2.5 递归总结   3 匿名函数 4 Python生成器  4.1 基本结构 4.2 使用场景 4.3 协程coriutine 4.4 yield from    1 函数的执行流程 函数的执行需要对函数进行压栈的，什么是压栈呢，简而言之就是在函数执行时在栈中创建栈帧存放需要变量以及指针的意思。具体涉及的知识非常多，这里就已一个Python脚本简单进行分析。
def foo1(b, b1=3): print(&amp;#39;call foo1&amp;#39;, b, b1) def foo2(c): foo3(c) print(&amp;#39;call foo2&amp;#39;, c) def foo3(d): print(&amp;#39;call foo3&amp;#39;, d) def main(): print(&amp;#39;call main&amp;#39;) foo1(100, 101) foo2(20) print(&amp;#39;main ending&amp;#39;) main() 当我们运行上面代码时，它的执行流程如下：</description>
    </item>
    
    <item>
      <title>12-树-基础知识-二叉树-完全二叉树-斜树</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/12-%E6%A0%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%96%9C%E6%A0%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/12-%E6%A0%91-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%96%9C%E6%A0%91/</guid>
      <description>{% raw %}
文章目录 1 树 2 树的概念 3 树的特点 4 二叉树  4.1 斜树 4.2 满二叉树 4.3 完全二叉树 4.4 二叉树的性质  4.4.1 性质1 4.4.2 性质2 4.4.3 性质3 4.4.4 性质4 4.4.5 性质5 4.4.6 其他性质      1 树  树在数据结构中属于一种非线性结构，每个元素可以有多个前驱和后继，它有如下定义：
树是n(n≥0)个元素的集合：
 n = 0 时，成为空树 树只有一个特殊的没有前驱的元素，称为数的根Root 树中除了根节点外，其余元素只能有一个前驱，可以有零个或者多个后继  递归定义：
 树T是n(n≥0)个元素的集合。n = 0 时，成为空树 有且只有一个特殊元素根，剩余元素都可以被划分为m个互不相交的集合T1，T2，&amp;hellip;，Tm，而每一个集合都是树，成为T的子树Subtree 子树也有自己的根  2 树的概念 树是一个中非常抽象的概念，下面主要介绍树中各种名词的含义：
   名称 含义     节点 数中的数据元素   数的度 树内各节点的度的最大值   节点的度(degree) 节点拥有的子树的数目成为度，记作d(v)   叶子节点 节点的度数为0，成为叶子节点leaf、终端节点、末端节点   分支节点 节点度数不为0，成为非终端节点或分支节点   分支 节点之间的关系   内部节点 除根节点外的分支节点，当然也不包括叶子节点   孩子(儿子Child)节点 节点的子树的根节点成为该节点的孩子   双亲(父Parent)节点 一个节点是它各个树的根节点的双亲   兄弟(Sibling)节点 具有相同双亲节点的节点   祖先节点 从根节点到该节点所经分支上所有的节点。   子孙节点 节点的所有子树上的节点都成为该节点的子孙。   节点的层次(Level) 根节点为第一层，根的孩子为第二层，依次类推记作(Lv)   树的深度(高度Depth) 树的层次的最大值   堂兄弟 双亲在同一层的节点   有序树 结点的子树是有顺序的(兄弟有大小，有先后次序)，不能交换   无序数 结点的子树是无序的，可以交换   路径 树中的k个节点n1、n2、&amp;hellip;nk，满足ni是n(i+1)的双亲，成为n1到nk的一条路径。就是一条线串下来的，前一个都是后一个父(前驱)节点。   森林 m(m≥0)课不相交的树的集合，对于节点而言，其子树的集合就是森林。        3 树的特点 下面我们来总结一下书的特点：</description>
    </item>
    
    <item>
      <title>13-高阶函数-柯里化-装饰器</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/13-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/13-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0-%E6%9F%AF%E9%87%8C%E5%8C%96-%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>{% raw %}
文章目录 1 高阶函数  1.1 自定义sort函数  1.1.1 将规模缩小，先实现排序，先不管key和reverse参数 1.1.2 添加reverse参数判断 1.1.3 添加key参数判断   1.2 内建函数(高阶函数)  1.2.1 sorted排序 1.2.2 filter 过滤 1.2.3 map 映射     2 柯里化 3 装饰器  3.1 需求分析 3.2 函数柯里化 3.3 装饰器函数(语法糖) 3.4 装饰器带来的问题 3.5 拷贝函数属性   4 代参装饰器  4.1 还是从一个需求开始 4.2 代参装饰器编写 4.3 代参装饰器小结    1 高阶函数  在Python中一切皆对象，当然也包括函数。函数在Python中是一等公民(First Class Object)。即函数与字符串数组整型无异，它可以被命名可以被赋值可以当作参数被传进另一个函数也可以被另一个函数当作返回值可以放在任何位置，简单来说：
 函数也是一个对象，并且是一个可调用对象(callable) 函数可以作为普通变量、参数、返回值等等   那什么是高阶函数呢？在Python中我们可以理解为：当一个函数接受另一个函数作为参数使用，或者一个函数最后返回了另外一个函数。在这两种情况下，这个函数就可以称之为高阶函数(满足以上任意一种情况即可，不必同时满足)。</description>
    </item>
    
    <item>
      <title>14-函数参数检测-inspect模块</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%A3%80%E6%B5%8B-inspect%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/14-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%A3%80%E6%B5%8B-inspect%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
文章目录 1 python类型注解 2 函数定义的弊端 3 函数文档 4 函数注解  4.1 annotation属性   5 inspect模块  5.1 常用方法 5.2 signature类 5.3 parameters属性 5.4 获取对象的参数签名   6 检查参数  1 python类型注解  类型注解，即对变量的类型，进行标注或者说明，因为Python是一门动态编译型语言，我们无法在赋值时就定义它的变量类型，所以在Python3.5以上版本新增了类型注解，但仅仅是提示作用，并不能严格控制，这是动态编译型语言的通病，下面来仔细看一下什么是Python的类型注解。
2 函数定义的弊端  Python是动态语言，变量随时可以被赋值，且赋值为不同的类型，这就与静态语言不同了，变量的类型是在运行期决定的，而静态语言事先就已经定义好了变量的类型了。这是动态语言方便之处，但也是一种弊端，我们无法控制变量的类型，也就无法控制异常的产生。举个栗子
def add(x,y): return x + y print(add(1,2)) print(add(&amp;#39;s&amp;#39;,&amp;#39;b&amp;#39;)) print(add(1,&amp;#39;a&amp;#39;))  当用户传入两个数字时，返回它们的和，但是如果我们传递其他变量呢？比如字符串，因为Python中实现了+号的类型重载，所以说两个字符串的确可以加，但是如果是数字和字符串呢？在Python这种强类型语言中来说，属于非法操作(javascript会隐式转换)，而这时，我们就需要对用户传入的数据进行类型判断，不符合本函数的需求，那么就抛个异常，或者提示等等操作，这样就不会引起后续代码在执行期崩溃。如何解决呢？其实主要有两种方式。
 函数文档 函数注解  3 函数文档  在函数中插入说明性文档的方式成为函数文档。
def add(x, y): &amp;#34;&amp;#34;&amp;#34; This function used to add something :param x: int object :param y: int object :return: int object &amp;#34;&amp;#34;&amp;#34; return x + y 在函数中，一般是定义语句后的首行使用三对双引号表示。通常存储在函数的__doc__属性中。当用户使用help(函数)时，会被打印在屏幕上。</description>
    </item>
    
    <item>
      <title>15-reduce-pratial偏函数-lsu_cache</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/15-reduce-pratial%E5%81%8F%E5%87%BD%E6%95%B0-lsu_cache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/15-reduce-pratial%E5%81%8F%E5%87%BD%E6%95%B0-lsu_cache/</guid>
      <description>{% raw %}
文章目录 介绍 1 reduce方法 2 partial方法(偏函数)  2.1 partial方法基本使用 2.2 partial原码分析 2.3 functools.warps实现分析   3 lsu_cache方法  3.1 基本使用 3.2 lru_cache原码分析 3.3 斐波那契序列的lru改造 3.4 lsu_cache的总结    介绍  functools模块存放着很多工具函数，大部分都是高阶函数，其作用于或返回其他函数的函数。一般来说，对于这个模块，任何可调用的对象都可以被视为函数。
1 reduce方法  其含义是减少，它接受一个两个参数的函数，初始时从可迭代对象中取两个元素交给函数，下一次会将本次函数返回值和下一个元素传入函数进行计算，直到将可迭代对象减少为一个值，然后返回：reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) calculates ((((1+2)+3)+4)+5),
reduce(function, sequence[, initial]) -&amp;gt; value  function: 两个参数的函数 sequence：可迭代对象(不能为空) initital：初始值(可以理解为给函数的第一个参数指定默认值)，否则第一次会在可迭代对象中再取一个元素  下面是一个求1到100累加的栗子
# 普通版 In [24]: sum = 0 In [25]: for i in range(1,101): .</description>
    </item>
    
    <item>
      <title>16-文件操作-StringIO-BytesIO</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/16-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-stringio-bytesio/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/16-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-stringio-bytesio/</guid>
      <description>{% raw %}
文章目录 1 文件操作  1.1 open函数介绍 1.2 打开操作  1.2.1 mode模式 1.2.2 文件指针 1.2.3 缓冲区 1.2.4 encoding编码 1.2.5 其他参数   1.3 读写操作 1.4 关闭操作 1.5 上下文管理 1.6 文件对象的其他方法   2 StringIO模块 3 BytesIO模块 4 file-like对象  1 文件操作  读写文件是最常见的IO操作(一般说IO操作，指的是文件IO，如果是网络，一般都会直接说网络IO)，在磁盘上读写文件的功能都是由操作系统提供的，操作系统不允许普通的程序直接操作磁盘(大部分程序都需要间接的通过操作系统来完成对硬件的操作)，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。在操作系统中，文件常用的操作有：
   功能 介绍     open 打开   read 读取   write 写   close 关闭   readline 行读取   readlines 多行读取   seek 文件指针操作   tell 指针操作    1.</description>
    </item>
    
    <item>
      <title>17-路径操作-shutil模块</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/17-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C-shutil%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/17-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C-shutil%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
文章目录 1 路径操作  1.1 os.path模块 1.2 pathlib模块  1.2.1 目录操作  初始化(一个路径对象) 路径拼接和分解 获取路径 父目录 目录的组成部分 全局方法及判断方法 通配符 目录属性   1.2.2 文件操作   1.3 os 模块   2 shutil模块  2.1 copy复制 2.2 rm删除 2.3 move移动 2.4 打包    1 路径操作  使用Python操作文件系统时,少不了会对路径进行切换,对目录的遍历,以及获取文件的绝对路径的一系列的操作,Python内置了相关的模块完成对应的功能,其中:
 3.4 以前使用os.path模块 3.4 开始使用pathlib模块  1.1 os.path模块  os.path是os模块中的一个比较重要的用来拼接、判断路径的主要方法，它主要有如下方法：
os.path.abspath(&amp;#39;dir/file&amp;#39;) 获取dir/file的绝对路径 os.path.split(&amp;#39;path&amp;#39;) 把路径分割为目录和文件名组成的元组格式，不管path是否存在 os.dirname(&amp;#39;path&amp;#39;) 获取文件的父目录名称，不管path是否存在 os.basename(&amp;#39;path&amp;#39;) 获取文件的名称，不管path是否存在 os.</description>
    </item>
    
    <item>
      <title>18-csv文件-ini文件处理</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/18-csv%E6%96%87%E4%BB%B6-ini%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/18-csv%E6%96%87%E4%BB%B6-ini%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86/</guid>
      <description>{% raw %}
文章目录 1 CSV文件  1.1 手动生成一个csv文件 1.2 cvs模块  1.2.1 reader方法 1.2.2 writer方法     2 ini文件处理  2.1 configparser模块 2.2 常用方法  2.2.1 读取配置配件 2.2.2 section操作 2.2.3 option操作 2.2.4 获取value 2.2.5 设置value 2.2.6 保存修改后的配置文件   2.3 字典的访问方式    1 CSV文件  逗号分隔值（Comma-Separated Values，CSV，有时也称为字符分隔值，因为分隔字符也可以不是逗号），其文件以纯文本形式存储表格数据（数字和文本）。
# 下面都是csv文件的内容格式 1,2,3,4,5 1,2,&amp;quot;1,3&amp;quot; 1,2,&amp;quot;a,&amp;quot;&amp;quot;f&amp;quot;  CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件。 CSV 不指定字符编码。  它有以下规范：
 行分隔符为\r\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符。每一行称为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。 如果字段的值是双引号，需要额外使用一个个双引号，表示一个转义。 表头可选，和字段列对齐就行了。  1.</description>
    </item>
    
    <item>
      <title>2-基础语法-操作符-循环控制</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/2-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%BE%AA%E7%8E%AF%E6%8E%A7%E5%88%B6/</guid>
      <description>{% raw %}
文章目录 1 Python 基础语法  1.1 注释 1.2 缩进 1.3 续行 1.4 标识符 1.5 转义序列 1.6 数字 1.7 字符串 1.8 其他   2 Python 运算符  2.1 赋值运算符 2.2 算数运算符 2.3 关系运算符 2.4 逻辑运算符 2.5 位运算符  2.5.1 原码、反码、补码、负数表示法 2.5.2 位运算符   2.6 成员、身份运算符 2.7 运算符优先级   3 Python 内存管理  3.1 Python的内存特性 3.2 Python的GC管理   4 程序控制  4.1 分支结构  4.1.1 单分支 4.</description>
    </item>
    
    <item>
      <title>23-面向对象基础-封装-属性-方法-访问控制</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/23-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-%E5%B0%81%E8%A3%85-%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/23-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-%E5%B0%81%E8%A3%85-%E5%B1%9E%E6%80%A7-%E6%96%B9%E6%B3%95-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</guid>
      <description>{% raw %}
文章目录 1 面向对象介绍 2 面向对象  2.1 类class 2.2 对象instance/object 2.3 Python的哲学思想   3 面向对象的要素 4 Python的类  4.1 类对象及属性 4.2 实例化  4.2.1 __init__函数 4.2.2 实例对象(instance) 4.2.3 实例变量和类变量 4.2.4 __dict__和变量查找顺序 4.2.5 总结   4.3 装饰一个类 4.4 类方法和静态方法  4.4.1 普通函数(不用) 4.4.2 类方法 4.4.3 静态方法(用的很少) 4.4.4 方法的调用     5 访问控制  5.1 私有属性 5.2 保护变量 5.3 私有方法 5.4 补丁：(黑科技) 5.5 属性装饰器 5.6 对象的销毁 5.</description>
    </item>
    
    <item>
      <title>24-面向对象基础-多继承-super-mro-Mixin</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/24-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BB%A7%E6%89%BF-super-mro-mixin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/24-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80-%E5%A4%9A%E7%BB%A7%E6%89%BF-super-mro-mixin/</guid>
      <description>{% raw %}
文章目录 1 类的继承 2 不同版本的类 3 基本概念 4 特殊属性和方法 5 继承中的访问控制 6 方法的重写(override)  6.1 super 6.2 继承中的初始化   7 多继承  7.1 多继承弊端 7.2 MRO 7.3 多继承的建议 7.4 Mixin  7.4.1 利用装饰器新增功能 7.4.2 Mixin类      1 类的继承  继承是面向对象的重要特性之一，是相对两个类而言的父子关系，子类继承了父类的所有的属性和方法，继承最大的好处是实现了代码的重用，可以重用已经存在的数据和行为，减少代码的重复编写。
2 不同版本的类  在Python2.2之前，类是没有共同的祖先的，之后，引入了object类，它是所有类的共同祖先类。Python2中为了兼容，分为古典类(旧式类)和新式类。而在Python 3中全部都为新式类，新式类都是继承object类的，并且可以使用super函数(后面会说)。下面是Python2.x中的代码
class A: pass class B(object): pass &amp;gt;&amp;gt;&amp;gt; dir(A) # 查看类的__dict__ [&amp;#39;__doc__&amp;#39;, &amp;#39;__module__&amp;#39;] &amp;gt;&amp;gt;&amp;gt; dir(B) [&amp;#39;__class__&amp;#39;, &amp;#39;__delattr__&amp;#39;, &amp;#39;__dict__&amp;#39;, &amp;#39;__doc__&amp;#39;, &amp;#39;__format__&amp;#39;, &amp;#39;__getattribute__&amp;#39;, &amp;#39;__hash__&amp;#39;, &amp;#39;__init__&amp;#39;, &amp;#39;__module__&amp;#39;, &amp;#39;__new__&amp;#39;, &amp;#39;__reduce__&amp;#39;, &amp;#39;__reduce_ex__&amp;#39;, &amp;#39;__repr__&amp;#39;, &amp;#39;__setattr__&amp;#39;, &amp;#39;__sizeof__&amp;#39;, &amp;#39;__str__&amp;#39;, &amp;#39;__subclasshook__&amp;#39;, &amp;#39;__weakref__&amp;#39;] 在Python2.</description>
    </item>
    
    <item>
      <title>25-面向对象高级-魔术方法基础</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/25-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/25-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E5%9F%BA%E7%A1%80/</guid>
      <description>{% raw %}
文章目录 1 魔术方法 2 类的魔术方法  2.1 基本的魔法方法和常用属性 2.2 有关属性 2.3 比较操作符 2.4 算数运算符 2.5 反运算 2.6 增量赋值运算 2.7 一元操作符 2.8 类型转换 2.9 上下文管理（with 语句） 2.10 容器类型   3 常用方法  3.1 查看属性 3.2 实例化 3.3 hash相关  3.3.1 hash相同能否去重 3.3.2 比较内容是否相同 3.3.3 坐标轴小例子   3.4 bool类型 3.5 可视化 3.6 运算符重载  3.6.1 实现两个实例相减 3.6.2 坐标轴小例子 3.6.3 应用场景 3.6.4 total_ordering装饰器   3.7 容器相关方法 3.8 可调用对象    1 魔术方法 　在Python中以两个下划线开头和结尾的方法，比如：__init__、__str__、__doc__、__new__等，被称为&amp;quot;魔术方法&amp;quot;（Magic methods）。魔术方法在类或对象的某些事件出发后会自动执行，如果希望根据自己的程序定制自己特殊功能的类，那么就需要对这些方法进行重写。</description>
    </item>
    
    <item>
      <title>26-面向对象高级-上下文管理-反射</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/26-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/26-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86-%E5%8F%8D%E5%B0%84/</guid>
      <description>{% raw %}
文章目录 1 上下文管理  1.1 上下文管理的安全性 1.2 返回值 1.3 方法的参数 1.4 计算函数的运行时间 1.5 主要应用场景 1.6 contextlib.contextmanager   2 反射  2.1 反射相关的函数 2.2 反射相关的魔术方法  2.2.1 getattr 2.2.2 setattr 2.2.3 delattr   2.3 getattribute    1 上下文管理 文件IO操作可以对文件对象使用上下文管理,它主要使用with..as..语法.
with open(&amp;#39;123.txt&amp;#39;) as f: print(f) 要想自己写的类实现上下文管理,那么需要用到两个方法__exit__和__enter__.
   方法 意义     __enter__ 进入与此对象相关的上下文,如果存放该方法,with语法会把该方法的返回值绑定到as子句中指定的变量上   __exit__ 退出与此对象相关的上下文    class Text: def __enter__(self): print(&amp;#39;enter------&amp;#39;) def __exit__(self, exc_type, exc_val, exc_tb): print(&amp;#39;exit-------&amp;#39;) with Text() as f : print(&amp;#39;进来了&amp;#39;) print(&amp;#39;出来了&amp;#39;) # enter------ # 进来了 # exit------- # 出来了 实例化对象的时候,并不会调用__enter__方法,只有进入with语句体中,才会调用__enter__方法,然后执行语句体,最后离开with语句块的时候,再调用__exit__方法.</description>
    </item>
    
    <item>
      <title>27-面向对象高级-描述器</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/27-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E6%8F%8F%E8%BF%B0%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/27-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7-%E6%8F%8F%E8%BF%B0%E5%99%A8/</guid>
      <description>{% raw %}
文章目录 1 描述器 2 描述器协议  2.1 非数据描述器  2.1.1 实例分析   2.2 数据描述器  2.2.1 实例   2.3 描述器的调用及属性访问顺序 2.4 描述器总结   3 Python的描述器体现  3.1 staticmethod简单实现 3.2 ClassMethod简单实现 3.3 对实例的数据进行校验  3.3.1 直接在__init__函数中检查 3.3.2 装饰器版本 3.3.3 描述器版本 3.3.4 装饰器+描述器版本之函数装饰器 3.3.5 装饰器+描述器版本之类装饰器     4 疑问  1 描述器  一般来说，一个描述器是一个有&#39;__绑定行为__&amp;lsquo;的对象属性(object attribute)，它的访问控制被描述器协议方法重写。这些方法是 __get__(), __set__(), 和 __delete__() 。
 有这些方法的对象叫做描述器。
  默认对属性的访问控制是从对象的字典里面(__dict__)中获取、设置和删除它。举例来说, 比如 a.</description>
    </item>
    
    <item>
      <title>28-生成器交互-__slots__-未实现异常</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/28-%E7%94%9F%E6%88%90%E5%99%A8%E4%BA%A4%E4%BA%92-__slots__-%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/28-%E7%94%9F%E6%88%90%E5%99%A8%E4%BA%A4%E4%BA%92-__slots__-%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8/</guid>
      <description>{% raw %}
文章目录 1 生成器交互 2 slots 3 未实现和未实现异常 4 Python的对象模型  1 生成器交互 生成器提供了一个send方法用于动态的和生成器对象进行交互。怎么理解的呢？看下面的例子：
def generator(): a = 0 while True: position = yield a # 格式 if position: a = position a += 1 g = generator() print(next(g)) g.send(10) print(next(g)) print(next(g))  上面的 变量 = yield 返回值，是生成器提供的交互格式，当我们使用生成器对象的send方法时，实参就会被传递给这里的position变量，从而在函数外部来控制函数内部的运行，同时send和next一样可以推动生成器的运行。
import time import random class Person: def __init__(self, name): self.name = name def eat(self): while True: something = yield print(&amp;#39;{} is eating {}&amp;#39;.</description>
    </item>
    
    <item>
      <title>29-异常处理-模块化</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/29-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E6%A8%A1%E5%9D%97%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/29-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E6%A8%A1%E5%9D%97%E5%8C%96/</guid>
      <description>{% raw %}
文章目录 1 异常  1.1 产生异常  1.1.1 解释器触发异常 1.1.2 手动触发异常   1.2 异常类型  1.2.1 自定义异常   1.3 异常处理(捕获)  1.3.1 多种捕获 1.3.2 finally子句引发的问题 1.3.3 异常的传递 1.3.4 异常的捕捉时机 1.3.5 小结     2 模块化  2.1 导入语句  2.1.1 import导入 2.1.2 from导入   2.2 自定义模块 2.3 模块搜索顺序 2.4 模块的重复导入 2.5 模块的运行 2.6 包  2.6.1 模块和包的区别   2.7 相对导入与绝对导入 2.8 访问控制  2.</description>
    </item>
    
    <item>
      <title>3-内置结构-列表</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/3-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/3-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%88%97%E8%A1%A8/</guid>
      <description>{% raw %}
文章目录 1 Python内置数据结构  1.1 数值型 1.2 math模块 1.3 round圆整 1.4 常用的其他函数 1.5 类型判断   2 列表  2.1 索引访问 2.2 列表和链表的区别 2.3 列表的查询 2.4 列表元素修改 2.5 列表的追加和插入 2.6 列表使用*重复带来的问题 2.7 删除元素 2.8 其他操作    1 Python内置数据结构  Python内置了很多数据结构(容器),供我们直接进行使用，在学习结构之前，有一些小的知识点进行补充。
1.1 数值型  int、float、complex、bool都是class、1，5.0，2+3j都是对象即实例 int：Python3的int就是长整型，且没有大小限制，受限于内存区域大小 float：有整数和小数部分组成。支持十进制和科学计数法表示。 complex：有实属和虚数部分组成，实数部分和虚数部分都是浮点数 bool：int的子类，仅有2个实例，True和False，其中True表示1，False表示0  In [2]: int(10.12) # 直接取整  Out[2]: 10 In [3]: int(-12) Out[3]: -12 In [4]: float(10) # 转换为浮点数  Out[4]: 10.</description>
    </item>
    
    <item>
      <title>31-gogs安装-git基础</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/31-gogs%E5%AE%89%E8%A3%85-git%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/31-gogs%E5%AE%89%E8%A3%85-git%E5%9F%BA%E7%A1%80/</guid>
      <description>{% raw %}
文章目录 1 Gogs安装 2 Git介绍 3 使用Github仓库  3.1 Git配置 3.2 远程仓库   4 Git基本使用  4.1 创建版本库 4.2 查看工作区状态 4.3 查看修改内容 4.4 查看提交日志 4.5 查看命令历史 4.6 版本回退   5 工作区、暂存区和版本库 6 Git高级  6.1 撤销修改  6.1.1 丢弃工作区的修改 6.1.2 丢弃暂存区的修改   6.2 删除文件 6.3 分支  6.3.1 创建及切换分支 6.3.2 合并分支及删除分支 6.3.3 普通模式合并分支 6.3.4 切换工作区 6.3.5 抓取分支   6.4 标签  6.4.1 新建一个标签 6.</description>
    </item>
    
    <item>
      <title>32-并发编程-线程-多线程</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/32-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/32-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</guid>
      <description>{% raw %}
1 概述  我们都知道windows是支持多任务的操作系统。
什么叫&amp;rsquo;多任务&amp;rsquo;呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。
现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？
答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。
 这里的执行时间，一般被称为时间片，即操作系统把CPU的时间划分为一个一个的时间片，在一个时间片内，线程可以可劲儿的运行，时间一到，当前线程就被挂起了。
  真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。
对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。
有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个&amp;rsquo;子任务&#39;，我们把进程内的这些&amp;rsquo;子任务&amp;rsquo;称为线程（Thread）。
由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。
我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办？有两种解决方案：
 一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。 一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。   当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。总结一下就是，多任务的实现有3种方式：
 多进程模式； 多线程模式； 多进程+多线程模式   同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于我们前面写的单进程单线程的程序。
 Python既支持多进程，又支持多线程。
 2 进程和线程  进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。线程(Thread)是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运作单位。
 一个程序的执行实例就是一个进程
 2.1 进程和线程的关系  程序是源代码编译后的文件，而这些文件存放在磁盘上。当程序被操作系统加载到内存中，就是进程，进程中存放着指令和数据(资源)，它也是线程的容器。
 Linux进程有父进程、子进程，而Windows中的进程都是平等关系。 线程，有时被称为轻量级进程(Lightweight Process,LWP)，是程序执行流的最小单元。一个标准的线程由线程ID，当前指令指针(PC)，寄存器集合和堆栈组成。在许多系统中，创建一个线程比创建一个进程快10-100倍。
 2.2 进程和线程的特点 现在操作系统提出进程的概念，每一个进程都认为自己独占所以计算机硬件资源：
 进程就是独立的王国，进程间不可以随便的共享数据(IPC) 线程就是省份，同一个进程内的线程可以共享进程资源，每一个线程拥有自己独立的堆栈。  2.3 线程与进程的区别  线程共享创建它的进程的地址空间，进程拥有自己的地址空间 线程可以直接访问进程的数据，进程拥有它父进程内存空间的拷贝 线程可以和同一进程内其他的线程直接通信，进程必须interprocess communicateion(IPC机制)进行通信 线程可以被很容易的创建，而进程依赖于父进程内存空间的拷贝 线程可以直接控制同一进程内的其他线程，进程只能控制自己的子进程 改变主线程(控制)可能会影响其他线程，改变主进程不会影响它的子进程  2.3 线程的状态 线程的状态如下表:</description>
    </item>
    
    <item>
      <title>33-并发编程-线程同步-Event-lock</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/33-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-event-lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/33-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-event-lock/</guid>
      <description>{% raw %}
文章目录 1 线程同步  1.1 Event  1.1.1 什么是Flag？ 1.1.2 Event原理 1.1.3 吃包子   1.2 Lock  1.2.1 lock方法 1.2.2 计数器 1.2.3 非阻塞锁 1.2.4 锁应用场景      1 线程同步  线程同步，线程间协同，通过某种技术，让一个线程访问某些数据时，其他线程不能访问这些数据，直到该线程完成对数据的操作后。不同的操作系统有多种实现方式。比如临界区(Critical Section)、互斥锁(Mutex)、信号量(Semaphore)、事件(Event)等。
1.1 Event  Event是线程间通讯机制最简单的实现，使用一个内部标记flag，主要提供了三个方法wait、clear、set，通过操作flag来控制线程的执行。
 clear()：将&amp;rsquo;Flag&amp;rsquo;设置为False。 set()：将&amp;rsquo;Flag&amp;rsquo;设置为True。 wait(timeout=None)：等待&amp;rsquo;Flag&amp;rsquo;为True后，继续执行(timeout为超时时间，否则永远等待)。 is_set(): 判断&amp;rsquo;Flag&amp;rsquo;是否为  1.1.1 什么是Flag？  Event对象在全局定义了一个&amp;rsquo;Flag&#39;，如果&amp;rsquo;Flag&amp;rsquo;值为 False，那么当程序执行 Event对象的wait方法时就会阻塞，如果&amp;rsquo;Flag&amp;rsquo;值为True，那已经阻塞的wait方法会继续执行。
1.1.2 Event原理  在使用threading.Event 实现线程间通信时：使用threading.Event可以使一个线程等待其他线程的通知，我们把这个Event传递到线程对象中，Event默认内置了一个标志，初始值为False。一旦该线程通过wait()方法进入等待状态，直到另一个线程调用该Event的set()方法将内置标志设置为True时，该Event会通知所有等待状态的线程恢复运行。
1.1.3 吃包子 有下面代码，大欣负责吃包子，厨师负责做包子，只有厨师做好了，大欣才能开始吃。
import time import random event = threading.</description>
    </item>
    
    <item>
      <title>35-并发编程-GIL-多进程</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/35-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-gil-%E5%A4%9A%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/35-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-gil-%E5%A4%9A%E8%BF%9B%E7%A8%8B/</guid>
      <description>{% raw %}
文章目录 1 GIL  1.1 为什么会有GIL 1.2 GIL与thread lock  1.3 个人总结     2 multiprocessing模块  2.1 Process类 2.2 Process类的方法 2.3 Process的其他属性 2.3 基本使用 2.4 进程同步锁 2.5 进程池  2.5.1 常用方法 2.5.2 AsyncResul对象常用方法 2.5.3 回调函数   2.6 进程间通讯  2.6.1 队列 2.6.2 共享数据      1 GIL  GIL：Global Interpreter Lock 全局解释器锁，它的含义是：在同一时间在某一个进程内，只有一个线程可以运行。即便是在多CPU下 。GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL。
官方是这样解释GIL的：
In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once.</description>
    </item>
    
    <item>
      <title>36-网络编程-TCP编程</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/36-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/36-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-tcp%E7%BC%96%E7%A8%8B/</guid>
      <description>{% raw %}
文章目录 1 概述 2 TCP/IP协议基础 3 TCP编程  3.1 通信流程 3.2 构建服务端 3.3 构建客户端 3.4 常用方法  3.4.1 makefile方法   3.5 socket交互  3.4.1 通讯循环及客户端发空消息时的问题 3.4.2 链接循环及客户端强制退出时的问题 3.4.3 模拟远程执行命令   3.6 粘包问题  3.6.1 struct模块 3.6.2 通过struct传递包头解决粘包问题 3.6.3 大并发时的问题   3.6 聊天室  3.6.1 聊天室之函数实现 3.6.2 聊天室之类实现      1 概述  自从互联网诞生以来，现在基本上所有的程序都是网络程序，很少有单机版的程序了。
计算机网络就是把各个计算机连接到一起，让网络中的计算机可以互相通信。网络编程就是如何在程序中实现两台计算机的通信。
举个例子，当你使用浏览器访问新浪网时，你的计算机就和新浪的某台服务器通过互联网连接起来了，然后，新浪的服务器把网页内容作为数据通过互联网传输到你的电脑上。
由于你的电脑上可能不止浏览器，还有QQ、微信、邮件客户端等，不同的程序连接的别的计算机也会不同，所以，更确切地说，网络通信是两台计算机上的两个进程之间的通信。比如，浏览器进程和新浪服务器上的某个Web服务进程在通信，而QQ进程是和腾讯的某个服务器上的某个进程在通信。
网络编程对所有开发语言都是一样的，Python也不例外。用Python进行网络编程，就是在Python程序本身这个进程内，连接别的服务器进程的通信端口进行通信。
2 TCP/IP协议基础  计算机为了联网，就必须规定通信协议，早期的计算机网络，都是由各厂商自己规定一套协议，IBM、Apple和Microsoft都有各自的网络协议，互不兼容，这就好比一群人有的说英语，有的说中文，有的说德语，说同一种语言的人可以交流，不同的语言之间就不行了。</description>
    </item>
    
    <item>
      <title>37-网络编程-UDP编程</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/37-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-udp%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/37-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-udp%E7%BC%96%E7%A8%8B/</guid>
      <description>{% raw %}
文章目录 1 UDP协议 2 UDP通信流程 3 UDP编程  3.1 构建服务端 3.2 构建客户端 3.3 常用方法   4 聊天室 5 UDP协议应用  1 UDP协议 UDP是面向无连接的协议，使用UDP协议时，不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发数据包。但是，能不能到达就不知道了。虽然用UDP传输数据不可靠，但它的优点是和TCP比，速度快，对于不要求可靠到达的数据，就可以使用UDP协议。
2 UDP通信流程 我们先来了解一下，python的socket的通讯流程:
服务端：
 创建Socket对象 绑定IP地址Address和端口Port，使用bind方法，IPv4地址为一个二元组(&amp;lsquo;IP&amp;rsquo;,Port)，一个UDP端口只能被绑定一次 接受数据，recvfrom方法，使用缓冲区接受数据 发送数据，sendto方法，类型为bytes 关闭连接  客户端：
 创建Socket对象 连接服务端。connect方法（可选） 发送数据，sendto/send方法，类型为bytes 接受数据，recvfrom/recv方法，使用缓冲区接受数据 关闭连接   我们可以看到UDP不需要维护一个连接，所以比较简单
 3 UDP编程  使用udp编程和使用tcp编程用于相似的步骤，而因为udp的特性，它的服务端不需要监听端口，并且客户端也不需要事先连接服务端。根据上图，以及建立服务端的流程，我门来捋一下服务端的逻辑到代码的步骤：
3.1 构建服务端  创建服务端  socket = socket.socket(socket.AF_INET,socket.SOCK_DGRAM) # socke.AF_INET 指的是使用 IPv4 # socket.SOCK_STREAM 指定使用面向数据报的UDP协议 绑定IP地址和端口。  socket.</description>
    </item>
    
    <item>
      <title>38-网络编程-socketserver</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/38-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socketserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/38-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socketserver/</guid>
      <description>{% raw %}
文章目录 1 socket编程弊端 2 SocketServer模块  2.1 服务器类 2.2 Mixin类 2.3 RequestHandlerClass是啥 2.4 编程接口   3 实现EchoServer 4 聊天室  1 socket编程弊端 socket编程过于底层，编程虽然有套路，但是要写出健壮的代码还是比较困难的，所以很多语言都会socket底层API进行封装，Python的封装就是SocketServer模块。它是网络服务编程框架，便于企业级快速开发。
2 SocketServer模块 SocketServer，网络通信服务器，是Python标准库中的一个高级模块，其作用是创建网络服务器。该模块简化了编写网络服务器的任务。
2.1 服务器类 SocketServer模块中定义了五种服务器类。
 BaseServer(server_address, RequestHandlerClass)：服务器的基类，定义了API。 TCPServer(server_address, RequestHandlerClass, bind_and_activate=True)：使用TCP/IP套接字。 UDPServer：使用数据报套接字 UnixStreamServer：使用UNIX套接字，只适用UNIX平台 UnixDatagramServer：使用UNIX套接字，只适用UNIX平台  它们的继承关系：
+------------+ | BaseServer | +------------+ | v +-----------+ +------------------+ | TCPServer |-------&amp;gt;| UnixStreamServer | +-----------+ +------------------+ | v +-----------+ +--------------------+ | UDPServer |-------&amp;gt;| UnixDatagramServer | +-----------+ +--------------------+  除了基类为抽象基类意外，其他四个类都是同步阻塞的。</description>
    </item>
    
    <item>
      <title>39-同步-异步-IO多路复用</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/39-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/39-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
      <description>{% raw %}
文章目录 1 同步与异步 2 阻塞与非阻塞 3 什么是IO  3.1 内核态用户态 3.2 IO两个阶段 3.3 IO模型  3.3.1 同步阻塞IO 3.3.2 同步非阻塞IO 3.3.3 IO多路复用 3.3.4 异步IO     4 Python中的IO多路复用  4.1 selectors库 4.2 register方法 4.3 利用selectors完成IO多路复用版本的EchoServer 4.4 聊天室    1 同步与异步 同步和异步关注的是程序在执行时的状态：
 同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，这时程序是出于阻塞的，只有接收到返回的值或消息后才往下执行其他的命令。 异步，执行完函数或方法后，不必阻塞性地等待返回值或消息，只需要向系统委托一个异步过程，那么当系统接收到返回值或消息时，系统会自动触发委托的异步过程，从而完成一个完整的流程。   同步如打电话，通信双方不能断（我们是同时进行，同步），你一句我一句，这样的好处是，对方想表达的信息我马上能收到，但是，我在打着电话，我无法做别的事情。 异步如收发收短信，对比打电话，打电话我一定要在电话的旁边听着，保证双方都在线，而收发短信，对方不用保证此刻我一定在手机旁，同时，我也不用时刻留意手机有没有来短信。这样的话，我看着视频，然后来了短信，我就处理短信（也可以不处理），接着再看视频。   对于写程序，同步往往会阻塞，没有数据过来，我就等着，异步则不会阻塞，没数据来我干别的事，有数据来去处理这些数据。一句话总结一下就是：函数或方法被调用时，调用者是否得到最终结果的。
 直接得到最终结果的就是同步调用； 得到中间结果而非最终结果的，就是异步调用  2 阻塞与非阻塞 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。  一句话总结一下就是：函数或方法被调用时，是否立刻返回
 立即返回就是非阻塞调用 不立即返回就是阻塞调用  3 什么是IO linux系统中，所有的设备读写都可以看做文件的读写来操作，对文件的读写一般要经过内核态和用户态的切换，正因为有切换才导致了IO有同步和异步的说法。</description>
    </item>
    
    <item>
      <title>4-内置结构-元组-字符串</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/4-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%85%83%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/4-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%85%83%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>{% raw %}
文章目录 1 元组概念  1.1 元祖的特点 1.2 元组的定义 1.3 元组的访问 1.4 元组的查询   2 命名元组 3 字符串  3.1 字符串的基本操作  3.1.1 字符串的访问 3.1.2 字符串的拼接   3.2 字符串分割 3.3 字符串大小写 3.4 字符串排版 3.5 字符串修改 3.6 字符串查找 3.7 字符串判断 3.8 字符串格式化  3.8.1 C语言格式化 3.8.2 format格式化 3.8.3 对齐 3.8.9 小数点与进制     4 切片  4.1 切片赋值    1 元组概念  元组（类型为 tuple）和列表十分相似,但是元组和字符串一样是不可变的。</description>
    </item>
    
    <item>
      <title>40-数据库基础</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/40-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/40-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid>
      <description>{% raw %}
文章目录 1 数据库概述  1.1 关系数据库之ACID理论 1.2 关系数据库之概念  1.2.1 候选键 1.2.2 主键 1.2.3 外键 1.2.4 约束Constraint 1.2.5 索引   1.3 实体联系 1.4 视图   2 SQL  2.1 分类 2.2 规范   3 MySQL  3.1 安装MySQL 3.2 数据类型 3.4 用户及授权操作 3.5 库操作  3.5.1 创建数据库 3.5.2 删除数据库 3.5.3 其他操作   3.6 表操作  3.6.1 创建单表 3.6.2 创建多表外键关联 3.6.3 删除表 3.6.4 查看表结构 3.</description>
    </item>
    
    <item>
      <title>41-数据库-pymysql-DBUtils</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/41-%E6%95%B0%E6%8D%AE%E5%BA%93-pymysql-dbutils/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/41-%E6%95%B0%E6%8D%AE%E5%BA%93-pymysql-dbutils/</guid>
      <description>{% raw %}
文章目录 1 Python操作数据库 2 安装模块 3 基本使用  3.1 创建一个连接 3.2 连接数据库 3.3 游标  3.3.1 利用游标操作数据库 3.3.2 事务管理 3.3.3 执行SQL语句  3.3.3.1 批量执行 3.3.3.2 SQL注入攻击 3.3.3.3 参数化查询     3.4 获取查询结果  3.4.1 带列明的查询   3.5 上下文支持   4 DBUtils连接池  1 Python操作数据库  Python 提供了程序的DB-API，支持众多数据库的操作。由于目前使用最多的数据库为MySQL，所以我们这里以Python操作MySQL为例子，同时也因为有成熟的API,所以我们不必去关注使用什么数据，因为操作逻辑和方法是相同的。
2 安装模块  Python 程序想要操作数据库，首先需要安装 模块 来进行操作，Python 2 中流行的模块为 MySQLdb，而该模块在Python 3 中将被废弃，而使用PyMySQL，这里以PyMySQL模块为例。下面使用pip命令安装PyMSQL模块
pip3 install pymysql 如果没有pip3命令那么需要确认环境变量是否有添加，安装完毕后测试是否安装完毕。</description>
    </item>
    
    <item>
      <title>42-数据库-orm-SQLAlchemy</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/42-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-sqlalchemy/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/42-%E6%95%B0%E6%8D%AE%E5%BA%93-orm-sqlalchemy/</guid>
      <description>{% raw %}
文章目录 1 ORM 2 sqlalchemy 3 基本使用  3.1 创建连接  3.1.1 利用连接池执行sql   3.2 创建基类 3.3 创建实体类  3.3.1 常用字段   3.4 实例化 3.5 创建表 3.6 创建会话Session 3.7 数据操作  3.7.1 增加数据 3.7.2 简单查询 3.7.3 修改数据 3.7.4 删除数据(不建议) 3.7.5 状态 3.7.6 枚举字段 3.7.7 复杂查询  3.7.7.1 where条件查询 3.7.7.2 排序 3.7.7.3 分页(偏移量) 3.7.7.4 消费方法 3.7.7.5 分组及聚合方法 3.7.7.6 关联查询  隐式连接 join连接         4 一对多关系  4.</description>
    </item>
    
    <item>
      <title>43-celery异步任务队列</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/43-celery%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/43-celery%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97/</guid>
      <description>{% raw %}
1 Celery概述 关于celery的定义，首先来看官方网站： Celery(芹菜) 是一个简单、灵活且可靠的，处理大量消息的分布式系统，并且提供维护这样一个系统的必需工具。
 简单来看，是一个基于python开发的分布式异步消息任务队列，持使用任务队列的方式在分布的机器、进程、线程上执行任务调度。通过它可以轻松的实现任务的异步处理， 如果你的业务场景中需要用到异步任务，就可以考虑使用celery， 举几个实例场景中可用的例子:
 你想对100台机器执行一条批量命令，可能会花很长时间 ，但你不想让你的程序等着结果返回，而是给你返回 一个任务ID,你过一段时间只需要拿着这个任务id就可以拿到任务执行结果，在任务执行ing进行时，你可以继续做其它的事情。  你想做一个定时任务，比如每天检测一下你们所有客户的资料，如果发现今天 是客户的生日，就给他发个短信祝福 。　  Celery 在执行任务时需要通过一个中间人(消息中间件)来接收和发送任务消息，以及存储任务结果，完整的中间人列表请查阅官方网站
PS：任务队列是一种在线程或机器间分发任务的机制。 PS：消息队列的输入是工作的一个单元，称为任务，独立的工作（Worker）进程持续监视队列中是否有需要处理的新任务。
2 Celery简介  Celery 系统可包含多个职程和中间人，以此获得高可用性和横向扩展能力，其基本架构由三部分组成，消息中间件（message broker），任务执行单元（worker）和任务执行结果存储（task result store）组成。
 消息中间件，Celery本身不提供消息服务，但是可以方便的和第三方提供的消息中间件集成，一般使用rabbitMQ or Redis，当然其他的还有MySQL以及Mongodb。 任务执行单元，Worker是Celery提供的任务执行的单元，worker并发的运行在分布式的系统节点中。 任务结果存储，Task result store用来存储Worker执行的任务的结果，Celery支持以不同方式存储任务的结果，包括Redis，MongoDB，Django ORM，AMQP等。  Celery的主要特点：
 简单：一单熟悉了celery的工作流程后，配置和使用还是比较简单的 高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务 快速：一个单进程的celery每分钟可处理上百万个任务 灵活： 几乎celery的各个组件都可以被扩展及自定制  根据前面的介绍，我们可以得出如下流程图：
 用户应用程序将任务(已经在celery app中注册的)放入Broker中。 多个worker通过Broker获取任务并执行。 worker执行完成后，会把任务的结果、状态等信息返回到Broker中存储，供用户程序读取。  PS：Celery 用消息通信，通常使用中间人（Broker）在客户端和职程(worker)间斡旋。这个过程从客户端向队列添加消息开始，之后中间人把消息派送给职程(worker)。
3 Celery模块的基本使用 要使用Celery需要先安装celery模块，下面的例子使用Python3进行举例,使用redis作为消息中间人的角色。
3.1 利用pip3命令安装celery模块 pip3 install celery # 测试是否成功安装 [root@namenode ~]# python3 Python 3.</description>
    </item>
    
    <item>
      <title>44-zookeeper学习笔记</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/44-zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/44-zookeeper%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>{% raw %}
1 zookeeper  zookeeper分布式服务框架是apache hadoop的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调通知等。
2 应用场景  越来越多的分布式计算开始强依赖zookeeper 比如 storm（流计算），Hbase。zookeeper对分布式开发带来了许多便利，利用zookeeper的独有得特性巧妙的解决了很多难题，很多分布式技术用到了zookeeper或多或少的特性，尤其是新生代分布式技术都会依赖zookeeper特性，如Hbase，storm。
3 zookeeper的体系架构  server端集群架构（leader及follower）每个集群仅选出一个leader，其他zk节点均为follower，具有fast fail特性（leader失效，快速在剩下的follower中竞选leader），非常健壮，无单点，不超过半数Server挂掉不影响提供服务（所以建议zookeeper的节点个数为奇数个，比如zk节点为4个，那么挂两个节点，整个集群就会失效，而5个的话，挂3个才会失效），采用master/Slave模式 4 zookeeper的工作原理  zookeeper和核心是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做zab协议。zab协议有两种模式，分别使用的是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。
为保证事务的顺序一致性，zookeeper采用了递增的事务id号(zxid)来标识事务。所有的协议(请求)都在被提出的时候加上了zxid。zxid是一个64位的数字，它的高32位是epoch用来表示leader关系是否改变，每次一个leader被选举出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。简单来说：高32位就是标识当前系统的leader的，低32位就是当前环境下zxid的计数 每个Server在工作过程中有三种状态：
 LOOKING：当前Server不知道leader是谁，正在搜寻 LEADING：当前Server即为选举出来的leader FOLLOWING：leader已经选举出来，当前Server与之同步  4.1 选主流程  当leader崩溃或者服务刚刚启动时，这时zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的Server都恢复到一个正确的状态。zk的选举算法有两种：一种是基于basic paxos实现的，另外一种是基于fast paxos算法实现的。系统默认的选举算法为fast paxos。流程如下；  选举线程由当前Server发起选举的线程担任，其主要功能是对投票结果进行统计，并选出推荐的Server； 选举线程首先向所有Server节点发起一次询问（包括自己）； 选举线程收到回复后，验证是否是自己发起的讯问（验证zxid是否一致），然后获取对方的id（myid），并存储到当前询问对象列表中，最后堆取对方提出的leader相关信息（id，zxid）并将这些信息存储到当次选举的投票记录表中； 收到所有Server回复后，就计算出zxid最大的那个Server，并将这个Server相关信息设置成下一次要投票的Server； 线程将当前zxid最大的Server设置为当前Server要推荐的Leader，如果此时获胜的Server获得n/2+1的Server票数，就设置当前推荐的leader为获胜的Server，将根据获胜的Server相关信息设置自己的状态，否则，继续这个过程，直到leader被选举出来。 要使Leader获得多数Server的支持，则Server的总数必须是奇数（2n+1），且存活的Server数目不得少于n+1  每个Server启动都会重复以上流程。在恢复模式下，如果是刚存崩溃状态恢复的或者刚启动的Server还会从磁盘快照中恢复数据和会话消息，zk会记录事务日志并定期进行快照，方便在恢复时期进行状态恢复。选主流程图如下：
 原理简单来说，就是要选举leader，会生成一个zxid，然后分发给所有的server（所以这里一台server可以接受多台server给他发送要选举leader的请求），然后各个server根据发送给自己的zxid，选择一个值最大的，然后将这个选择返回给发送这个zxid的server，只要这个server收到的答复大于等于2/n+1个（也就是超过半数的同意票），则表明自己当选为leader，然后会向所有server广播自己已经成为leader。
 4.2 同步流程 选举完leader以后，zk就进入了状态同步过程。
 leader等待server链接 follower链接leader，将最大的zxid发送给leader leader根据follower的zxid确定同步点 完成同步后通知follower已经成为up to date状态 follower收到uptodate消息后，就可以接受client的请求进行服务了。  4.3 角色与工作流程    角色 功能     Leader 负责投票的发起和决议，更新系统状态。Leader数据是最新的、最权威的。   Follower 接受客户端读请求并返回结果，写请求转给Leader。参与选主投票   Observer 接受客户端读请求并返回结果，写请求发给Leader。不参与投票。扩展节点，减轻读压力   Client 读写请求的发起方    4.</description>
    </item>
    
    <item>
      <title>5-Python的封装与解构-集合</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/5-python%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E6%9E%84-%E9%9B%86%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/5-python%E7%9A%84%E5%B0%81%E8%A3%85%E4%B8%8E%E8%A7%A3%E6%9E%84-%E9%9B%86%E5%90%88/</guid>
      <description>{% raw %}
文章目录 1 封装与解构  1.1 封装 1.2 解构 1.3 Python3的解构   2 set类型  2.1 set的定义 2.2 set的基本操作  2.2.1 增加元素 2.2.2 删除元素 2.2.3 修改元素 2.2.4 成员判断   2.3 set小结   3 集合  3.1 集合运算 3.2 并集 3.3 交集 3.3 差集 3.4 对称差集 3.5 集合的其他运算     1 封装与解构  封装与解构属于Python语言的一种特性，它使用起来很像其他语言中的&amp;quot;逗号表达式&amp;quot;，但内部原理是不同的，在某些场景下：比如变量交换复制时使用，显得非常优雅。
1.1 封装  封装故名思议就是装箱，把多个值使用逗号分隔，组合在一起，本质上来看，其返回的是一个元组，只是省略了小括号。(一定要区别与C语言的逗号表达式)
In [91]: t1 = (1,2) # 定义一个元组  In [92]: t2 = 1,2 # 省略括号，其内部还是会封装成元组  In [93]: t1 Out[93]: (1, 2) In [94]: t2 Out[94]: (1, 2) In [95]: type(t1) Out[95]: tuple In [96]: type(t2) Out[96]: tuple 1.</description>
    </item>
    
    <item>
      <title>6-内置结构-字典</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/6-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/6-%E5%86%85%E7%BD%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</guid>
      <description>{% raw %}
文章目录 1 字典介绍 2 字典的基本操作  2.1 字典的定义 2.2 字典元素的访问 2.3 字典的增删改   3 字典遍历  3.1 遍历字典的key 3.2 遍历字典的value 3.3 变量字典的键值对 3.4 字典遍历小结   4 defaultdict默认值字典 5 OrdereDict有序字典  1 字典介绍  在Python中字典属于一种映射类型，它和set相同，同样属于非线性结构存储，Python官方对dict有如下解释
 一个映射对象映射一个可hash的值到任意一个对象上去。 映射是可变的对象。 dict是当前唯一一个标准的映射类型。 字典的键几乎可以任意的值。 字典的值可以不必可hash，也就是说值可以是列表，字典，或者其他任意可变的对象 如果key相同，那么后面的value将会覆盖先前的value 不建议使用float类型作为字典的key  简单来说：字典是由key:value键值对组成的数据的集合，它的主要特点是 可变的、无序的、不重复的。
 字典的key必须是可hash对象，之所以快，因为其本质上使用空间换了时间。
 2 字典的基本操作  字典是除set集合以外另一种可变的非线性容器模型，在Python中非常强大，适合各种结构数据的存储、嵌套等。
2.1 字典的定义  字典的每个key到value的键值对用冒号(:)分割，每对之间用逗号(,)分割，整个字典包括在花括号({})中。例：{&#39;a&#39;:1, &#39;b&#39;:2}，Python提供了多种创建字典的方式，如下：
 基本格式：d = dict() 或者 d = {} dict(**kwargs): 使用name=value对，来初始化一个字典 dict(iterable, **kwargs)：使用可迭代对象和name=value构造字典，注意可迭代对象必须是一个二元结构 dict(mapping, **kwargs): 使用一个字典构造另一个字典 dic = {&#39;a&#39;:1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:[1,2,3]} dic = dict.</description>
    </item>
    
    <item>
      <title>7-列表解析式-生成器</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/7-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/7-%E5%88%97%E8%A1%A8%E8%A7%A3%E6%9E%90%E5%BC%8F-%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description>{% raw %}
文章目录 1 解析式 2 列表解析式  2.1 列表解析式进阶   3 其他解析式  3.1 集合表达式 3.2 字典解析式   4 生成器表达式  4.1 特点 4.2 next函数   5 总结  1 解析式  从一个问题来看解析式，现有如下需求：生成一个列表，元素0-9，对每一个元素自增1后求平方返回新列表。
lst = list(range(10)) lst2 = [] for value in lst: lst2.append((value + 1) ** 2) print(lst2)  看起来很容易理解，但是这种需求竟然用了5行代码！下面来看一下列表解析式的写法。
[ (x+1)**2 for x in range(10)]  看起来非常简洁，属于Python的风格！哈哈
  再来看一下，什么是列表解析式？在Python中列表解析式是一种语法糖，虽然对看似复杂的代码进行了简写，但是编译器会进行优化，不会因为简写而影响效率，反而因为优化提高了效率。另外还介绍了代码量，减少了出错的机会，还简化了代码，增加了代码可读性。
2 列表解析式  列表解析式的基本语法是如下</description>
    </item>
    
    <item>
      <title>9-函数定义-位置参数-返回值</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/9-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/9-%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0-%E8%BF%94%E5%9B%9E%E5%80%BC/</guid>
      <description>{% raw %}
文章目录 1 函数介绍  1.1 为什么要使用函数 1.2 Python中的函数   2 函数的基本使用 3 函数的参数  3.1 参数的默认值 3.2 可变参数  3.2.1 可变位置传参 3.2.2 可变关键字传参 3.2.3 可变参数混合使用 3.2.4 可变参数小结   3.3 keyword-only参数* 3.4 参数解构   4 函数的返回值  1 函数介绍  函数在编程语言中就是完成特定功能的一个词句组(代码块)，这组语句可以作为一个单位使用，并且给它取一个名字。可以通过函数名在程序的不同地方多次执行（这叫函数的调用）。函数在编程语言中有基本分为：预定义函数，自定义函数。预定义函数可以直接使用，而自定义函数顾名思义需要我们自己定义函数。
 在数学中的定义，这里就不介绍了。因为没卵用。哈哈
 1.1 为什么要使用函数 在编程中使用函数主要有两个优点：
 降低编程难度：通常将一个复杂的大问题分解成一系列的小问题，然后将小问题划分成更小的问题，当问题细化为足够简单时，我们就可以分而治之，各个小问题解决了，大问题就迎刃而解了。 代码重用：避免重复劳作，提供效率 代码更加简洁美观，可读性增加  1.2 Python中的函数  在Python中，函数由若干语句组成代码块、函数名称、参数列表构成，它是组织代码的最小单元,使用函数可以完成一定的功能，在Python中函数主要分为三类：内置函数、第三方函数库、自定义函数。常用的内置函数在前面已经介绍，第三方函数库需要先引入模块，通过模块调用，在模块学习中进行介绍，这里主要说的是如何自定义一个函数。
2 函数的基本使用  在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。下面是一个函数的基本结构
def 函数名(参数列表): 函数体(代码块) [return 返回值] # 函数可以无返回值 注意：</description>
    </item>
    
    <item>
      <title>面向对象基础</title>
      <link>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</guid>
      <description>{% raw %}
 1 随机整数生成类  1.1 工具类思路 1.2 生成器思路   2 打印坐标 3 车辆信息 4 实现温度的处理 5 模拟购物车 6 面积计算  1 随机整数生成类 描述：创建一个随机整数生成类，可以指定一批生成的个数，可以指定数值的范围，可以调整每批生成数字的个数。
 先从搭架子开始，根据题目需求,首先确认至少存在1个类，它有一个功能，可以生成一批数字  class RandomGen: def __init__(self): pass def generate(self): pass 出厂配置，由于实例可以指定范围，可以指定生成的个数，那么最少要有三个属性进行标识  class RandomGen: def __init__(self,start=1, stop=100, count=10): self.start = start self.stop = stop self.count = count def generate(self): pass 生成一批数据，这里通过调用random模块来生成随机数据  import random class RandomGen: def __init__(self,start=1, stop=100, count=10): self.start = start self.</description>
    </item>
    
  </channel>
</rss>
