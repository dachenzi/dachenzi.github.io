<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python练习s on dahl&#39;s blog</title>
    <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/</link>
    <description>Recent content in Python练习s on dahl&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>dahlhin.li@gmail.com (daxin.li)</managingEditor>
    <webMaster>dahlhin.li@gmail.com (daxin.li)</webMaster>
    <copyright>(c) 2015 Lee xin.</copyright><atom:link href="https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>九九乘法表</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E4%B9%9D%E4%B9%9D%E4%B9%98%E6%B3%95%E8%A1%A8/</guid>
      <description>{% raw %}
文章目录 打印九九乘法表 1 降低问题复杂度 2 获取对角线下半部部分 3 调整循环次数 4 调整间距 5 使用三元云算符惊喜调整间隔 6 利用format优化显示 7 利用print进行优化 8 三行搞定终极版 9 就这么完了吗？   打印九九乘法表 现在有需求，请使用 Python 尽可能少的代码，打印如下九九乘法表
1*1=1 2*1=2 2*2=4 3*1=3 3*2=6 3*3=9 4*1=4 4*2=8 4*3=12 4*4=16 5*1=5 5*2=10 5*3=15 5*4=20 5*5=25 6*1=6 6*2=12 6*3=18 6*4=24 6*5=30 6*6=36 7*1=7 7*2=14 7*3=21 7*4=28 7*5=35 7*6=42 7*7=49 8*1=8 8*2=16 8*3=24 8*4=32 8*5=40 8*6=48 8*7=56 8*8=64 9*1=9 9*2=18 9*3=27 9*4=36 9*5=45 9*6=54 9*7=63 9*8=72 9*9=81 1 降低问题复杂度 首先我可以先打一个九乘九的矩阵，假设当前我们只了解字符串拼接</description>
    </item>
    
    <item>
      <title>双向链表</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</guid>
      <description>{% raw %}
用面向对象实现LinkedList链表 (1)单向链表实现append，iternodes方法
(2)双向链表实现append、pop、insert、remove、iternodes方法
(1) 分析需求  链表存放数据，那么链表肯定需要一个类，那么数据呢？链表的特质，访问一个对象才能知道下一个对象在哪，那么如果每个元素是一个对象就很方便了 单向链表的话，针对元素对象来说只需要前一个元素记住后一个元素就可以了，所以需要一个next属性来记录 因为迭代是要从起始位开始的，所以我们的链表对象需要一个变量来记录起始位置，那是否要结尾呢？仔细想一下，append的方法就是在链表的结尾处追加一个元素，所以记录结尾元素可以方便追加操作。  下面我们来实现一下单向链表
class LinkNode: def __init__(self, value, next=None): self.item = value self.next = next def __str__(self): # 打印时的输出 return &amp;#39;{} ==&amp;gt; {}&amp;#39;.format(self.item, self.next.item if self.next else None) class LinkedList: def __init__(self, head=None, tail=None): self.head = head # 链表首位 self.tail = tail # 链表末位 # 追加方法 def append(self, value): # 实例化一个LinkNode 对象 node = LinkNode(value) if self.head is None: # 当链表首位为None,表示当前列表为空 self.</description>
    </item>
    
    <item>
      <title>双向链表之容器包装</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%8C%85%E8%A3%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E4%B9%8B%E5%AE%B9%E5%99%A8%E5%8C%85%E8%A3%85/</guid>
      <description>{% raw %}
容器包装  构建双向链表，实现append，pop，insert，remove，iternodes方法 将双向链表链表封装为容器，并且提供__getitem__、__iter__、__setitem__方法  class LinkNode: def __init__(self, value, prev=None, after=None): self.value = value self.prev = prev self.after = after class LinkedList: def __init__(self): self.head = None self.tail = None self.length = 0 def append(self, value): node = LinkNode(value) if self.head == None: self.head = node else: prev = self.tail prev.after = node node.prev = prev self.tail = node self.length += 1 def pop(self): item = self.</description>
    </item>
    
    <item>
      <title>基础练习题</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%9F%BA%E7%A1%80/</guid>
      <description>{% raw %}
文章目录 1、给一个半径，求圆的面积和周长。圆周率3.14 2 输入两个数，比较大小后，从小到大升序打印 3 依次输入若干个整数，打印出最大值，如果输入为空，则退出程序 4 输入n个数，求每次输入后的算数平均数 5 打印一个边长为n的正方形 6 求100内所有奇数的和(2500) 7 判断学生成绩，成绩等级A-E,其中90分以上为A,80-89分为B，70-79分为C,60-69分为D，60分以下为E 8 求1到5阶乘之和  1、给一个半径，求圆的面积和周长。圆周率3.14 # 简单版本 radius = float(input(&amp;#39;&amp;gt;&amp;gt;: &amp;#39;).strip()) print(&amp;#39;area: {:.2f},circumference: {:.2f}&amp;#39;.format(3.14*radius**2, 2*3.14*radius)) # 复杂版本 import math while True: radius = input(&amp;#39;半径&amp;gt;&amp;gt;&amp;gt;: &amp;#39;).strip() if radius.isdecimal(): radius = float(radius) area = math.pi * radius ** 2 circumference = 2 * math.pi * radius print(&amp;#39;面积: {:.2f}, 周长：{:.2f}&amp;#39;.format(area, circumference)) elif radius.lower() == &amp;#39;q&amp;#39;: print(&amp;#39;\033[31m bye \033[0m&amp;#39;) break else: print(&amp;#39;input Error ,retry&amp;#39;) 2 输入两个数，比较大小后，从小到大升序打印 # 简单版 number1 = int(input(&amp;#39;&amp;gt;&amp;gt;&amp;gt;: &amp;#39;)) number2 = int(input(&amp;#39;&amp;gt;&amp;gt;&amp;gt;: &amp;#39;)) if number1 &amp;lt; number2: print(number1, number2) else: print(number2, number1) # 负载版 lst = [] for i in range(2): lst.</description>
    </item>
    
    <item>
      <title>字典练习题</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%AD%97%E5%85%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E5%AD%97%E5%85%B8/</guid>
      <description>{% raw %}
文章目录 1 用户输入一个数字 2 数字重复统计 3 字符串重复统计  1 用户输入一个数字  打印每一位数字及其重复的次数  1.当key不存在时利用0进行初始化(初级) num = input(&amp;#39;&amp;gt;&amp;gt;&amp;gt;: &amp;#39;).strip().lstrip(&amp;#39;0&amp;#39;) dic = {} for i in num: if i not in dic: dic[i] = 0 dic[i] += 1 print(dic) 2. 利用字典的get方法，不存在时返回0，然后统计 num = input(&amp;#39;&amp;gt;&amp;gt;&amp;gt;: &amp;#39;).strip().lstrip(&amp;#39;0&amp;#39;) dic = {} for i in num: dic[i] = dic.get(i, 0) + 1 print(dic) 3. 利用默认值字典直接进行统计 from collections import defaultdict num = input(&amp;#39;&amp;gt;&amp;gt;&amp;gt;: &amp;#39;).strip().lstrip(&amp;#39;0&amp;#39;) dic = defaultdict(int) for i in num: dic[i]+= 1 print(dic) 2 数字重复统计  随机产生100个整数 数字的范围[-1000, 1000] 升序输出这些数字并打印其重复的次数  import random lst = [random.</description>
    </item>
    
    <item>
      <title>打印菱形</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E6%89%93%E5%8D%B0%E8%8F%B1%E5%BD%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E6%89%93%E5%8D%B0%E8%8F%B1%E5%BD%A2/</guid>
      <description>{% raw %}
文章目录 打印菱形 1 分析 2 对称性 3 abs及三元表达式调整 4 完了吗？  打印菱形 现在有需求，请使用 Python 尽可能少的代码，打印如下菱形
* *** ***** ******* ***** *** * 1 分析 一般让我们打印图形的题目都有窍门，或者说规律可循，刚开始不了解，可以把图形分解，查找其中的关系
# 行 前空格 星星 后空格 # 1 3 1 3 # 2 2 3 2 # 3 1 5 1 # 4 0 7 0 # 5 1 5 1 # 6 2 3 2 # 7 3 1 3 通过对菱形的分析，我们有如上数据，仔细观察可以发现，他们是基于第四行对称的，从图形上分析，在星星后面的空格可以不用管它，得到这个结果以后，我们发现可以构造1列数据，进行循环控制
# 行 前空格 星星 后空格 循环控制 # 1 3 1 3 -3 # 2 2 3 2 -2 # 3 1 5 1 -1 # 4 0 7 0 0 # 5 1 5 1 1 # 6 2 3 2 2 # 7 3 1 3 3 2 对称性 for i in range(-3,4): prespace = -i if i &amp;lt; 0 else i line = &amp;#39; &amp;#39; * prespace + &amp;#39;*&amp;#39; * (7 - 2 * prespace ) print(line) # 结果 * *** ***** ******* ***** *** * 代码看起来不是那么美观，合并代码，及使用abs处理负数情况</description>
    </item>
    
    <item>
      <title>斐波那契序列系列</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/</guid>
      <description>{% raw %}
1 打印100以内的斐波那契序列 a, b = 0, 1 print(b) while True: c = a + b if c &amp;gt; 100: break print(c) a, b = b, c 2 求斐波那契数列第101项 a, b = 0, 1 count = 1 while True: c = a + b if count == 100: print(c) a, b = b, c count += 1 {% endraw %}</description>
    </item>
    
    <item>
      <title>素数系列</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E7%B4%A0%E6%95%B0%E7%B3%BB%E5%88%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/%E7%B4%A0%E6%95%B0%E7%B3%BB%E5%88%97/</guid>
      <description>{% raw %}
1 给一个数、判断它是否是素数(质数) (质数：一个大于1的自然数只能被1和它本身整除)
(1) 传统方法 n = 12577 flag = False # 假定不是素数，一旦整除就是素数 for i in range(2, n - 1): # 偶数一定不是素数，这里排除 if n % i == 0: # 整除了就不是素数 flag = True break if flag: print(n, &amp;#39;Is not a prime number&amp;#39;) else: print(n, &amp;#39;Is a prime number&amp;#39;) (2) n = 12777 for i in range(3, int(n**0.5)+1, 2): # 奇数是无法被偶数整除的，所以跳过偶数，当计算到开方处时(int会取整，所以为了边界问题，+1)，还没办法整除表示它是一个素数 if n % i == 0: print(&amp;#39;Is not a prime number&amp;#39;) break else: print(&amp;#39;Is a prime number&amp;#39;) 2 求10万以内所有素数 (1) 方法1 n = 100000 lst = [] count = 1 for i in range(3, n, 2): # 排除偶数 for j in range(3, int(n**0.</description>
    </item>
    
    <item>
      <title>阶段复习-1</title>
      <link>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E7%BB%83%E4%B9%A0/python%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0/</guid>
      <description>{% raw %}
 1 求和 2 选取文件 3 转置矩阵 4 生成随机的20个ID 5 去除重复数字 6 排序 7 第6题实现选择排序 8 判断密码强弱 9 日志统计 10 打印矩阵外圈  1 求和 对下面集合中随机取数字，要求取出的数字是3的倍数但不能是4的倍数，成功取到10个数字并对取到的所有数字求和输出 {5,10,3,8,6,10,9,15,24,30,27,48,24}
import random numbers = {5,10,3,8,6,10,9,15,24,30,27,48,24} numbers = list(numbers) lst = [] while len(lst) != 10: nums = random.choice(numbers) if (nums % 3 == 0) and (nums % 4 != 0): lst.append(nums) print(sum(lst)) 2 选取文件 现有如下文件：
ftp://ftp.astron.com/pub/file/file-5.14.tar.gz ftp://ftp.gmplib.org/pub/gmp-5.1.2/gmp-5.1.2.tar.xz ftp://ftp.vim.org/pub/vim/unix/vim-7.3.tar.bz2 http://anduin.linuxfromscratch.org/sources/LFS/lfs-packages/conglomeration//iana-etc/iana-etc-2.30.tar.bz2 http://anduin.linuxfromscratch.org/sources/other/udev-lfs-205-1.tar.bz2 http://download.savannah.gnu.org/releases/libpipeline/libpipeline-1.2.4.tar.gz http://download.</description>
    </item>
    
  </channel>
</rss>
