<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]> <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]> <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>4-logging模块  &middot; dahl&#39;s blog</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1">


<meta name="description" content="" />

<meta name="keywords" content="">


<meta property="og:title" content="4-logging模块  &middot; dahl&#39;s blog ">
<meta property="og:site_name" content="dahl&#39;s blog"/>
<meta property="og:url" content="https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/4-logging%E6%A8%A1%E5%9D%97/" />
<meta property="og:locale" content="en-EN">


<meta property="og:type" content="article" />
<meta property="og:description" content=""/>
<meta property="og:article:published_time" content="0001-01-01T00:00:00Z" />
<meta property="og:article:modified_time" content="0001-01-01T00:00:00Z" />

  
    
  

  

<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "Article",
    "headline": "4-logging模块",
    "author": {
      "@type": "Person",
      "name": "daxin.li"
    },
    "datePublished": "0001-01-01",
    "description": "",
    "wordCount":  1192 
  }
</script>



<link rel="canonical" href="https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/4-logging%E6%A8%A1%E5%9D%97/" />

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="https://dachenzi.github.io/touch-icon-144-precomposed.png">
<link href="https://dachenzi.github.io/favicon.png" rel="icon">

<meta name="generator" content="Hugo 0.75.1" />

  <!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
<![endif]-->

<link href='https://fonts.googleapis.com/css?family=Merriweather:300%7CRaleway%7COpen+Sans' rel='stylesheet' type='text/css'>
<link rel="stylesheet" href="/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/highlight/default.css">

  
  
	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	  ga('create', 'Your Google Analytics tracking code', 'auto');
	  ga('send', 'pageview');

	</script>

</head>
<body>
  <main id="main-wrapper" class="container main_wrapper has-sidebar">
    <header id="main-header" class="container main_header">
  <div class="container brand">
  <div class="container title h1-like">
  <a class="baselink" href="https://dachenzi.github.io">
  foobar

</a>

</div>

  
<div class="container topline">
  
  few words about your site


</div>


</div>

  <nav class="container nav primary no-print">
  

<a class="homelink" href="https://dachenzi.github.io">home</a>


  
<a href="https://dachenzi.github.io/about">About</a>

<a href="https://dachenzi.github.io/post" title="Show list of posts">Posts</a>

<a href="https://dachenzi.github.io/tags" title="Show list of tags">Tags</a>


</nav>

<div class="container nav secondary no-print">
  
<a id="contact-link-email" class="contact_link" rel="me" aria-label="Email" href="mailto:dahlhin.li@gmail.com">
  <span class="fa fa-envelope-square"></span></a>



<a id="contact-link-github" class="contact_link" rel="me" aria-label="Github" href="https://github.com/enten/hugo-boilerplate">
  <span class="fa fa-github-square"></span></a>




 


















</div>


  

</header>


<article id="main-content" class="container main_content single">
  <header class="container hat">
  <h1>4-logging模块
</h1>

</header>

  <div class="container content">
  <p>{% raw %}</p>
<p><!-- raw HTML omitted --><strong>文章目录</strong><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<ul>
<li><a href="#1-logging%E6%A8%A1%E5%9D%97">1 logging模块</a>
<ul>
<li><a href="#11-%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB">1.1 日志级别</a></li>
<li><a href="#12-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F%E5%AD%97%E7%AC%A6%E4%B8%B2">1.2 日志格式字符串</a></li>
<li><a href="#13-%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8">1.3 快速使用</a>
<ul>
<li><a href="#131-%E4%BF%AE%E6%94%B9%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F">1.3.1 修改日期格式</a></li>
<li><a href="#132-%E8%BE%93%E5%87%BA%E5%88%B0%E6%96%87%E4%BB%B6%E4%B8%AD">1.3.2 输出到文件中</a></li>
<li><a href="#133-%E6%9E%84%E5%BB%BA%E6%B6%88%E6%81%AF">1.3.3 构建消息</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B">2 处理流程</a></li>
<li><a href="#3-logger%E7%B1%BB">3 logger类</a>
<ul>
<li><a href="#31-getlogger%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95">3.1 getLogger工厂方法</a></li>
<li><a href="#32-%E5%AE%9E%E4%BE%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">3.2 实例常用方法</a></li>
<li><a href="#33-%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">3.3 层次结构</a></li>
<li><a href="#34-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFroot-logger">3.4 为什么是root logger</a></li>
<li><a href="#35-root-logger%E6%98%AF%E5%95%A5">3.5 root logger是啥？</a>
<ul>
<li><a href="#351-basicconfig%E5%B8%B8%E7%94%A8%E5%8F%82%E6%95%B0">3.5.1 basicConfig常用参数</a></li>
</ul>
</li>
<li><a href="#36-%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">3.6 继承关系</a></li>
</ul>
</li>
<li><a href="#4-handler%E7%B1%BB">4 handler类</a>
<ul>
<li><a href="#41-streamhandler">4.1 StreamHandler</a></li>
<li><a href="#42-filehandler">4.2 FileHandler</a></li>
<li><a href="#43-%E5%A4%9A%E4%B8%AAhandler">4.3 多个Handler</a></li>
<li><a href="#44-handler%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95">4.4 handler的常用方法</a></li>
</ul>
</li>
<li><a href="#5-formatter%E7%B1%BB">5 Formatter类</a></li>
<li><a href="#6-filter%E7%B1%BB">6 Filter类</a></li>
<li><a href="#7-%E4%BF%A1%E6%81%AF%E4%BC%A0%E9%80%92">7 信息传递</a></li>
<li><a href="#8-%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90">8 过程分析</a></li>
<li><a href="#9-%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2">9 日志切割</a>
<ul>
<li><a href="#91-%E6%8C%89%E7%85%A7%E5%A4%A7%E5%B0%8F%E5%88%87%E5%89%B2%E6%97%A5%E5%BF%97">9.1 按照大小切割日志</a></li>
<li><a href="#92-%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E5%88%87%E5%89%B2%E6%97%A5%E5%BF%97">9.2 按照时间切割日志</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h1 id="1-logging模块">1 logging模块</h1>
<p>这个模块定义了一些函数和类，它们为应用程序和库实现了一个灵活的事件日志系统。下面先来了解下日志的级别分类。</p>
<h2 id="11-日志级别">1.1 日志级别</h2>
<p>下面是日志级别以及对应的数字值表：</p>
<table>
<thead>
<tr>
<th>Level</th>
<th>Numeric value</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRITICAL</td>
<td>50</td>
</tr>
<tr>
<td>ERROR</td>
<td>40</td>
</tr>
<tr>
<td>WARNING</td>
<td>30</td>
</tr>
<tr>
<td>INFO</td>
<td>20</td>
</tr>
<tr>
<td>DEBUG</td>
<td>10</td>
</tr>
<tr>
<td>NOTSET</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>之所以设置级别是为了控制输出信息，以及针对日志进行了分类：</p>
<ul>
<li>Error一般为程序的错误信息</li>
<li>Warning为程序的告警信息</li>
<li>info和debug则可以是提示或者调试信息</li>
</ul>
<p>当我们需要对我们的程序运行时输出的日志进行分类打印时，可以使用这种简便而快速的方法。</p>
<blockquote>
<p>基本上所以的软件程序日志输出都分为上述级别。</p>
</blockquote>
<h2 id="12-日志格式字符串">1.2 日志格式字符串</h2>
<p>logging模块中定义好的可以用于format格式字符串常用的如下：</p>
<table>
<thead>
<tr>
<th>字段/属性名称</th>
<th>使用格式</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>asctime</td>
<td>%(asctime)s</td>
<td>日志事件发生的时间&ndash;人类可读时间，如：2003-07-08 16:49:45,896</td>
</tr>
<tr>
<td>created</td>
<td>%(created)f</td>
<td>日志事件发生的时间&ndash;时间戳，就是当时调用datetime.datetime.now()函数返回的值</td>
</tr>
<tr>
<td>relativeCreated</td>
<td>%(relativeCreated)d</td>
<td>日志事件发生的时间相对于logging模块加载时间的相对毫秒数（目前还不知道干嘛用的）</td>
</tr>
<tr>
<td>msecs</td>
<td>%(msecs)d</td>
<td>日志事件发生事件的毫秒部分</td>
</tr>
<tr>
<td>levelname</td>
<td>%(levelname)s</td>
<td>该日志记录的文字形式的日志级别（&lsquo;DEBUG&rsquo;, &lsquo;INFO&rsquo;, &lsquo;WARNING&rsquo;, &lsquo;ERROR&rsquo;, &lsquo;CRITICAL&rsquo;）</td>
</tr>
<tr>
<td>levelno</td>
<td>%(levelno)s</td>
<td>该日志记录的数字形式的日志级别（10, 20, 30, 40, 50）</td>
</tr>
<tr>
<td>name</td>
<td>%(name)s</td>
<td>所使用的日志器名称，默认是&rsquo;root'，因为默认使用的是 rootLogger</td>
</tr>
<tr>
<td>message</td>
<td>%(message)s</td>
<td>日志记录的文本内容，通过 msg % args计算得到的</td>
</tr>
<tr>
<td>pathname</td>
<td>%(pathname)s</td>
<td>调用日志记录函数的源码文件的全路径</td>
</tr>
<tr>
<td>filename</td>
<td>%(filename)s</td>
<td>pathname的文件名部分，包含文件后缀</td>
</tr>
<tr>
<td>module</td>
<td>%(module)s</td>
<td>filename的名称部分，不包含后缀</td>
</tr>
<tr>
<td>lineno</td>
<td>%(lineno)d</td>
<td>调用日志记录函数的源代码所在的行号</td>
</tr>
<tr>
<td>funcName</td>
<td>%(funcName)s</td>
<td>调用日志记录函数的函数名</td>
</tr>
<tr>
<td>process</td>
<td>%(process)d</td>
<td>进程ID</td>
</tr>
<tr>
<td>processName</td>
<td>%(processName)s</td>
<td>进程名称，Python 3.1新增</td>
</tr>
<tr>
<td>thread</td>
<td>%(thread)d</td>
<td>线程ID</td>
</tr>
<tr>
<td>threadName</td>
<td>%(thread)s</td>
<td>线程名称</td>
</tr>
</tbody>
</table>
<h2 id="13-快速使用">1.3 快速使用</h2>
<p>了解了级别和格式，我们就可以按照如下方式定义日志然后输出了。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> loggerName:</span><span style="color:#e6db74">%(name)s</span><span style="color:#e6db74"> logLevel:</span><span style="color:#e6db74">%(levelname)s</span><span style="color:#e6db74"> logNum:</span><span style="color:#e6db74">%(levelno)s</span><span style="color:#e6db74"> Line:</span><span style="color:#e6db74">%(lineno)s</span><span style="color:#e6db74"> message:</span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#34;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT)

logging<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;hello world&#34;</span>)
<span style="color:#75715e"># 2019-03-05 21:42:01,952 loggerName:root logLevel:INFO logNum:20 Line:6 message:hello world</span>
</code></pre></div><p>注意：</p>
<ul>
<li>basicConfig中的level表示日志的级别，也可以直接使用等价数字即可。这里INFO对应的是20，填写数字20，也可以。（使用字符串时，必须为大写)</li>
<li>format表示按照上面定义的格式来输出日志信息。</li>
<li>指定了level=logging.INFO，那么下面输入日志时就要大于等于logging.info(调用方法时为小写)</li>
</ul>
<blockquote>
<p>日志格式，这里使用了空格进行分段，便于收集处理，当然分割符是自己指定的，但最好不要用00分割，会产生意想不到的问题</p>
</blockquote>
<h3 id="131-修改日期格式">1.3.1 修改日期格式</h3>
<p>basicConfig提供了一个参数datefmt用来便捷的修改日志为指定格式</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(name)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(levelname)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(levelno)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(lineno)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#34;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT, datefmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%Y-%m&#39;</span>)

logging<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#34;hello world&#34;</span>)
<span style="color:#75715e"># 2019-03 root ERROR 40 6 hello world</span>
</code></pre></div><p>格式采用c风格的标准的时间占位符，比如:<code>&quot;%Y/%m/%d %H:%M:%S&quot;</code>。</p>
<h3 id="132-输出到文件中">1.3.2 输出到文件中</h3>
<p>basicConfig的filename参数用于指定输出的文件名称以及文件的位置。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(name)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(levelname)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(levelno)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(lineno)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#34;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT, datefmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%Y-%m&#39;</span>, filename<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;log.txt&#39;</span>)

logging<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#34;hello world&#34;</span>)
</code></pre></div><h3 id="133-构建消息">1.3.3 构建消息</h3>
<p>如果需要自定义format中关键字占位符，动态的传递消息，可以使用extra来传递</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(helloworld)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#34;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT, datefmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%Y/%m/</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> %H:%M:%S&#39;</span>)

logging<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#34;hello world&#34;</span>, extra<span style="color:#f92672">=</span>{<span style="color:#e6db74">&#39;helloworld&#39;</span>:<span style="color:#e6db74">&#39;daxin&#39;</span>})
<span style="color:#75715e"># 2019/03/05 22:04:03 daxin hello world</span>
</code></pre></div><p>在调用时通过extra传递字典来为自定义关键字传值。(很少用)</p>
<h1 id="2-处理流程">2 处理流程</h1>
<p>logging模块要输出一个日志要经过以下工序：
<img src="../%E7%AC%94%E8%AE%B0/photo/loggingflow.png" alt="loggingflow"><br>
看起来相对比较复杂，那么先从四大组件开始了解</p>
<h1 id="3-logger类">3 logger类</h1>
<p>        logger类被称为日志记录器，但从来不直接实例化，总是通过<code>logging.getLogger(name)</code>来实例化。对于具有相同名称的getLogger()的多次调用总是返回对同一个Logger对象的引用。它的主要功能有：</p>
<ol>
<li>基于日志严重等级（默认的过滤设施）或filter对象(过滤器)来决定要对哪些日志进行后续处理；</li>
<li>将日志消息传送给所有绑定的日志handlers。</li>
</ol>
<blockquote>
<p>消息的级别会通过getEffectiveLevel()转换为数字和logger设置的级别想比较，只有大于等于，才会被logger转发至所有绑定的handler</p>
</blockquote>
<h2 id="31-getlogger工厂方法">3.1 getLogger工厂方法</h2>
<p>        logging模块建议使用getlogger方法，来构建一个新的logger实例，并且当传入的name相同时，多次执行返回的是相同的logger，为什么这样做呢？因为logger本身是跨线程的，并且是线程安全的，我们没必要为每一个线程创建一个用于输出日志的logger，而且这样很浪费内存空间。</p>
<blockquote>
<p>习惯上称getLogger为工厂方法</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)        <span style="color:#75715e"># logger的名称必须为str</span>
<span style="color:#66d9ef">print</span>(mylogger)  <span style="color:#75715e"># &lt;Logger daxin (WARNING)&gt;  </span>
</code></pre></div><p>这样就构建了一个logger，级别为warning，那为什么是warning呢，和logger的父系结构有关。</p>
<h2 id="32-实例常用方法">3.2 实例常用方法</h2>
<p>logger类包含如下常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>setLevel(level)</td>
<td>设置logger的日志级别，可以设置为数字或者logging对应的级别</td>
</tr>
<tr>
<td>getEffectiveLevel()</td>
<td>获取对应的数字级别显示</td>
</tr>
<tr>
<td>addHandler(hdlr)</td>
<td>为logger添加一个Handler，可以添加多个</td>
</tr>
<tr>
<td>removeHandler(hdlr)</td>
<td>为logger删除一个Handler</td>
</tr>
<tr>
<td>addFilter(filter)</td>
<td>为logger添加一个Filter，可以添加多个</td>
</tr>
<tr>
<td>removeFilter(filter)</td>
<td>为logger删除一个Filter</td>
</tr>
<tr>
<td>getChild(suffix)</td>
<td>为logger创建一个子logger</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>以及对应分类的触发日志的方法:</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>debug(msg, *args, **kwargs)</td>
<td>标识消息为 <code>debug/10</code> 级别</td>
</tr>
<tr>
<td>info(msg, *args, **kwargs)</td>
<td>标识消息为 <code>info/20</code> 级别</td>
</tr>
<tr>
<td>warning(msg, *args, **kwargs)</td>
<td>标识消息为 <code>warning/30</code> 级别</td>
</tr>
<tr>
<td>error(msg, *args, **kwargs)</td>
<td>标识消息为 <code>error/40</code> 级别</td>
</tr>
<tr>
<td>critical(msg, *args, **kwargs)</td>
<td>标识消息为 <code>critical/50</code> 级别</td>
</tr>
</tbody>
</table>
<p>logger对象具有的属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>handlers</td>
<td>所有绑定的handler列表</td>
</tr>
<tr>
<td>level</td>
<td>当前logger的级别</td>
</tr>
<tr>
<td>name</td>
<td>当前logger的名称</td>
</tr>
<tr>
<td>parent</td>
<td>当前logger的父logger，根节点为root</td>
</tr>
<tr>
<td>filters</td>
<td>所有绑定的filter列表</td>
</tr>
<tr>
<td>propagate</td>
<td>是否进行消息传递(默认为True，表示传递) &ndash; 后面会说</td>
</tr>
</tbody>
</table>
<p>举个栗子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(name)s</span><span style="color:#e6db74"> [</span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">]&#39;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT)

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
mylogger<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;from mylogger level is info&#34;</span>)  <span style="color:#75715e"># 2019-03-06 11:10:47,000 daxin [from mylogger level is info]</span>
<span style="color:#66d9ef">print</span>(mylogger<span style="color:#f92672">.</span>getEffectiveLevel())  <span style="color:#75715e"># 20(和继承关系有关)</span>

<span style="color:#75715e"># 设置logger的级别</span>
mylogger<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>CRITICAL)
mylogger<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;from mylogger level is Critical&#34;</span>)  <span style="color:#75715e"># 没办法输出，因为logger的级别是50，而我们输入的是级别为10的日志。</span>
<span style="color:#66d9ef">print</span>(mylogger<span style="color:#f92672">.</span>getEffectiveLevel())  <span style="color:#75715e"># 50</span>
</code></pre></div><h2 id="33-层次结构">3.3 层次结构</h2>
<p>logger是层次结构的，使用.号分割，如&rsquo;a',&lsquo;a.b&rsquo;或&rsquo;a.b.c&rsquo;。</p>
<ul>
<li>a.b: a是b的parent，b是a的child</li>
<li>对于a来说，a.main和a.main.one，都是a的后代。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(name)s</span><span style="color:#e6db74"> [</span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">]&#39;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT)

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
mylogger<span style="color:#f92672">.</span>setLevel(<span style="color:#ae81ff">40</span>)

<span style="color:#75715e"># 构建一个子的logger</span>
newlogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin.new&#39;</span>)
<span style="color:#66d9ef">print</span>(newlogger<span style="color:#f92672">.</span>parent)  <span style="color:#75715e"># &lt;Logger daxin (ERROR)&gt;</span>

<span style="color:#75715e"># 再构建一个子logger</span>
endlogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin.new.end&#39;</span>)
<span style="color:#66d9ef">print</span>(endlogger<span style="color:#f92672">.</span>parent)         <span style="color:#75715e"># &lt;Logger daxin.new (ERROR)&gt;</span>
<span style="color:#66d9ef">print</span>(endlogger<span style="color:#f92672">.</span>parent<span style="color:#f92672">.</span>parent)  <span style="color:#75715e"># &lt;Logger daxin (ERROR)&gt;</span>
<span style="color:#66d9ef">print</span>(endlogger<span style="color:#f92672">.</span>parent<span style="color:#f92672">.</span>parent<span style="color:#f92672">.</span>parent)  <span style="color:#75715e"># &lt;RootLogger root (INFO)&gt; 为什么？</span>
</code></pre></div><p>明明没有为mylogger指定parent，那么为什么他的parent会是root logger？ root logger是啥？</p>
<h2 id="34-为什么是root-logger">3.4 为什么是root logger</h2>
<p>我们没有定义过，那么肯定是logging模块中定义的，那么来看一下logging的源码。大约在logging的1731行有如下代码:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">root <span style="color:#f92672">=</span> RootLogger(WARNING)
Logger<span style="color:#f92672">.</span>root <span style="color:#f92672">=</span> root
Logger<span style="color:#f92672">.</span>manager <span style="color:#f92672">=</span> Manager(Logger<span style="color:#f92672">.</span>root)
</code></pre></div><p>我们发现logging帮我们实例化了一个logger，名字叫root，接下来查看RootLogger发现(1585行)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">RootLogger</span>(Logger):
    <span style="color:#66d9ef">def</span> __init__(self, level):
        Logger<span style="color:#f92672">.</span>__init__(self, <span style="color:#e6db74">&#34;root&#34;</span>, level)
</code></pre></div><p>RootLogger继承自Logger类，它为我们创建了一个logger，且级别为Warning(20)，那为什么我们创建的logger会关联root logger呢？继续来看源码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e"># 1837行</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getLogger</span>(name<span style="color:#f92672">=</span>None):
    <span style="color:#66d9ef">if</span> name:
        <span style="color:#75715e"># 如果指定了logger名称</span>
        <span style="color:#66d9ef">return</span> Logger<span style="color:#f92672">.</span>manager<span style="color:#f92672">.</span>getLogger(name)   
    <span style="color:#66d9ef">else</span>:
        <span style="color:#75715e"># 如果没有指定logger名称，默认返回构建好的root logger</span>
        <span style="color:#66d9ef">return</span> root    

<span style="color:#75715e"># 1160行，Logger.manager.getLogger</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">getLogger</span>(self, name):

    rv <span style="color:#f92672">=</span> None
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> isinstance(name, str):
        <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">TypeError</span>(<span style="color:#e6db74">&#39;A logger name must be a string&#39;</span>)
    _acquireLock()
    <span style="color:#66d9ef">try</span>:
        <span style="color:#75715e"># 非初次创建，这里先省略</span>
        <span style="color:#66d9ef">if</span> name <span style="color:#f92672">in</span> self<span style="color:#f92672">.</span>loggerDict:    
            <span style="color:#f92672">...</span> <span style="color:#f92672">...</span> 
        <span style="color:#75715e"># 初次创建，主要看下面的</span>
        <span style="color:#66d9ef">else</span>:   
            rv <span style="color:#f92672">=</span> (self<span style="color:#f92672">.</span>loggerClass <span style="color:#f92672">or</span> _loggerClass)(name)   <span style="color:#75715e"># logger(name)</span>
            rv<span style="color:#f92672">.</span>manager <span style="color:#f92672">=</span> self   <span style="color:#75715e"># 为logger的实例，构建manager属性</span>
            self<span style="color:#f92672">.</span>loggerDict[name] <span style="color:#f92672">=</span> rv  <span style="color:#75715e"># 在manager属性的字典中，新增{name:loggerobj},通过key来获取对应的logger，所以当传入的name相同时，多次执行返回的是相同的logger。</span>
            self<span style="color:#f92672">.</span>_fixupParents(rv)  <span style="color:#75715e"># 看看这里做了什么？</span>
    <span style="color:#66d9ef">finally</span>:
        _releaseLock()
    <span style="color:#66d9ef">return</span> rv

<span style="color:#75715e"># 1211行  _fixupParents()</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">_fixupParents</span>(self, alogger):
    name <span style="color:#f92672">=</span> alogger<span style="color:#f92672">.</span>name
    i <span style="color:#f92672">=</span> name<span style="color:#f92672">.</span>rfind(<span style="color:#e6db74">&#34;.&#34;</span>)
    rv <span style="color:#f92672">=</span> None
    <span style="color:#f92672">...</span> <span style="color:#f92672">...</span> 
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> rv:
         <span style="color:#75715e"># 这里定义了：如果名字中，没有点(没有parent)，那么他的parent就是root</span>
        rv <span style="color:#f92672">=</span> self<span style="color:#f92672">.</span>root   
    alogger<span style="color:#f92672">.</span>parent <span style="color:#f92672">=</span> rv
</code></pre></div><h2 id="35-root-logger是啥">3.5 root logger是啥？</h2>
<p>        现在想一想为什么我们一开始可以直接使用logging.basicConfig来设置日志的输出格式？根据我们上面的日志处理流程图，我们知道：没有logger，没有handler，没有format，它是怎么输出的呢。那么下面来看一下basicConfig的原码</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">basicConfig</span>(<span style="color:#f92672">**</span>kwargs):
    _acquireLock()
    <span style="color:#66d9ef">try</span>:  
        <span style="color:#75715e"># 我们发现这里其实是针对root logger 的定义及操作</span>
        <span style="color:#66d9ef">if</span> len(root<span style="color:#f92672">.</span>handlers) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
            handlers <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;handlers&#34;</span>, None)
            <span style="color:#f92672">...</span> <span style="color:#f92672">...</span>
            <span style="color:#66d9ef">if</span> handlers <span style="color:#f92672">is</span> None:
                filename <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;filename&#34;</span>, None)
                mode <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;filemode&#34;</span>, <span style="color:#e6db74">&#39;a&#39;</span>)
                <span style="color:#66d9ef">if</span> filename:
                    h <span style="color:#f92672">=</span> FileHandler(filename, mode)
                <span style="color:#66d9ef">else</span>:
                    stream <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;stream&#34;</span>, None)
                    <span style="color:#75715e"># 这里会为root logger创建一个Handler，这里stream为None，在StreamHandler中，会设置为stderr</span>
                    h <span style="color:#f92672">=</span> StreamHandler(stream)    
                 <span style="color:#75715e"># 在handlers中添加 这个新的 handler</span>
                handlers <span style="color:#f92672">=</span> [h]  
            dfs <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;datefmt&#34;</span>, None)
            style <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;style&#34;</span>, <span style="color:#e6db74">&#39;%&#39;</span>)
            <span style="color:#66d9ef">if</span> style <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> _STYLES:
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#39;Style must be one of: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> <span style="color:#e6db74">&#39;,&#39;</span><span style="color:#f92672">.</span>join(
                                 _STYLES<span style="color:#f92672">.</span>keys()))
            <span style="color:#75715e"># 如果没有给定format，这里定义了默认的格式，在 _STYLES[style][1]中，我们发现默认格式为 {levelname}:{name}:{message}</span>
            fs <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;format&#34;</span>, _STYLES[style][<span style="color:#ae81ff">1</span>])  
            <span style="color:#75715e"># 构建Formatter</span>
            fmt <span style="color:#f92672">=</span> Formatter(fs, dfs, style)  
            <span style="color:#66d9ef">for</span> h <span style="color:#f92672">in</span> handlers:
                <span style="color:#66d9ef">if</span> h<span style="color:#f92672">.</span>formatter <span style="color:#f92672">is</span> None:
                    h<span style="color:#f92672">.</span>setFormatter(fmt)  <span style="color:#75715e"># 把formatter绑定在了handler上</span>
                
                <span style="color:#75715e"># 把上面创建的handler，绑定到root logger上</span>
                root<span style="color:#f92672">.</span>addHandler(h)
            level <span style="color:#f92672">=</span> kwargs<span style="color:#f92672">.</span>pop(<span style="color:#e6db74">&#34;level&#34;</span>, None)
            <span style="color:#66d9ef">if</span> level <span style="color:#f92672">is</span> <span style="color:#f92672">not</span> None:
                root<span style="color:#f92672">.</span>setLevel(level)
            <span style="color:#66d9ef">if</span> kwargs:
                keys <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;, &#39;</span><span style="color:#f92672">.</span>join(kwargs<span style="color:#f92672">.</span>keys())
                <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#39;Unrecognised argument(s): </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#39;</span> <span style="color:#f92672">%</span> keys)
    <span style="color:#66d9ef">finally</span>:
        _releaseLock()
</code></pre></div><p>        看到这，我们知道logging模块在导入时，就为我们创建了一个root logger，为的是让我们方便的直接进行日志输出，当然root logger也符合日志处理逻辑，只不过它的handler和Formatter是有默认值的，如果没有特殊需求，我们可以直接使用logging.basicConfig，来定制root logger的handler和Formatter等。</p>
<h3 id="351-basicconfig常用参数">3.5.1 basicConfig常用参数</h3>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">filename</td>
<td>指定日志输出目标文件的文件名，指定该设置项后日志信心就不会被输出到控制台了</td>
</tr>
<tr>
<td style="text-align:center">filemode</td>
<td>指定日志文件的打开模式，默认为&rsquo;a'。需要注意的是，该选项要在filename指定时才有效</td>
</tr>
<tr>
<td style="text-align:center">format</td>
<td>指定日志格式字符串，即指定日志输出时所包含的字段信息以及它们的顺序。logging模块定义的格式字段下面会列出。</td>
</tr>
<tr>
<td style="text-align:center">datefmt</td>
<td>指定日期/时间格式。需要注意的是，该选项要在format中包含时间字段%(asctime)s时才有效</td>
</tr>
<tr>
<td style="text-align:center">level</td>
<td>指定日志器的日志级别</td>
</tr>
<tr>
<td style="text-align:center">stream</td>
<td>指定日志输出目标stream，如sys.stdout、sys.stderr以及网络stream。需要说明的是，stream和filename不能同时提供，否则会引发 ValueError异常</td>
</tr>
<tr>
<td style="text-align:center">style</td>
<td>Python 3.2中新添加的配置项。指定format格式字符串的风格，可取值为'%'、'{&lsquo;和&rsquo;$'，默认为'%'</td>
</tr>
<tr>
<td style="text-align:center">handlers</td>
<td>Python 3.3中新添加的配置项。该选项如果被指定，它应该是一个创建了多个Handler的可迭代对象，这些handler将会被添加到root logger。需要说明的是：filename、stream和handlers这三个配置项只能有一个存在，不能同时出现2个或3个，否则会引发ValueError异常。</td>
</tr>
</tbody>
</table>
<h2 id="36-继承关系">3.6 继承关系</h2>
<p>logger是层级结构，不同的logger实例存在继承和传递关系。看下面的例子：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(mylogger<span style="color:#f92672">.</span>getEffectiveLevel())  <span style="color:#75715e"># 20</span>
</code></pre></div><p>明明没有定义logger的级别，为什么会打印20？</p>
<ul>
<li><code>如果设置了level，就先使用自己的level</code>。</li>
<li><code>如果不设置level，继承最近的祖先的level</code>。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(mylogger<span style="color:#f92672">.</span>getEffectiveLevel())   <span style="color:#75715e"># 30(root logger 是30)</span>

<span style="color:#75715e"># 构建一个子logger</span>
mylogger<span style="color:#f92672">.</span>setLevel(<span style="color:#ae81ff">50</span>)
newlogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin.new&#39;</span>)
<span style="color:#66d9ef">print</span>(newlogger<span style="color:#f92672">.</span>getEffectiveLevel())  <span style="color:#75715e"># 50,未设置时，继承最近的父类。</span>
</code></pre></div><p>如果所有的父logger则，直接继承root logger，则级别为20.</p>
<h1 id="4-handler类">4 handler类</h1>
<p>        handler类一般称为日志分发器，它是一个基类，用于控制日志信息输出的目的地，可以是控制台、文件。不要直接对它进行实例化，可以使用它提供的几个子类，可以实现不同的输出功能：</p>
<ol>
<li>StreamHandler类：</li>
<li>NullHandler类：</li>
<li>FileHandler类：</li>
</ol>
<p>可以对它进行如下功能的定制：</p>
<ol>
<li>可以单独设置level</li>
<li>可以单独设置formattrt格式</li>
<li>可以单独设置filter过滤器</li>
</ol>
<p><strong><code>需要注意的是，我们创建的handler是需要通过绑定在logger上，才可以被触发的。</code></strong></p>
<h2 id="41-streamhandler">4.1 StreamHandler</h2>
<p>流式handler，一般用于输出到屏幕上。它的使用方法为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">StreamHandler(stream<span style="color:#f92672">=</span>None)
</code></pre></div><p>当stream不指定时，默认输出位置为sys.stderr(标准错误输出)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging
<span style="color:#f92672">import</span> sys

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
<span style="color:#66d9ef">print</span>(mylogger<span style="color:#f92672">.</span>getEffectiveLevel())   <span style="color:#75715e"># 30(root logger 是30)</span>

<span style="color:#75715e"># 构建一个handler</span>
myhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>StreamHandler(stream<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stdout)

<span style="color:#75715e"># 将handler绑定在logger上</span>
mylogger<span style="color:#f92672">.</span>addHandler(myhandler) 

mylogger<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#39;hello world &#39;</span>) <span style="color:#75715e"># hello world</span>
<span style="color:#75715e"># 由于没有定义格式，默认情况下只输出日志内容</span>
</code></pre></div><h2 id="42-filehandler">4.2 FileHandler</h2>
<p>故名思议，用于输出到文件中去。它的使用方法为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">FileHandler(filename, mode<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;a&#39;</span>, encoding<span style="color:#f92672">=</span>None, delay<span style="color:#f92672">=</span>False)
</code></pre></div><ul>
<li>filename：表示日志文件的名称(文件可以不存在)</li>
<li>mode：日志文件的打开方式(默认为<code>追加</code>模式)</li>
<li>encoding: 打开文件的编码格式，不访问的话可以设置为UTF-8</li>
<li>delay：是否在保存时额外执行一次flush</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
mylogger<span style="color:#f92672">.</span>setLevel(<span style="color:#ae81ff">10</span>)

<span style="color:#75715e"># 构建一个handler</span>
myhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>FileHandler(filename<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;C:\Users\Dahl\Desktop\access.log&#39;</span>)

<span style="color:#75715e"># 将handler绑定在logger上</span>
mylogger<span style="color:#f92672">.</span>addHandler(myhandler)

mylogger<span style="color:#f92672">.</span>warning(<span style="color:#e6db74">&#39;hello world &#39;</span>) <span style="color:#75715e"># 输出到文件中</span>
</code></pre></div><h2 id="43-多个handler">4.3 多个Handler</h2>
<p>一个logger是可以被添加多个handler的，多个Handler也是按照level进行比较输出的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging
<span style="color:#f92672">import</span> sys

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
mylogger<span style="color:#f92672">.</span>setLevel(<span style="color:#ae81ff">10</span>)

<span style="color:#75715e"># 构建一个handler</span>
myhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>FileHandler(filename<span style="color:#f92672">=</span><span style="color:#e6db74">r</span><span style="color:#e6db74">&#39;C:\Users\Dahl\Desktop\access.log&#39;</span>)
<span style="color:#66d9ef">print</span>(myhandler<span style="color:#f92672">.</span>level)

<span style="color:#75715e"># 构建两个handler</span>
newhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>StreamHandler(stream<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stdout)
newhandler<span style="color:#f92672">.</span>setLevel(<span style="color:#ae81ff">30</span>)
<span style="color:#66d9ef">print</span>(newhandler<span style="color:#f92672">.</span>level)

<span style="color:#75715e"># 将handler绑定在logger上</span>
mylogger<span style="color:#f92672">.</span>addHandler(myhandler)
mylogger<span style="color:#f92672">.</span>addHandler(newhandler)

mylogger<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#39;hello world &#39;</span>) 
</code></pre></div><p>上面代码只会输出到文件中去，因为newhandler的级别为30，要高于写入日志的级别20，所以newhandler不会输出这条日志，另外，新建的handler如果不设置Level，那么它的level是0，即只要logger转发过来一条匹配的日志消息，所有为0的handler都会处理。</p>
<h2 id="44-handler的常用方法">4.4 handler的常用方法</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Handler.setLevel()</td>
<td>设置handler将会处理的日志消息的最低严重级别</td>
</tr>
<tr>
<td>Handler.setFormatter()</td>
<td>为handler设置一个格式器对象</td>
</tr>
<tr>
<td>Handler.addFilter()<!-- raw HTML omitted -->Handler.removeFilter()</td>
<td>为handler添加 和 删除一个过滤器对象</td>
</tr>
</tbody>
</table>
<h1 id="5-formatter类">5 Formatter类</h1>
<p>Formater对象用于配置日志信息的最终顺序、结构和内容。与logger以及Handler基类不同的是，我们可以直接实例化Formatter类，来构造自己的输出格式。Formatter类的构造方法定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">Formatter(fmt<span style="color:#f92672">=</span>None, datefmt<span style="color:#f92672">=</span>None, style<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;%&#39;</span>)
</code></pre></div><ul>
<li>fmt：表示日志格式字符串</li>
<li>datefmt：表示时间格式</li>
<li>style：表示风格（%一般为C风格）</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging
<span style="color:#f92672">import</span> sys

<span style="color:#75715e"># 构建一个logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)

<span style="color:#75715e"># 构建一个handler</span>
myhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>StreamHandler(stream<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stdout)

<span style="color:#75715e"># 将handler绑定在logger上</span>
mylogger<span style="color:#f92672">.</span>addHandler(myhandler)

<span style="color:#75715e"># 构建一个Formatter</span>
myformatter <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>Formatter(fmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>,datefmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;%Y/%m/</span><span style="color:#e6db74">%d</span><span style="color:#e6db74"> %H:%M:%S&#34;</span>)

<span style="color:#75715e"># 将formatter绑定在handler上</span>
myhandler<span style="color:#f92672">.</span>setFormatter(myformatter)

mylogger<span style="color:#f92672">.</span>warning(<span style="color:#e6db74">&#39;hello world &#39;</span>)  <span style="color:#75715e"># 2019/03/06 22:16:58 hello world </span>
</code></pre></div><p>需要注意的是：<code>一个handler只能绑定一个Formatter</code>，如果不指定Formatter的格式，那么默认为:<code>%(message)s</code></p>
<h1 id="6-filter类">6 Filter类</h1>
<p>        Filter可以被Handler和Logger用来做比level更细粒度的、更复杂的过滤功能。Filter是一个过滤器基类，它只允许某个logger层级下的日志事件通过过滤。比如指定了过滤器fliter(&lsquo;daxin&rsquo;)，那么当这个过滤器绑定在logger或者handler上时，会只允许&rsquo;daxin',&lsquo;daxin.A&rsquo;,&lsquo;daxin.B&rsquo;,&lsquo;daxin.A.B&rsquo;这种name的日志信息通过，而&rsquo;daxindaxin.a&rsquo;就不行。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging

<span style="color:#75715e"># 构建logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)
newlogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin.new&#39;</span>)

<span style="color:#75715e"># 构建filter</span>
myfilter <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>Filter(<span style="color:#e6db74">&#39;daxin.new&#39;</span>)

<span style="color:#75715e"># 绑定fliter</span>
mylogger<span style="color:#f92672">.</span>addFilter(myfilter)
newlogger<span style="color:#f92672">.</span>addFilter(myfilter)

mylogger<span style="color:#f92672">.</span>warning(<span style="color:#e6db74">&#39;mylogger  ~~~ hello world&#39;</span>)
newlogger<span style="color:#f92672">.</span>warning(<span style="color:#e6db74">&#39;newlogger ~~~ hello world&#39;</span>)

<span style="color:#75715e"># newlogger ~~~ hello world</span>
</code></pre></div><p>我们看到只有newlogger输出了，因为mylogger的name为daxin，不匹配filter的daxin.new的过滤，所以被阻塞了。</p>
<p>在logging.Filter类的filter方法中，我们看到</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">filter</span>(self, record):
    <span style="color:#66d9ef">if</span> self<span style="color:#f92672">.</span>nlen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">elif</span> self<span style="color:#f92672">.</span>name <span style="color:#f92672">==</span> record<span style="color:#f92672">.</span>name:
        <span style="color:#66d9ef">return</span> True
    <span style="color:#66d9ef">elif</span> record<span style="color:#f92672">.</span>name<span style="color:#f92672">.</span>find(self<span style="color:#f92672">.</span>name, <span style="color:#ae81ff">0</span>, self<span style="color:#f92672">.</span>nlen) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>:
        <span style="color:#66d9ef">return</span> False
    <span style="color:#66d9ef">return</span> (record<span style="color:#f92672">.</span>name[self<span style="color:#f92672">.</span>nlen] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;.&#34;</span>)
</code></pre></div><p>其本质上其实就等于name.startswith(filter.name)</p>
<h1 id="7-信息传递">7 信息传递</h1>
<p>当我们使用子定义的logger时，我们会发现很好玩的事情，请看如下代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging
<span style="color:#f92672">import</span> sys

FORMAT <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>
logging<span style="color:#f92672">.</span>basicConfig(level<span style="color:#f92672">=</span>logging<span style="color:#f92672">.</span>INFO, format<span style="color:#f92672">=</span>FORMAT)

<span style="color:#75715e"># 构建logger</span>
mylogger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;daxin&#39;</span>)

<span style="color:#75715e"># 构建handler</span>
myhandler <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>StreamHandler(stream<span style="color:#f92672">=</span>sys<span style="color:#f92672">.</span>stdout)

<span style="color:#75715e"># 绑定handler</span>
mylogger<span style="color:#f92672">.</span>addHandler(myhandler)

mylogger<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#39;mylogger  ~~~ hello world&#39;</span>)

<span style="color:#75715e"># mylogger  ~~~ hello world</span>
<span style="color:#75715e"># 2019-03-07 19:42:57,556 mylogger  ~~~ hello world</span>
</code></pre></div><p>为什么会出现两一个条记录？这是因为logger的<code>propagate属性</code>。</p>
<ul>
<li>在logger初始化时，propagate属性的<code>默认值为True</code></li>
<li>为True时，当logger收到日志消息后通过level和fliter后，发送给所有绑定的handlers，还会继续传递给自己的父logger。</li>
<li>父logger重复这个过程。</li>
</ul>
<h1 id="8-过程分析">8 过程分析</h1>
<p>        根据上面的的四大类，那么我们再来看一下流程图，下面以一个logger为参照，当一个日志消息需要进行输出，那么它会经过以下步骤：</p>
<ol>
<li>如果消息在某一个logger对象上产生，这个logger就是当前logger，首先消息level要和当前logger的Effectivelevel比较，如果低于当前logger的EffectiveLevel，则流程结束；否则生成log记录。</li>
<li>日志记录会交给当前logger的所有handler处理，记录还要和每一个handler的级别分别比较，低的不处理，否则按照handler输出日志记录</li>
<li>当前logger的所有handler处理完毕后，查看自己的propagate属性，如果是True表示向父logger传递这个日志记录，否则到此流程结束</li>
<li>如果日志记录传递到父logger，<code>不需要和父logger的level比较</code>，而是直接交给父的所有handler，父logger成为当前logger，重复2、3步骤，直到当前logger的父logger是None退出，也就是说当前logger最后一般是root logger(是否能到root logger要看中间的logger是否允许propagate)</li>
</ol>
<blockquote>
<p>logger实例初始的propagate属性为True，即允许向父logger传递消息</p>
</blockquote>
<p>PS：如果root没有handler，就默认创建一个StreamHandler，如果设置了filename，就创建一个FileHandler。如果设置了format参数，就会用它生成一个Formatter对象，否则会生成缺省的Formattrt，并把这个Formatter加入到刚才创建的handler上，然后把这些handler加入到root.handlers列表上，level是设置给root logger的，如果root.handlers列表不为空，logging.basicConfig的调用什么都不做。</p>
<h1 id="9-日志切割">9 日志切割</h1>
<p>在生产上，我们不会向上面那样只是定义出日志的格式，就好了，还要考虑很多其他问题</p>
<ul>
<li>日志可以无限大吗</li>
<li>日志都要存放在一个文件中么</li>
</ul>
<p>logging.handlers主要包含两个类，用于对日志进行分割处理</p>
<ul>
<li><code>RotatingFileHandler</code>：按照大小来切割日志</li>
<li><code>TimedRotatingFileHandler</code>：按照时间来切割日志</li>
</ul>
<h2 id="91-按照大小切割日志">9.1 按照大小切割日志</h2>
<p>下面是一个例子,其中：</p>
<ul>
<li>maxBytes: 表示单个文件的大小</li>
<li>backupCount: 表示切割文件的总个数(超过时，依次覆盖)</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> logging.handlers <span style="color:#f92672">import</span> RotatingFileHandler
<span style="color:#f92672">import</span> logging
<span style="color:#f92672">import</span> time

logger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;hello&#39;</span>)
logger<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>INFO)

handler <span style="color:#f92672">=</span> RotatingFileHandler(<span style="color:#e6db74">&#39;/Users/lixin/test.log&#39;</span>, maxBytes<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">1024</span>,backupCount<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>, encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;UTF-8&#39;</span>)
handler<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>INFO)
formatter <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>Formatter(fmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> [ </span><span style="color:#e6db74">%(levelname)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(funcName)s</span><span style="color:#e6db74"> ] </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>)
handler<span style="color:#f92672">.</span>setFormatter(formatter)
logger<span style="color:#f92672">.</span>addHandler(handler)

<span style="color:#75715e">#################</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">10000</span>):
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">0.01</span>)
    logger<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#39;msg = {}&#39;</span><span style="color:#f92672">.</span>format(i))
</code></pre></div><p>注意：当maxBytes和backupCount中任意一个参数为0时，切割方式不生效</p>
<h2 id="92-按照时间切割日志">9.2 按照时间切割日志</h2>
<p>下面时一个例子，其中</p>
<ul>
<li>when: 按照什么来切割。</li>
<li>interval：间隔多久。</li>
<li>backupCount: 切分几个</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> logging
<span style="color:#f92672">from</span> logging.handlers <span style="color:#f92672">import</span> TimedRotatingFileHandler
<span style="color:#f92672">import</span> time

logger <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>getLogger(<span style="color:#e6db74">&#39;hello&#39;</span>)
logger<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>INFO)

handler <span style="color:#f92672">=</span> TimedRotatingFileHandler(<span style="color:#e6db74">&#39;/Users/lixin/text.log&#39;</span>,when<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;S&#39;</span>,interval<span style="color:#f92672">=</span><span style="color:#ae81ff">10</span>,backupCount<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>,encoding<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;UTF-8&#39;</span>)
handler<span style="color:#f92672">.</span>setLevel(logging<span style="color:#f92672">.</span>INFO)

formatter <span style="color:#f92672">=</span> logging<span style="color:#f92672">.</span>Formatter(fmt<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">%(asctime)s</span><span style="color:#e6db74"> [ </span><span style="color:#e6db74">%(levelname)s</span><span style="color:#e6db74"> </span><span style="color:#e6db74">%(funcName)s</span><span style="color:#e6db74"> ] </span><span style="color:#e6db74">%(message)s</span><span style="color:#e6db74">&#39;</span>)
handler<span style="color:#f92672">.</span>setFormatter(formatter)

logger<span style="color:#f92672">.</span>addHandler(handler)


<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">1000000</span>):
    time<span style="color:#f92672">.</span>sleep(<span style="color:#ae81ff">1</span>)
    logger<span style="color:#f92672">.</span>error(<span style="color:#e6db74">&#39;msg = {}&#39;</span><span style="color:#f92672">.</span>format(i))
</code></pre></div><p>when可以指定的类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">值</th>
<th style="text-align:center">间隔的单位</th>
<th style="text-align:center">当atTime参数设定时</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lsquo;S&rsquo;</td>
<td style="text-align:center">Seconds</td>
<td style="text-align:center">Ignored</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;M&rsquo;</td>
<td style="text-align:center">Minutes</td>
<td style="text-align:center">Ignored</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;H&rsquo;</td>
<td style="text-align:center">Hours</td>
<td style="text-align:center">Ignored</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;D&rsquo;</td>
<td style="text-align:center">Days</td>
<td style="text-align:center">Ignored</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;W0&rsquo;-&lsquo;W6&rsquo;</td>
<td style="text-align:center">Weekday (0=Monday)</td>
<td style="text-align:center">Used to compute initial rollover time</td>
</tr>
<tr>
<td style="text-align:center">&lsquo;midnight&rsquo;</td>
<td style="text-align:center">Roll over at midnight, if atTime not specified, else at time atTime</td>
<td style="text-align:center">Used to compute initial rollover time</td>
</tr>
<tr>
<td style="text-align:center">{% endraw %}</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>

</div>


  
</article>
      <footer id="main-footer" class="container main_footer">
  

  <div class="container nav foot no-print">
  
<a href="https://dachenzi.github.io/license">license</a>


  <a class="toplink" href="#">back to top</a>

</div>

  <div class="container credits">
  
<div class="container footline">
  
  code with <!-- raw HTML omitted --><!-- raw HTML omitted -->


</div>


  
<div class="container copyright">
  
  (c) 2015 Lee xin.


</div>


</div>

</footer>

    </main>
    
<script type="text/javascript">
  (function() {
    
    
    if (window.location.hostname == "localhost")
      return;
    var dsq = document.createElement('script'); dsq.async = true; dsq.type = 'text/javascript';
    dsq.src = '//your_disqus_shortname.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>



<script src="/js/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>



    
  </body>
</html>

