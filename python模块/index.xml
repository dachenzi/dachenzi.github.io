<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python模块s on dahl&#39;s blog</title>
    <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/</link>
    <description>Recent content in Python模块s on dahl&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-EN</language>
    <managingEditor>dahlhin.li@gmail.com (daxin.li)</managingEditor>
    <webMaster>dahlhin.li@gmail.com (daxin.li)</webMaster>
    <copyright>(c) 2015 Lee xin.</copyright><atom:link href="https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1-random模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/1-random%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/1-random%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
1 随机数random  之所以在这里介绍random模块是因为，我们可能需要在列表中随机挑选一个或几个重复或者不重复的数据，这时，就可以使用python得知的radnom模块。我们常用的函数如下：
random.randint(a,b): 返回[a,b]之间的整数,包含a和b本身。 random.choice(seq): 从非空序列的元素中随机挑选一个元素。 random.randrange([start,] stop, [,step]): 从指定范围内获取一个随机数。和range相同属于前包后不包区间, start(起始) 默认为0，step（步长) 默认为1 random.shuffle(list) --&amp;gt; None : 直接对原列表进行洗牌(随机打乱) random.sample(population, k): 从population(样本空间)中随机选取出k个不同的元素，返回一个新的列表 下面是例子：
In [24]: import random In [25]: random.randint(1,10) Out[25]: 4 In [26]: random.choice(range(10)) Out[26]: 5 In [27]: random.randrange(1) Out[27]: 0 In [28]: random.randrange(0,5,2) Out[28]: 2 In [31]: lst = list(range(10)) In [32]: random.shuffle(lst) In [33]: lst Out[33]: [8, 1, 6, 4, 3, 9, 7, 0, 5, 2] In [34]: random.</description>
    </item>
    
    <item>
      <title>2-datetime模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/2-datetime%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/2-datetime%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
文章目录 1 时间 2 datetime模块  2.1 获取当前日期和时间 2.2 获取指定日期和时间 2.3 datetime转换为timestamp 2.4 timestamp转换为datetime 2.5 str转换为datetime 2.6 datetime转换为str 2.7 datetime加减   3 time模块   1 时间  在我们日常写代码的过程中很多时候会用到时间，比如：输出当前时间，计算程序的运行时间，让程序休息一定的时间然后再做某些事情等等，Python内置了不少用于计算和输出时间的模块，最常用的是time模块和datetime模块。在Python 3中建议使用datetime模块。
2 datetime模块  datetime是Python标准库中用于处理时间的模块，是date模块和time模块的合集。它在内部提供了多种类，用于处理不同场景下的时间需求。
class datetime.date : 日期类，包含year，month 和 day等 class datetime.time : 时间类，包含hour，minute，second，microsecound 和 tzinfo等 class datetime.datetime : 日期和时间的组合 class datetime.timedelta : 表示两个日期、时间或日期时间实例到微秒分辨率之间的差异。 class datetime.tzinfo : 时区信息对象的抽象基类 class datetime.timezone : 根据tzinfo组合UTC时间的类(UTC时间基类)  常用的是datetime.datetime类和datetime.timedelta类，其他类可以不关注
 2.1 获取当前日期和时间 通过datetime模块我们可以方便的获取当前的时间</description>
    </item>
    
    <item>
      <title>3-concurrent模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/3-concurrent%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/3-concurrent%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
文章目录 1 conturrent包 2 future模块 3 ThreadPoolExecutor对象 4 Future对象 5 ProcessPoolExecutor对象 6 支持上下文管理 7 异步爬网站的小例子  1 conturrent包 conturrent包内只包含了一个future模块，它为异步执行调用提供了高级的接口。
2 future模块 主要提供了两个用于异步执行的类：
 ThreadpPoolExecutor：异步调用的线程池的执行器 ProcessPoolExecutor：异步调用的进程池的执行器   两者实现相同的接口，该接口由抽象Executor类定义。
 3 ThreadPoolExecutor对象 提供了以下方法用于构建和执行多线程任务：
   方法 含义     ThreadpPoolExecutor(max_workers=None, thread_name_prefix=&#39;&#39;) 池中至多创建max_workers个线程的池来同时异步执行，返回Executor实例，如果max_workers没有指定，那么会开启cpu核数(或1) * 5 个线程   submit(fn, *args, **kwargs) 提交执行的函数及其参数，返回Future类的实例   shutdown(wait=True) 清理池    基本使用:
import concurrent.futures def worker(name, count=1000): total = 0 for i in range(count): total += 1 return name, total fs = [] executor = concurrent.</description>
    </item>
    
    <item>
      <title>4-logging模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/4-logging%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/4-logging%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
文章目录 1 logging模块  1.1 日志级别 1.2 日志格式字符串 1.3 快速使用  1.3.1 修改日期格式 1.3.2 输出到文件中 1.3.3 构建消息     2 处理流程 3 logger类  3.1 getLogger工厂方法 3.2 实例常用方法 3.3 层次结构 3.4 为什么是root logger 3.5 root logger是啥？  3.5.1 basicConfig常用参数   3.6 继承关系   4 handler类  4.1 StreamHandler 4.2 FileHandler 4.3 多个Handler 4.4 handler的常用方法   5 Formatter类 6 Filter类 7 信息传递 8 过程分析 9 日志切割  9.</description>
    </item>
    
    <item>
      <title>5-paramiko模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/5-paramiko%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/5-paramiko%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
1 简介  ssh是一个协议，OpenSSH是其中一个开源实现，paramiko是Python的一个库，支持Python 2.6+ 和Python 3.3+ 版本，实现了SSHv2协议(底层使用cryptography)。有了Paramiko以后，我们就可以在Python代码中直接使用SSH协议对远程服务器执行操作，而不是通过ssh命令对远程服务器进行操作。
由于paramiko属于第三方库，所以需要使用如下命令先行安装
pip3 install paramiko # 测试 python3 -c &amp;#39;import paramiko&amp;#39; 2 Paramiko介绍  paramiko包含两个核心组件：SSHClient和SFTPClient。
 SSHClient的作用类似于Linux的ssh命令，是对SSH会话的封装，该类封装了传输(Transport)，通道(Channel)及SFTPClient建立的方法(open_sftp)，通常用于执行远程命令。 SFTPClient的作用类似与Linux的sftp命令，是对SFTP客户端的封装，用以实现远程文件操作，如文件上传、下载、修改文件权限等操作。  2.1 Paramiko中的几个基础名词：  Channel：是一种类Socket，一种安全的SSH传输通道； transport：是一种加密的会话，使用时会同步创建了一个加密的Tunnels(通道)，这个Tunnels叫做Channel； Session：是client与Server保持连接的对象，用connect()/start_client()/start_server()开始会话。  3 Paramiko的基本使用  基于常用的两个核心组件进行说明。
3.1 SSHClient介绍  下面是一个使用SSHClient连接服务器并执行命令的操作步骤：（支持密码认证和密钥认证）
import paramiko #实例化SSHClient client = paramiko.SSHClient() #自动添加策略，保存服务器的主机名和密钥信息，如果不添加，那么不再本地know_hosts文件中记录的主机将无法连接 client.set_missing_host_key_policy(paramiko.AutoAddPolicy()) #连接SSH服务端，以用户名和密码进行认证 client.connect(hostname=&amp;#39;10.0.0.3&amp;#39;,port=22,username=&amp;#39;root&amp;#39;,password=&amp;#39;123456&amp;#39;) #打开一个Channel并执行命令 stdin,stdout,stderr = client.exec_command(&amp;#39;df -h &amp;#39;) # stdout 为正确输出，stderr为错误输出，同时只有1个变量有值 #打印执行结果 print(stdout.read().decode(&amp;#39;utf-8&amp;#39;)) #关闭SSHClient client.close() SSHClient使用私钥连接:
import paramiko # 配置私人密钥文件位置 private = paramiko.</description>
    </item>
    
    <item>
      <title>6-subprocess模块-tempfile模块</title>
      <link>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/6-subprocess%E6%A8%A1%E5%9D%97-tempfile%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>dahlhin.li@gmail.com (daxin.li)</author>
      <guid>https://dachenzi.github.io/python%E6%A8%A1%E5%9D%97/6-subprocess%E6%A8%A1%E5%9D%97-tempfile%E6%A8%A1%E5%9D%97/</guid>
      <description>{% raw %}
1 subprocess模块  用于执行命令，它取代了比较老得os.system,commands等模块，它通过启动子进程来完成命令的执行，并且提供了更多灵活，高效的方法。
2 subprocess.call 功能类似于os.system 无法捕获结果
subprocess.call(&amp;#39;ls -l&amp;#39;,shell=True) 注意当执行的cmd中有空格的时候，python解释器会认为后面的参数都为第一个命令的参数，这个时候方便起见，都会使用shell=True,它真正的含义是：
 shell=True参数会让subprocess.call接受字符串类型的变量作为命令，并调用shell去执行这个字符串 当shell=False是，subprocess.call只接受数组变量作为命令，并将数组的第一个元素作为命令，剩下的全部作为该命令的参数。  基于安全考虑，官方的推荐是尽量不要设置shell=True。
3 subprocess.check_call 功能和call相同，无法捕捉结果,与call不同的是，check_call默认会检查命令的返回值，如果不是0，则会返回异常subprocess.CalledProcessError
4 subprocess.Popen 用于执行命令，但具有更高的定制化，比如信息的输出，返回码的获取，其调用外部命令的时候，会像C那样fork一个子进程进行执行。
# 格式： Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=&amp;lt;object object at 0x1005ac1c0&amp;gt;, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None)  args: 执行的命令 stdin: 输入 stdout: 输出信息（默认到控制台） stderr: 错误输出信息（默认到控制台） cwd: 切换到某个目录后再执行命令  例子：
subprocess.Popen(&amp;#39;cmd&amp;#39;,shell=True,stdout=subprocess.PIPE) subprocess.Popen([&amp;#39;cmd&amp;#39;],stdout=subprocess.PIPE) --&amp;gt; 一般用这种 上面两行代码功能相同，不写stdout的话，默认会把输出打印到当前的屏幕上,其中PIPE 表示管道符，会把命令的输出方式暂时缓存，然后通过对应的方式.进行读取p.stdout.read()
 stdout 表示标准输出 stdin 表示标准输入，stdin=subprocess.</description>
    </item>
    
  </channel>
</rss>
